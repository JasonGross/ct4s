(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import ProofIrrelevance FunctionalExtensionality.
Require Export Category Functor.
Require Import Common.

Set Implicit Arguments.

Generalizable All Variables.

(** * Subcategories *)

Local Ltac faithful_t :=
  repeat (unfold Object in *; simpl in *;
          match goal with
            | _ => intro
            | _ => progress trivial
            | [ |- _ = _ ] => (apply functional_extensionality_dep; intro)
            | _ => progress simpl_eq
            | [ H : _ = _ |- _ ] => fg_equal_in H
          end).

Section sig_obj_mor.
  Context `(A : @Category objA).
  Variable Pobj : objA -> Prop.
  Variable Pmor : forall s d : sig Pobj, A.(Morphism) (proj1_sig s) (proj1_sig d) -> Prop.
  Variable Pidentity : forall x, @Pmor x x (Identity (C := A) _).
  Variable Pcompose : forall s d d',
                      forall m1 m2,
                        @Pmor d d' m1
                        -> @Pmor s d m2
                        -> @Pmor s d' (Compose (C := A) m1 m2).

  Definition Category_sig : @Category (sig Pobj).
    match goal with
      | [ |- @Category ?obj ] =>
        refine (@Build_Category obj
                                (fun s d => sig (@Pmor s d))
                                (fun x => exist _ _ (Pidentity x))
                                (fun s d d' m1 m2 => exist _ _ (Pcompose (proj2_sig m1)
                                                                         (proj2_sig m2)))
                                _
                                _
                                _
               )
    end;
    abstract (intros; simpl_eq; auto with category).
  Defined.

  Definition proj1_sig_functor : Functor Category_sig A
    := Build_Functor Category_sig A
                     (@proj1_sig _ _)
                     (fun s d => @proj1_sig _ _)
                     (fun _ _ _ _ _ => eq_refl)
                     (fun _ => eq_refl).
End sig_obj_mor.

Arguments proj1_sig_functor {objA A Pobj Pmor Pidentity Pcompose}.

Section sig_obj.
  Context `(A : @Category objA).
  Variable Pobj : objA -> Prop.

  Definition Category_sig_obj : @Category (sig Pobj).
    match goal with
      | [ |- @Category ?obj ] =>
        refine (@Build_Category obj
                                (fun s d => A.(Morphism) (proj1_sig s)
                                                         (proj1_sig d))
                                (fun x => Identity (C := A) (proj1_sig x))
                                (fun s d d' m1 m2 => Compose (C := A) m1 m2)
                                _
                                _
                                _
               )
    end;
    abstract (intros; destruct_sig; simpl; auto with category).
  Defined.

  Definition proj1_sig_obj_functor : Functor Category_sig_obj A
    := Build_Functor Category_sig_obj A
                     (@proj1_sig _ _)
                     (fun s d m => m)
                     (fun _ _ _ _ _ => eq_refl)
                     (fun _ => eq_refl).

  Definition Category_sig_obj_as_sig : @Category (sig Pobj)
    := @Category_sig _ A Pobj
                     (fun _ _ _ => True)
                     (fun _ => I)
                     (fun _ _ _ _ _ _ _ => I).

  Definition sig_functor_obj : Functor Category_sig_obj_as_sig Category_sig_obj
    := Build_Functor Category_sig_obj_as_sig Category_sig_obj
                     (fun x => x)
                     (fun _ _ => @proj1_sig _ _)
                     (fun _ _ _ _ _ => eq_refl)
                     (fun _ => eq_refl).

  Definition sig_functor_obj_inv : Functor Category_sig_obj Category_sig_obj_as_sig
    := Build_Functor Category_sig_obj Category_sig_obj_as_sig
                     (fun x => x)
                     (fun _ _ m => exist _ m I)
                     (fun _ _ _ _ _ => eq_refl)
                     (fun _ => eq_refl).

  Lemma sig_obj_eq
  : ComposeFunctors sig_functor_obj sig_functor_obj_inv
    = IdentityFunctor _
    /\ ComposeFunctors sig_functor_obj_inv sig_functor_obj
       = IdentityFunctor _.
    split; functor_eq; destruct_sig; destruct_head True; reflexivity.
  Qed.

  Lemma sig_obj_compat
  : ComposeFunctors proj1_sig_obj_functor sig_functor_obj
    = proj1_sig_functor.
    functor_eq.
  Qed.
End sig_obj.

Arguments proj1_sig_obj_functor {objA A Pobj}.

Section sig_mor.
  Context `(A : @Category objA).
  Variable Pmor : forall s d, A.(Morphism) s d -> Prop.

  Variable Pidentity : forall x, @Pmor x x (Identity (C := A) _).
  Variable Pcompose : forall s d d',
                      forall m1 m2,
                        @Pmor d d' m1
                        -> @Pmor s d m2
                        -> @Pmor s d' (Compose (C := A) m1 m2).

  Definition Category_sig_mor : @Category objA.
    match goal with
      | [ |- @Category ?obj ] =>
        refine (@Build_Category obj
                                (fun s d => sig (@Pmor s d))
                                (fun x => exist _ (Identity (C := A) x) (Pidentity x))
                                (fun s d d' m1 m2 =>
                                   exist _
                                         (Compose (proj1_sig m1) (proj1_sig m2))
                                         (Pcompose (proj2_sig m1) (proj2_sig m2)))
                                _
                                _
                                _
               )
    end;
    abstract (intros; simpl_eq; auto with category).
  Defined.

  Definition proj1_sig_mor_functor : Functor Category_sig_mor A
    := Build_Functor Category_sig_mor A
                     (fun x => x)
                     (fun s d => @proj1_sig _ _)
                     (fun _ _ _ _ _ => eq_refl)
                     (fun _ => eq_refl).

  Definition Category_sig_mor_as_sig : @Category (sig (fun _ : objA => True))
    := @Category_sig _ A _
                     (fun s d => @Pmor (proj1_sig s) (proj1_sig d))
                     (fun _ => Pidentity _)
                     (fun _ _ _ _ _ m1 m2 => Pcompose m1 m2).

  Definition sig_functor_mor : Functor Category_sig_mor_as_sig Category_sig_mor
    := Build_Functor Category_sig_mor_as_sig Category_sig_mor
                     (@proj1_sig _ _)
                     (fun _ _ m => m)
                     (fun _ _ _ _ _ => eq_refl)
                     (fun _ => eq_refl).

  Definition sig_functor_mor_inv : Functor Category_sig_mor Category_sig_mor_as_sig
    := Build_Functor Category_sig_mor Category_sig_mor_as_sig
                     (fun x => exist _ x I)
                     (fun _ _ m => m)
                     (fun _ _ _ _ _ => eq_refl)
                     (fun _ => eq_refl).

  Lemma sig_mor_eq
  : ComposeFunctors sig_functor_mor sig_functor_mor_inv = IdentityFunctor _
    /\ ComposeFunctors sig_functor_mor_inv sig_functor_mor = IdentityFunctor _.
    split; apply Functor_Eq; repeat intro; destruct_sig; destruct_head True;
    subst_eq_refl_in_match;
    reflexivity.
  Qed.

  Lemma sig_mor_compat
  : ComposeFunctors proj1_sig_mor_functor sig_functor_mor = proj1_sig_functor.
    functor_eq.
  Qed.
End sig_mor.

Arguments proj1_sig_mor_functor {objA A Pmor Pidentity Pcompose}.

Definition Subcategory := @Category_sig.
Definition SubcategoryInclusionFunctor := @proj1_sig_functor.
Definition FullSubcategory := @Category_sig_obj.
Definition FullSubcategoryInclusionFunctor := @proj1_sig_obj_functor.
Definition WideSubcategory := @Category_sig_mor.
Definition WideSubcategoryInclusionFunctor := @proj1_sig_mor_functor.
