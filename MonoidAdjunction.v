(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing ≄ %\ensuremath{\not\simeq}% #&#8772;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
(** printing ℙ %\ensuremath{\mathbb{P}}% #&#x2119;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ↦ %\ensuremath{\mapsto}% #&#21A6# *)
(** printing ↪ %\ensuremath{\hookrightarrow}% #&rarrhk;# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ▻ %\ensuremath{\triangleright}% #&#x25BB;# *)
(** printing ◅ %\ensuremath{\triangleleft}% #&#x25C5;# *)
(** printing ⊣ %\ensuremath{\dashv}% #&#x22a3;# *)
(** printing -| %\ensuremath{\dashv}% #&#x22a3;# *)
(** printing ⊥ %\ensuremath{\bot}% #&#x22a5;# *)
(** printing ⊢ %\ensuremath{\vdash}% #&#x22a2;# *)
(** printing |- %\ensuremath{\vdash}% #&#x22a2;# *)
(** printing ⊤ %\ensuremath{\top}% #&#x22a4;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ≰ %\ensuremath{\not\le}% #&#x2270;# *)
(** printing ≱ %\ensuremath{\not\ge}% #&#x2271;# *)
(** printing ≼ %\ensuremath{\preceq}% #&#x227c;# *)
(** printing ≽ %\ensuremath{\succeq}% #&#x227d;# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import FunctionalExtensionality.
Require Export List.
Require Export Category Functor SetCategory MonoidCategory Adjoint.
Require Import ProductCategory Duals Hom.
Require Import Common Notations.

Set Implicit Arguments.

Generalizable All Variables.

Section MonoidAdjunction.
  Section underlying.
    Definition UnderlyingSetOfMonoid : Functor CategoryOfMonoids CategoryOfTypes.
      refine (Build_Functor CategoryOfMonoids CategoryOfTypes
                            (fun x => projT1 x)
                            (fun s d m => m)
                            _
                            _);
      reflexivity.
    Defined.
  End underlying.

  Section free.
    Local Hint Extern 0 => reflexivity.
    Local Hint Extern 0 => intro.
    Local Hint Extern 0 => rewrite app_nil_r.
    Local Hint Extern 1 => rewrite app_assoc.
    Local Hint Extern 0 => apply map_app.

    Definition FreeMonoidOn (T : Type) : Monoid (list T).
      exists {| id := nil;
                comp := @app _ |};
      split; simpl; unfold monoid_obj;
      abstract auto.
    Defined.

    Definition FreeMonoidMorphism (T U : Type) (f : T -> U)
    : MonoidHomomorphism (FreeMonoidOn T) (FreeMonoidOn U).
      exists (map f);
      abstract auto.
    Defined.

    Definition FreeMonoid : Functor CategoryOfTypes CategoryOfMonoids.
      refine (Build_Functor CategoryOfTypes CategoryOfMonoids
                            (fun x => existT _ _ (FreeMonoidOn x))
                            (fun s d m => FreeMonoidMorphism m)
                            _
                            _);
      abstract (
          intros;
          simpl in *;
            apply MonoidHomomorphism_Eq;
          simpl;
          intros;
          hnf in *;
            match goal with
              | [ H : list _ |- _ ] => induction H; simpl; [ auto | apply f_equal; assumption ]
            end
        ).
    Defined.
  End free.

  Section adjunction.
    Local Open Scope functor_scope.

    Definition LiftMonoidFunction T U (M : Monoid U) (f : T -> U)
    : MonoidHomomorphism (FreeMonoidOn T) M.
      exists (fun l => fold_right (comp M) id (map f l));
      abstract (
          try reflexivity;
          intros; hnf in *; simpl in *;
                  rewrite map_app;
          rewrite fold_right_app;
          simpl;
          generalize (map f m1);
          generalize (map f m2);
          clear;
          intros;
          unfold monoid_obj;
          match goal with
            | [ |- fold_right _ ?x _ =
                   fold_right _ _ _ ★ ?x ] => generalize x; clear
          end;
          pose proof (is_monoid M);
          match goal with
            | [ H : list _ |- _ ] => induction H
          end;
          intros; simpl in *;
                  repeat rewrite left_id;
          repeat rewrite right_id;
          repeat match goal with
                   | [ H : _ |- _ ] => rewrite left_id in H
                   | [ H : _ |- _ ] => rewrite right_id in H
                 end;
          try reflexivity;
          repeat rewrite assoc;
          apply f_equal;
          intuition
        ).
    Defined.

    Definition MonoidFreeUnderlyingAdjunction : FreeMonoid -| UnderlyingSetOfMonoid.
      constructor.
      let F := match goal with [ |- NaturalIsomorphism ?F ?G ] => constr:(F) end in
      let G := match goal with [ |- NaturalIsomorphism ?F ?G ] => constr:(G) end in
      (exists (Build_NaturalTransformation F G
                                           (fun _ f x => f (x :: nil))
                                           (fun _ _ _ => eq_refl))).
      simpl.
      intro x.
      exists (@LiftMonoidFunction (fst x) _ (projT2 (snd x)));
        abstract (
            repeat match goal with
                     | _ => reflexivity
                     | _ => intro
                     | _ => (apply functional_extensionality_dep; intro)
                     | [ |- IsMonoid (cmonoid ?M) ] => (destruct M; simpl in *; assumption)
                     | _ => progress repeat rewrite @right_id
                     | _ => apply MonoidHomomorphism_Eq
                     | _ => progress (simpl in *; hnf in *; idtac)
                     | [ x : MonoidHomomorphism _ _ |- _ ]
                       => (let H := fresh in
                           pose proof (MonoidHomomorphism_IdentityLaw x) as H;
                           simpl in *;
                             rewrite H)
                     | _ => rewrite <- MonoidHomomorphism_CompositionLaw
                     | [ H : _ |- _ ] => rewrite H
                     | [ l : list _ |- _ ] => induction l; simpl
                   end
          ).
    Defined.
  End adjunction.
End MonoidAdjunction.
