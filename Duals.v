(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import JMeq Eqdep.
Require Export Category CategoryIsomorphisms Functor.
(*ProductCategory NaturalTransformation*)
Require Import Common Notations.

Set Implicit Arguments.

Generalizable All Variables.

(** * Dual Categories *)

Local Open Scope category_scope.

Section OppositeCategory.
  Definition OppositeCategory `(C : @Category objC) : @Category objC
    := @Build_Category objC
                       (fun s d => Morphism C d s)
                       (@Identity _ C)
                       (fun _ _ _ m1 m2 => @Compose _ C _ _ _ m2 m1)
                       (fun _ _ _ _ _ _ _ => eq_sym (@Associativity _ _ _ _ _ _ _ _ _))
                       (fun _ _ => @RightIdentity _ _ _ _)
                       (fun _ _ => @LeftIdentity _ _ _ _).
End OppositeCategory.

(*Notation "C ᵒᵖ" := (OppositeCategory C) : category_scope.*)
(*
Section DualCategories.
  Context `(C : @Category objC).
  Context `(D : @Category objD).

  Lemma op_op_id : OppositeCategory (OppositeCategory C) = C.
    clear D objD.
    apply Category_eq.
    unfold OppositeCategory; simpl.
    destruct C; simpl; f_equal.
    apply proof_irrelevance.
    unfold eq_sym.
    repeat change (fun a => ?f a) with f.
    destruct C as [ C' [ ] ]; destruct C'; intros; simpl; reflexivity.
  Qed.

  Lemma op_distribute_prod : OppositeCategory (C * D) = (OppositeCategory C) * (OppositeCategory D).
    spcat_eq.
  Qed.
End DualCategories.

Hint Rewrite @op_op_id @op_distribute_prod : category.

Section DualObjects.
  Context `(C : @Category objC).

  Definition terminal_opposite_initial (o : C) : IsTerminalObject o -> IsInitialObject (C := OppositeCategory C) o
    := fun H o' => H o'.

  Definition initial_opposite_terminal (o : C) : IsInitialObject o -> IsTerminalObject (C := OppositeCategory C) o
    := fun H o' => H o'.

  Definition terminal_to_opposite_initial : TerminalObject C -> InitialObject (OppositeCategory C)
    := Eval cbv beta iota zeta delta [terminal_opposite_initial TerminalObject_IsTerminalObject IsInitialObject_InitialObject proj1_sig proj2_sig] in
        fun x => terminal_opposite_initial x.

  Definition initial_to_opposite_terminal : InitialObject C -> TerminalObject (OppositeCategory C)
    := Eval cbv beta iota zeta delta [initial_opposite_terminal IsTerminalObject_TerminalObject InitialObject_IsInitialObject proj1_sig proj2_sig] in
        fun x => initial_opposite_terminal x.
End DualObjects.
*)

Section OppositeFunctor.
  Context `(C : @Category objC).
  Context `(D : @Category objD).
  Variable F : Functor C D.
  Let COp := OppositeCategory C.
  Let DOp := OppositeCategory D.

  Definition OppositeFunctor : Functor COp DOp
    := Build_Functor COp DOp
                     (fun c : COp => F c : DOp)
                     (fun (s d : COp) (m : C.(Morphism) d s) => MorphismOf F (s := d) (d := s) m)
                     (fun d' d s m1 m2 => FCompositionOf F s d d' m2 m1)
                     (FIdentityOf F).
End OppositeFunctor.

(*Notation "C ᵒᵖ" := (OppositeFunctor C) : functor_scope.*)
(*
Section OppositeFunctor_Id.
  Context `(C : @Category objC).
  Context `(D : @Category objD).
  Variable F : Functor C D.

  Lemma op_op_functor_id : OppositeFunctor (OppositeFunctor F) == F.
    functor_eq; autorewrite with category; trivial.
  Qed.
End OppositeFunctor_Id.

(* not terribly useful, given that this would make [autorewrite with core] give "Anomaly: Uncaught exception Failure("nth"). Please report." *)
(*Hint Rewrite op_op_functor_id.*)

Section OppositeNaturalTransformation.
  Context `(C : @Category objC).
  Context `(D : @Category objD).
  Variables F G : Functor C D.
  Variable T : NaturalTransformation F G.
  Let COp := OppositeCategory C.
  Let DOp := OppositeCategory D.
  Let FOp := OppositeFunctor F.
  Let GOp := OppositeFunctor G.

  Definition OppositeNaturalTransformation : NaturalTransformation GOp FOp.
    refine (Build_NaturalTransformation GOp FOp
      (fun c : COp => T.(ComponentsOf) c : DOp.(Morphism) (GOp c) (FOp c))
      (fun s d m => eq_sym (Commutes T d s m))
    ).
  Defined.
End OppositeNaturalTransformation.

(*Notation "C ᵒᵖ" := (OppositeNaturalTransformation C) : natural_transformation_scope.*)

Section OppositeNaturalTransformation_Id.
  Context `(C : @Category objC).
  Context `(D : @Category objD).
  Variables F G : Functor C D.
  Variable T : NaturalTransformation F G.

  Lemma op_op_nt_id : OppositeNaturalTransformation (OppositeNaturalTransformation T) == T.
    nt_eq; intros; try functor_eq; autorewrite with category; trivial.
  Qed.
End OppositeNaturalTransformation_Id.

(* not terribly useful, given that this would make [autorewrite with core] give "Anomaly: Uncaught exception Failure("nth"). Please report." *)
(*Hint Rewrite op_op_nt_id.*)


(** We include the object type as a parameter, because, otherwise, we
    can't make a category of categories easily. *)
Record Category {obj : Type} :=
  {
    Object :> _ := obj;
    Morphism : obj -> obj -> Type;

    Identity : forall x, Morphism x x;
    Compose : forall s d d', Morphism d d' -> Morphism s d -> Morphism s d';
    Associativity : forall o1 o2 o3 o4
                           (m1 : Morphism o1 o2)
                           (m2 : Morphism o2 o3)
                           (m3 : Morphism o3 o4),
                      Compose (Compose m3 m2) m1 = Compose m3 (Compose m2 m1);
    LeftIdentity : forall a b (f : Morphism a b), Compose (Identity b) f = f;
    RightIdentity : forall a b (f : Morphism a b), Compose f (Identity a) = f
  }.

Delimit Scope category_scope with category.
Delimit Scope object_scope with object.
Delimit Scope morphism_scope with morphism.

Bind Scope category_scope with Category.
Bind Scope object_scope with Object.
Bind Scope morphism_scope with Morphism.

Arguments Object {obj%type} C%category : rename.
Arguments Morphism {obj%type} C%category s%object d%object : rename.
Arguments Identity {obj%type} [C%category] x%object : rename.
Arguments Compose {obj%type} [C%category s%object d%object d'%object] m1%morphism m2%morphism : rename.

Infix "o" := (@Compose _ _ _ _ _) : morphism_scope.

(* create a hint db for all category theory things *)
Create HintDb category discriminated.
(* create a hint db for morphisms in categories *)
Create HintDb morphism discriminated.

Hint Resolve @LeftIdentity @RightIdentity @Associativity : category.
Hint Resolve @LeftIdentity @RightIdentity @Associativity : morphism.
Hint Rewrite @LeftIdentity @RightIdentity : category.
Hint Rewrite @LeftIdentity @RightIdentity : morphism.

(** We create aliases for categories, calling them small and locally
    small in accordance with mathematical terminology.   *)
Definition LocallySmallCategory {obj : Type} (*mor : obj -> obj -> Set*) := @Category obj.
Definition SmallCategory {obj : Set} (*mor : obj -> obj -> Set*) := @Category obj.
Identity Coercion LocallySmallCategory_Category_Id
: LocallySmallCategory >-> Category.
Identity Coercion SmallCategory_LocallySmallCategory_Id
: SmallCategory >-> Category.
*)
