(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing ≄ %\ensuremath{\not\simeq}% #&#8772;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ≰ %\ensuremath{\not\le}% #&#x2270;# *)
(** printing ≱ %\ensuremath{\not\ge}% #&#x2271;# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import Arith.
Require Import Category PreOrderCategory Product Orders NatOrders.
(*Require Import Numbers.Natural.Abstract.NLcm.*)
(*Require Import Numbers.Natural.Abstract.NGcd.*)
Require Import Common Notations.

Set Implicit Arguments.

Generalizable All Variables.

(** ------------------------------------------------------------------------ *)

(** * Exercise 4.5.1.16 *)
Section Exercise_4_5_1_16.
  (** ** Problem *)
  (** Consider the preorder [(ℕ, divides)], discussed in Exercise
      4.5.1.4, where e.g. [5 ≤ 15] but [5 ≰ 6].

      (a) What is the product of 9 and 12 in this category?

      (b) Is there a standard name for products in this category? *)
  (** ** Solution *)
  (** (a) 3

      (b) Greatest common divisor (least common multiple is the
          coproduct; both gcd and lcm are "universal", and the
          directionality for [divides] lines up with product in this
          case).  (Really, the way I decided weather to solve this
          problem or 4.5.1.29 was that I wrote code for gcd (because
          it's simpler than lcm), and then tried to prove that it was
          a product.  If the trivial way of doing this failed, I would
          have switched to coproduct, where it would have worked.) *)

  Local Infix "≤" := divides.

  (** We have that [v = gcd n m] if [v divides n], [v divides m], and
      for any other [v'] which [divides] both [n] and [m], [v']
      divides [v]. *)
  Class is_gcd (n m gcd_value : ℕ) :=
    {
      gcd_divides_first : divides gcd_value n;
      gcd_divides_second : divides gcd_value m;
      gcd_maximal : forall v,
                      divides v n
                      -> divides v m
                      -> divides v gcd_value
    }.

  (** We now implement the Euclidean algorithm for computing the gcd
      of two numbers.  I chose to implement it using typeclasses,
      because I didn't want to deal with well-founded recursion
      ([gt_wf_rec] and [lt_wf_rec]), and I don't think Coq's built-in
      [Fixpoint] mechanism is sufficiently powerful to implement this
      algorithm.  See [Arith.Euclid] (in the standard library) for a
      version of this algorithm based on well-founded recursion.  I
      found this version too hard to use for proofs.  The downside of
      using typeclasses is that we can't prove that it's a total
      algorithm, and we need some tactic code to find gcds. *)

  (** The tactics [t] and [t'] will discharge most of the proofs
      required to implement the Euclidean algorithm for computing gcds. *)

  (** The tactic [t] repeatedly tries the following things:

      - proving a conjunction by proving its two parts

      - turning [|- forall x, y] into [x |- y]

      - solving the goal [x |- x] by [assumption] (the [e] in
        [eassumption] means that we try to instantiate existential
        variables

      - using the [omega] tactic to solve some goals about arithmetic

      - attempting to solve [exists x, P x] by guessing that [x = 0],
        [x = 1], by guessing that [x] is some number that we have as a
        hypothesis, or by leaving [x] as a hole, and hoping that it
        will be instantiated uniquely in the process of solving the
        rest of the proof.

      - applying hypotheses, unfolding definitions (and applying
        eliminators), and using the substitution property of equality *)

  Local Ltac t :=
    repeat (split
              || intro
              || eassumption
              || (progress destruct_head_hnf @ex)
              || omega
              || (exists 0; solve [ t ])
              || (exists 1; solve [ t ])
              || (eexists; solve [ t ])
              || (match goal with
                    | [ n : _ |- _ ] => (exists n; solve [ t ])
                    | [ H : _ |- _ ] => apply H; solve [ t ]
                  end)
              || (solve [ progress (hnf in *; subst); t ])
              || (progress destruct_head_hnf @is_gcd)).

  (** The tactic [t'] solves goals of the form [exists x, P x] (or
      goals which can be transformed into such goals by applying a
      hypothesis) by guessing that we are looking for either a sum of
      two numbers, or a difference of two numbers.  We only accept
      this as a solution if we can solve the remaining goals by some
      combination of applying [t], rewriting with the distributive law
      of multiplication, and finding the remaining goals among the
      hypotheses. *)

  Local Ltac t' :=
    match goal with
      | [ a : _, b : _ |- _ ] =>
        (exists (a + b);
                rewrite mult_plus_distr_r;
                solve [ t
                      | apply f_equal2; eassumption ])
      | [ H : _ |- _ ] =>
        apply H;
          solve [ t
                | eexists (_ - _);
                  rewrite mult_minus_distr_r;
                  apply f_equal2;
                  eassumption ]
    end.

  (** We attempt to discharge [Program Instance] goals with [t] and
      [t']. *)

  Local Obligation Tactic :=
    t;
    try t'.

  (*Class > le_class n m := le_class_intro :> le n m.
  Global Program Instance le_class_n n : le_class n n | 0.
  Global Instance le_class_S n m `(H : le_class n m) : le_class n (S m) | 0 := le_S _ _ H. *)

  (** We enter some basic properties (base cases) of gcd. *)
  Global Program Instance gcd_0_n n : is_gcd 0 n n | 0.
  Global Program Instance gcd_n_0 n : is_gcd n 0 n | 0.
  Global Program Instance gcd_1_n n : is_gcd 1 n 1 | 0.
  Global Program Instance gcd_n_1 n : is_gcd n 1 1 | 0.
  Global Program Instance gcd_n_n n : is_gcd n n n | 0.
  Global Program Instance gcd_n_m_flip
         g `(le m n) `(is_gcd n m g)
  : is_gcd m n g | 1.
  (** The main case is that [gcd(m, n) = gcd(m - n, n)] if [n <= m]. *)
  Global Program Instance gcd_n_m
         g `(le n m) `(is_gcd (m - n) n g)
  : is_gcd m n g | 1.

  (** Now prove that the gcd is a product; the three components of the
      gcd are the morphisms of products.  The rest of the proofs are
      discharged by proof irrelevance. *)
  Global Instance gcd_is_product n m g `(H : is_gcd n m g)
  : is_product (PreOrderCategory (R := divides) _) n m g.
  exists gcd_divides_first gcd_divides_second gcd_maximal;
    abstract (intros; simpl; apply ProofIrrelevance.proof_irrelevance).
  Defined.

  (** This tactic recursively solves goals of the form [is_gcd n m _]
      by applying the instances defined above. *)

  Local Ltac try_solve_gcd :=
    match goal with
      | _ => solve [ eauto with typeclass_instances | hnf; omega ]
      | [ |- is_gcd _ _ _ ] => apply gcd_n_m_flip; simpl; try_solve_gcd
      | [ |- is_gcd _ _ _ ] => apply gcd_n_m; simpl; try_solve_gcd
      | [ |- is_gcd _ _ _ ] => idtac
    end.

  Definition gcd_9_12 : { n | is_gcd 9 12 n }.
    eexists.
    try_solve_gcd.
  Defined.

  (** Compute [gcd(9, 12)]. *)
  Eval hnf in (proj1_sig gcd_9_12).
  (** [= 3 : ℕ] *)
End Exercise_4_5_1_16.

(** ------------------------------------------------------------------------ *)
