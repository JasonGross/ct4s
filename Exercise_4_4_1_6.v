(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing ≄ %\ensuremath{\not\simeq}% #&#8772;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import FunctionalExtensionality JMeq EqdepFacts Relation_Definitions.
Require Import Omega.
Require Import Schema SchemaMorphism Path.
Require Import Common Notations FEqualDep.

Set Implicit Arguments.

Generalizable All Variables.

(** ------------------------------------------------------------------------ *)

(** * Exercise 4.4.1.6 *)
Module Exercise_4_4_1_6.
  (** ** Problem *)
  (** Consider the graph [Loop] pictured below
<<
                  __
                 /   ↘
     Loop :=  f |     s
                 \___/

>>

      and for any natural number [n], let [L_n] denote the schema
      [(Loop, ≃_n)] where [≃_n] is the PED [f^{n+1} ≃ f^n]. This is the "finite
      hierarchy" schema of Example 3.5.2.11. Let _1_ denote the graph
      with one vertex and no arrows; consider it as a schema.

      (a) Is _1_ isomorphic to [L_1] in [Sch]?

      (b) Is it isomorphic to any (other) [L_n]? *)
  (** ** Solution *)
  (** (a) No; by (b), it's isomorphic to [L_0], which is clearly not
          isomorphic to [L_1]. (Though proving this is a pain, because
          equivalence relations are a pain.  The idea would be to show
          that for [n <> 0], [f^1] is not equivalent to [f^0], but any
          morphism which factors through [L_0] sends all paths to
          equivalent paths, because all paths are equivalent in
          [L_0].)

      (b) Yes, _1_ is isomorphic to [L_0]; both have exactly one path,
          up to path equivalence, and schema morphisms which are the
          same up to path equivalence are defined to be equivalent.
          *)

  Inductive Loop_Vertex := s.
  Inductive Loop_Edge : Loop_Vertex -> Loop_Vertex -> Set := f : Loop_Edge s s.

  Fixpoint count_edges x y (p : path Loop_Edge x y) : ℕ
    := match p with
         | NoEdges => 0
         | AddEdge _ _ p e => 1 + (count_edges p)
       end.

  Lemma count_edges_prepend x y z (e : Loop_Edge x y) (p : path Loop_Edge y z)
  : count_edges (prepend p e) = 1 + count_edges p.
    induction p; simpl in *; intuition.
  Qed.

  Lemma count_edges_concatenate x y z (p1 : path Loop_Edge x y) (p2 : path Loop_Edge y z)
  : count_edges (concatenate p1 p2) = count_edges p2 + count_edges p1.
    revert x p1.
    induction p2; simpl in *; intuition.
  Qed.

  (** We have [f^a ≃_n f^b] if and only if [a = b] or [a >= n /\ b >=
      n]. *)
  Definition Loop_Equiv (n : ℕ) x y
  : Relation_Definitions.relation (path Loop_Edge x y)
    := fun p q => count_edges p = count_edges q
                  \/ (count_edges p >= n /\ count_edges q >= n).

  Local Notation "x ≃_ n y" := (@Loop_Equiv n x y) (at level 70).

  Hint Extern 1 => etransitivity; (eassumption || (symmetry; eassumption)).

  (** The schema [(Loop, ≃_n)]. *)
  Definition L (n : ℕ) : Schema.
    refine {| SVertex := Loop_Vertex;
              SEdge := Loop_Edge;
              PathsEquivalent := (@Loop_Equiv n) |};
    abstract (
        repeat (intro || split);
        hnf in *;
          repeat match goal with
                   | _ => progress simpl in *
                   | _ => progress rewrite count_edges_prepend
                   | [ H0 : _, H1 : _ |- _ ] => progress rewrite H0 in H1
                   | [ H : _ |- _ ] => progress rewrite H
                   | _ => progress intuition eauto
                 end
      ).
  Defined.

  (** The schema with one vertex and no arrows. *)
  Definition SingletonSchema : Schema.
    refine {| SVertex := unit;
              SEdge := (fun _ _ => ∅);
              PathsEquivalent := (fun _ _ => @eq _) |};
    abstract (repeat (esplit || intro); intuition eauto).
  Defined.

  (** We build an isomorphism between [L_0] and _1_ .  It sends
      everything to [NoEdges].  We destruct paths and absurdities and
      use reflexivity to prove that it's a schema morphism. *)
  Definition L0_to_singleton : SchemaMorphism (L 0) SingletonSchema.
    refine (@Build_SchemaMorphism (L 0) SingletonSchema
                                  (fun _ => tt)
                                  (fun _ _ _ => NoEdges)
                                  _).
    abstract (
        intros;
        simpl;
        apply JMeq_eq;
        match goal with
          | [ |- ?a == ?b ] => let a' := fresh in
                               let b' := fresh in
                               set (a' := a); set (b' := b);
          simpl in *;
            try destruct a';
          try destruct b'
        end;
        try reflexivity;
        destruct_head_hnf ∅
      ).
  Defined.

  Definition singleton_to_L0 : SchemaMorphism SingletonSchema (L 0).
    refine (@Build_SchemaMorphism SingletonSchema (L 0)
                                  (fun _ => s)
                                  (fun _ _ _ => NoEdges)
                                  _).
    abstract (
        intros;
        hnf in *;
          subst;
        intuition
      ).
  Defined.

  (** We prove the composition one way is the identity by using the
      fact that there is only one element of the singleton set, and
      the fact that having an element of the empty set is an
      absurdity. *)
  Lemma singleton_to_L0_to_singleton_id
  : ComposeSchemaMorphisms L0_to_singleton singleton_to_L0
    = IdentitySchemaMorphism _.
    apply SchemaMorphism_Eq;
    repeat intros [].
    reflexivity.
  Qed.

  (** We prove the composition the other way is equivalent to the
      identity by using the fact that there is only one element of the
      singleton set, and by using the fact that all paths are
      equivalent in [L_0]. *)
  Lemma L0_to_singleton_to_L0_id
  : SchemaMorphismsEquivalent (ComposeSchemaMorphisms singleton_to_L0 L0_to_singleton)
                              (IdentitySchemaMorphism _).
    apply SchemaMorphisms_equivalent;
    repeat (intros [] || intro);
    repeat (right || constructor).
  Qed.
 End Exercise_4_4_1_6.

(** ------------------------------------------------------------------------ *)
