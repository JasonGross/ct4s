(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing ≄ %\ensuremath{\not\simeq}% #&#8772;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
(** printing ℙ %\ensuremath{\mathbb{P}}% #&#x2119;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import Eqdep_dec.
Require Import ChainCategory Functor Isomorphism.
Require Import Common Notations FEqualDep NatFacts.

Set Implicit Arguments.

Generalizable All Variables.

(** ------------------------------------------------------------------------ *)

(** * Exercise 4.5.2.3 *)
Module Exercise_4_5_2_3.
  Local Open Scope category_scope.
  Local Open Scope morphism_scope.
  (** ** Problem *)
  (** Consider [[2]], the linear order category of length [2].

      (a) Is [[2]] the appropriate indexing category for commutative
          triangles?

      (b) If not, what is? *)

  Parameter objC : Type.
  Parameter C : @Category objC.
  Record CommutativeTriangle :=
    {
      a : C;
      b : C;
      c : C;
      f : Morphism C a b;
      g : Morphism C b c;
      h : Morphism C a c;
      TriangleCommutes : g o f = h
    }.

  Definition nat_eq_dec (n m : nat) : {n = m} + {n <> m}.
    decide equality.
  Defined.

  Section commutative_triangle_to_diagram.
    Variable T : CommutativeTriangle.

    Let a := a T.
    Let b := b T.
    Let c := c T.
    Let f := f T.
    Let g := g T.
    Let h := h T.

    Definition CommutativeTriangleDiagram_ObjectOf
    : [2] -> C.
      intro x.
      refine (match x with
                | exist 0 _ => a
                | exist 1 _ => b
                | exist 2 _ => c
                | exist (S (S (S n'))) pf => (fun pf : S (S (S n')) <= 2
                                              => _) pf
              end);
        exfalso;
        abstract omega.
    Defined.

    Definition CommutativeTriangleDiagram_MorphismOf
               s d (m : Morphism [2] s d)
    : Morphism C
               (CommutativeTriangleDiagram_ObjectOf s)
               (CommutativeTriangleDiagram_ObjectOf d).
      destruct s as [s pfs], d as [d pfd].
      destruct s as [|[|[|]]], d as [|[|[|]]];
        simpl in *;
        solve [ exact f
              | exact g
              | exact h
              | exact (Identity _)
              | hnf in *; exfalso; abstract omega ].
    Defined.

    Definition DiagramOfCommutativeTriangle : Functor [2] C.
      refine (Build_Functor [2] C
                            CommutativeTriangleDiagram_ObjectOf
                            CommutativeTriangleDiagram_MorphismOf
                            _
                            _);
       (
          intros;
          repeat match goal with
                   | [ H : sig _ |- _ ] => destruct H as [ [|[|[|]]] ? ]
                   | _ => reflexivity
                   | _ => (exfalso; abstract omega)
                   | _ => (subst f g h; rewrite <- TriangleCommutes; reflexivity)
                   | _ => progress autorewrite with category
                   | _ => progress simpl in *
                 end
        ).
    Defined.
  End commutative_triangle_to_diagram.

  Section diagram_to_commutative_triangle.
    Variable CommutativeTriangleDiagram : Functor [2] C.
    Lemma pf_a : 0 <= 2. Proof. repeat constructor. Defined.
    Lemma pf_b : 1 <= 2. Proof. repeat constructor. Defined.
    Lemma pf_c : 2 <= 2. Proof. repeat constructor. Defined.

    Lemma pf_f : 0 <= 1. Proof. repeat constructor. Defined.
    Lemma pf_g : 1 <= 2. Proof. repeat constructor. Defined.
    Lemma pf_h : 0 <= 2. Proof. repeat constructor. Defined.

    Let a' : [2] := exist _ 0 pf_a.
    Let b' : [2] := exist _ 1 pf_b.
    Let c' : [2] := exist _ 2 pf_c.

    Let a := CommutativeTriangleDiagram a'.
    Let b := CommutativeTriangleDiagram b'.
    Let c := CommutativeTriangleDiagram c'.

    Let f := MorphismOf CommutativeTriangleDiagram (s := a') (d := b') pf_f.
    Let g := MorphismOf CommutativeTriangleDiagram (s := b') (d := c') pf_g.
    Let h := MorphismOf CommutativeTriangleDiagram (s := a') (d := c') pf_h.

    Lemma triangle_commutes : g o f = h.
      subst_body.
      rewrite <- FCompositionOf.
      f_equal.
      simpl.
      apply nat_le_proofs_unicity.
    Defined.

    Definition CommutativeTriangleOfDiagram : CommutativeTriangle.
      exists a b c f g h.
      exact triangle_commutes.
    Defined.
  End diagram_to_commutative_triangle.

  Hypothesis C_obj_trunc : forall (s : C)
                                  (p1 p2 : s = s),
                             p1 = p2.

  Definition diagram_triangle_iso : Functor [2] C ≅ CommutativeTriangle.
    exists CommutativeTriangleOfDiagram.
    exists DiagramOfCommutativeTriangle.
    - abstract (
          intro x;
          destruct x; expand;
          f_equal;
          compute;
          repeat match goal with
                   | [ |- appcontext[match ?E with _ => _ end] ] => case E
                 end;
          reflexivity
        ).
    - abstract (
          pose proof C_obj_trunc;
          intro;
          apply Functor_Eq;
          intros;
          simpl in *;
            intros;
          repeat match goal with
                   | [ H : sig _ |- _ ] => destruct H as [ [|[|[|]]] ? ]
                   | _ => reflexivity
                   | _ => (exfalso; abstract omega)
                   | _ => (subst f g h; rewrite <- TriangleCommutes; reflexivity)
                   | _ => progress rewrite <- FIdentityOf
                   | _ => progress autorewrite with morphism
                   | _ => progress simpl in *
                   | _ => progress apply f_equal
                   | _ => apply nat_le_proofs_unicity
                   | [ H : ?m <= S ?n |- _ ] => (let H' := fresh in
                                                 assert (H' : m <= n) by repeat constructor;
                                                 assert (H = le_S _ _ H')
                                                   by apply nat_le_proofs_unicity;
                                                 subst H)
                   | [ H : ?n <= ?n |- _ ] => (assert (H = le_n n)
                                                by apply nat_le_proofs_unicity;
                                               subst H)
                   | _ => progress subst_eq_refl_dec_in_match
                 end
        ).
  Defined.
End Exercise_4_5_2_3.

(** ------------------------------------------------------------------------ *)
