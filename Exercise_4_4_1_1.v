(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import FunctionalExtensionality JMeq EqdepFacts.
Require Import Graph PathsCategory ChainCategory UnderlyingGraph Graph PathsFunctor Morphism.
Require Import Common Notations.

Set Implicit Arguments.

Generalizable All Variables.

(** ------------------------------------------------------------------------ *)

(** * Exercise 4.4.1.1 *)
Module Exercise_4_4_1_1.
  (** ** Problem *)
  (** Let [[2]] denote the linear order graph of length 2 (see
      Exercise 4.1.1.8 and Proposition 4.1.2.6), and let [Loop] denote
      the unique graph having one vertex and one arrow (pictured in
      Diagram (3.15)).

      (a) Find an injective graph homomorphism [f : [2] ->
          Paths(Loop)].

      (b) The graph [[2]] has 6 paths, so [Paths([2])] has 6
          arrows. What are the images of these arrows under the graph
          homomorphism [Paths(f) : Paths([2]) -> Paths(Paths(Loop))]?
          *)
  (** ** Solution *)
  (** (a) There are many.  For each [n <> m] both natural numbers,
          there is an injective graph homomorphism which sends one
          edge in [2] to the path of [n] edges in [Paths(Loop)], and
          the other edge to the path of [m] edges.

      (b) The three empty-path edges are sent to the edge which
          corresponds to the empty path of edges in [Paths(Loop)].
          The path [0 -> 1] is sent to the path which contains the
          single edge, which is a path of [n] edges (edges which live
          in [Loop]).  The path [1 -> 2] is sent to the path which
          contains the single edge, which is a path of [m] edges
          (edges which live in [Loop]).  The path [0 -> 1 -> 2] is
          sent to the two element path, which consists first of the
          edge in [Paths(Loop)] corresponding to the path of [n] edges
          in [Loop], and second of the edge in [Paths(Loop)]
          corresponding to the path of [m] edges in [Loop]. *)

  Definition Loop : Graph := {| Vertex := unit; Edge := (fun _ _ => unit) |}.

  (** The graph [2] is [0 -> 1 -> 2]; we have three vertices, and an
      edge from [Zero] to [One], and one from [One] to [Two] *)
  Inductive LinearOrder2Graph_Vertex := Zero | One | Two.
  Inductive LinearOrder2Graph_Edge
  : LinearOrder2Graph_Vertex -> LinearOrder2Graph_Vertex -> Set :=
  | Zero_One : LinearOrder2Graph_Edge Zero One
  | One_Two : LinearOrder2Graph_Edge One Two.
  Definition LinearOrder2Graph : Graph
    := {| Vertex := LinearOrder2Graph_Vertex;
          Edge := LinearOrder2Graph_Edge |}.

  (** There are many possible [f]s; one for each path.  Since the
      paths are in bijection with the natural numbers, we parameterize
      [f] on pairs natural numbers, because we have two edges. *)

  (** We have [n] edges in this path. *)
  Fixpoint nth_edge_in_loop (n : ℕ) : path (fun _ _ => unit) tt tt
    := match n with
         | O => NoEdges
         | S n' => AddEdge (nth_edge_in_loop n') tt
       end.

  (** Send the only valid [src, tgt] pairs to the helper function we
      defined above.  Send everything else, which turns out to be the
      empty set, to [NoEdges]; we do this because it's slightly
      non-trivial to convince Coq that the type of [x] below is the
      empty set. *)
  Definition f (n m : ℕ) : GraphHomomorphism LinearOrder2Graph (PathsFunctor Loop)
    := Build_GraphHomomorphism LinearOrder2Graph
                               (PathsFunctor Loop)
                               (fun _ => tt)
                               (fun src tgt =>
                                  match src, tgt with
                                    | Zero, One =>
                                      (fun _ => nth_edge_in_loop n)
                                    | One, Two =>
                                      (fun _ => nth_edge_in_loop m)
                                    | _, _ => fun x => NoEdges
                                  end).

  (** We prove that [f] above is not injective on vertices.  We
      construct a contradiction by obtaining a hypothesis that two of
      the elements of [LinearOrder2Graph_Vertices], called [One] and
      [Two], are equal. *)

  Lemma Exercise_4_4_1_1_a_vert n m
  : is_injective (OnVertices (f n m)) -> False.
    subst_body; clear; simpl.
    intro H.
    specialize (H One Two eq_refl).
    inversion H.
  Qed.

  (** As a helper function, we prove [nth_edge_in_loop] is
      injective. We prove this by induction on the natural number
      argument, and then by deduction of absurdity from absurd
      hypotheses, first order logical reasoning, and the fact that two
      paths are equal if, when you add the same edge to both, you get
      equal paths (the [inversion] tactic does both this and deduction
      of absurdity from absurd hypotheses). *)
  Lemma nth_edge_in_loop_injective
  : is_injective nth_edge_in_loop.
    intro x; induction x;
    intro y; induction y;
    intuition;
    match goal with
      | [ H : _ |- _ ] => try solve [ inversion H; firstorder ]
    end.
  Qed.

  (** We prove that [f] above is injective on edges when [n] and [m]
      are nonequal.  That is, when treated as a graph homomorphism as
      defined in the book, where there is a function from a set of all
      edges in one graph to a set of all edges in another, we prove
      that this function is injective.

      We prove this mostly by substituting definitions, splitting
      apart pair types, inferring absurdity from absurd hypotheses,
      and using the fact that if two pairs are equal, then their
      components are equal (this is the [apply
      EqdepFacts.eq_sigT_eq_dep in H; apply eq_dep_JMeq in H; apply
      JMeq_eq in H] sequence; we need to go through heterogeneous
      equality to prove this). *)
  Definition f' n m := GraphHomomorphismToGraph'Homomorphism (f n m).
  Lemma Exercise_4_4_1_1_a_edges n m
  : m <> n -> is_injective (OnArrows' (f' n m)).
    subst_body; clear; simpl.
    intro.
    assert (n <> m) by intuition.
    intros x y.
    destruct_head_hnf @sigT;
    destruct_head_hnf @prod;
    destruct_head_hnf @LinearOrder2Graph_Edge;
    simpl in *;
    repeat intro;
    try reflexivity;
    repeat match goal with
             | [ H : @eq (sigT _) _ _ |- _ ] =>
               apply EqdepFacts.eq_sigT_eq_dep in H;
                 apply eq_dep_JMeq in H;
                 apply JMeq_eq in H
             | [ H : _ = _ |- _ ] => apply nth_edge_in_loop_injective in H
           end;
    firstorder.
  Qed.

  (** The graph [[2]] has 6 paths, so [Paths([2])] has 6 arrows. *)
  Definition Paths2 := PathsFunctor LinearOrder2Graph.
  Definition Paths2Path0 : Edge Paths2 Zero Zero
    := NoEdges.
  Definition Paths2Path1 : Edge Paths2 One One
    := NoEdges.
  Definition Paths2Path2 : Edge Paths2 Two Two
    := NoEdges.
  Definition Paths2Path3 : Edge Paths2 Zero One
    := AddEdge NoEdges Zero_One.
  Definition Paths2Path4 : Edge Paths2 One Two
    := AddEdge NoEdges One_Two.
  Definition Paths2Path5 : Edge Paths2 Zero Two
    := AddEdge (AddEdge NoEdges Zero_One) One_Two.

  Section part_b.
    Local Notation "[ a , .. , b ]" := (AddEdge .. (AddEdge NoEdges a) .. b).
    Local Notation "[]" := NoEdges.

    Variables n m : ℕ.

    Local Notation "'Paths_f' a" := ((MorphismOf PathsFunctor (f n m)) a) (at level 10).
    Local Notation "a ~> b" := (Edge _ a b).
    Local Notation "a ~~> b" := (path _ a b).

    (** We use [simpl] to compute the action on edges.  The part
        between the equals sign and the colon describes the path, the
        part after the colon describes the type.  The notation [~>] is
        an edge, [~~>] is a path. *)

    Eval simpl in OnEdges (MorphismOf PathsFunctor (f n m)) _ _ Paths2Path0.
    (** [= []
     : Paths_f Zero ~> Paths_f Zero] *)

    Eval simpl in OnEdges (MorphismOf PathsFunctor (f n m)) _ _ Paths2Path1.
    (** [= []
     : Paths_f One ~> Paths_f One] *)

    Eval simpl in OnEdges (MorphismOf PathsFunctor (f n m)) _ _ Paths2Path2.
    (** [= []
     : Paths_f Two ~> Paths_f Two] *)

    Eval simpl in OnEdges (MorphismOf PathsFunctor (f n m)) _ _ Paths2Path3.
    (** [= [nth_edge_in_loop n]
     : Paths_f Zero ~~> Paths_f One] *)

    Eval simpl in OnEdges (MorphismOf PathsFunctor (f n m)) _ _ Paths2Path4.
    (** [= [nth_edge_in_loop m]
     : Paths_f One ~~> Paths_f Two] *)

    Eval simpl in OnEdges (MorphismOf PathsFunctor (f n m)) _ _ Paths2Path5.
    (** [= [nth_edge_in_loop n, nth_edge_in_loop m]
     : Paths_f Zero ~~> Paths_f Two] *)
  End part_b.
End Exercise_4_4_1_1.

(** ------------------------------------------------------------------------ *)
