(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing ≄ %\ensuremath{\not\simeq}% #&#9772;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
(** printing ℙ %\ensuremath{\mathbb{P}}% #&#x2119;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2199# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ↦ %\ensuremath{\mapsto}% #&#21A6# *)
(** printing ↪ %\ensuremath{\hookrightarrow}% #&rarrhk;# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ▻ %\ensuremath{\triangleright}% #&#x25BB;# *)
(** printing ◅ %\ensuremath{\triangleleft}% #&#x25C5;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ≰ %\ensuremath{\not\le}% #&#x2270;# *)
(** printing ≱ %\ensuremath{\not\ge}% #&#x2271;# *)
(** printing ≼ %\ensuremath{\preceq}% #&#x227c;# *)
(** printing ≽ %\ensuremath{\succeq}% #&#x227d;# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import JMeq ProofIrrelevance.
Require Import RelationClasses Coq.Logic.Description.
Require Import Adjoint AdjointUnit DiscreteCategoryFunctors SetCategory ComputableCategory InitialTerminalCategory.
Require Import EquivalenceClass EquivalenceRelationGenerator.
Require Import Common Notations FEqualDep.

Set Implicit Arguments.

Generalizable All Variables.

(** ------------------------------------------------------------------------ *)

(** * Exercise 5.1.1.9 *)
Section Exercise_5_1_1_9.
  (** ** Problem *)
  (** The discrete category functor [Disc : Set -> Cat] has a left
      adjoint [p : Cat -> Set]. Describe it. Hint: look at the mate
      isomorphism at the component corresponding to [[1] : Ob Cat] and
      [_2_ : Ob Set]. *)
  (** ** Solution *)
  (** [p] is the functor which sends every category to its set of
      connected components, where a connected component is . *)

  (** Note: Quotients are a pain without higher inductive types.  The
      documentation is a bit sparse on this one; sorry. *)

  (** The connected components of a category is the set of equivalence
      classes using the equivalence relation generated by the
      existance of a morphism. *)

  Definition ConnectedComponents `(C : @Category objC) : Type
    := @EquivalenceClass objC (@EquivalenceOf objC (fun s d => inhabited (Morphism C s d))).

  (** We end some proofs by unfolding definitions and either noting
      that the identity morphism fits what we are looking for, or by
      assumption, or by noting that we can define a morphism [F x -> F
      y] if we have a morphism [x -> y]. *)

  Local Ltac fin_tac F :=
    repeat match goal with
             | _ => progress destruct_head_hnf @inhabited
             | [ |- inhabited _ ] => constructor
             | _ => assumption
             | _ => apply (MorphismOf F)
             | _ => apply Identity
           end.

  (** We can use a functor [C -> D] to define a function between the
      connected components. *)

  Definition LiftConnectedFunctor `(C : @Category objC) `(D : @Category objD) (F : Functor C D)
  : ConnectedComponents C -> ConnectedComponents D.
    intro x.
    apply (fun v => @apply_to_class
                      _ _
                      _ _
                      (ObjectOf F)
                      v
                      x
                      (@EquivalenceOf_Equivalence _ _)).
    intros v v' H.
    abstract (
        induction H;
        destruct_head_hnf @inhabited;
        try solve [ apply gen_underlying; fin_tac F
                  | apply gen_refl
                  | apply gen_sym; assumption
                  | eapply gen_trans; eassumption ]
      ).
  Defined.

  (** We can extend that function to a functor between the discrete
      categories. *)

  Definition LiftConnectedFunctor_Functor `(C : @Category objC) `(D : @Category objD) (F : Functor C D)
  : Functor (DiscreteCategory (ConnectedComponents C)) (DiscreteCategory (ConnectedComponents D)).
    refine (Build_Functor (DiscreteCategory (ConnectedComponents C))
                          (DiscreteCategory (ConnectedComponents D))
                          (LiftConnectedFunctor F)
                          (fun s d (m : s = d) => match m with eq_refl => Identity _ end)
                          _
                          _);
    abstract (intros; hnf in *; subst; reflexivity).
  Defined.

  (** We can define a functor from a category to the discrete category
      on its connected components. *)

  Definition ConnectedComponentsProjectionFunctor `(C : @Category objC)
  : Functor C (DiscreteCategory (ConnectedComponents C)).
    refine (Build_Functor C (DiscreteCategory (ConnectedComponents C))
                          (fun x => classOf _ x)
                          (fun s d m => proj2 (classOf_eq _ _ _) (gen_underlying _ _ _ (inhabits m)))
                          _
                          _);
    abstract (intros; simpl; apply ProofIrrelevance.proof_irrelevance).
  Defined.

  (** We can define a function from the connected components of a
      discrete category on a set to that set itself. *)

  Definition ConnectedComponentsInjectionFunction T
  : ConnectedComponents (DiscreteCategory T) -> T.
    intro x.
    apply (fun H y =>
             EquivalenceClass_eq_lift constructive_definite_description
                                      (@apply_to_class _ (EquivalenceOf (λ s d : T, inhabited (Morphism (DiscreteCategory T) s d)))
                                                       _ (@eq T)
                                                       (fun x : T => x)
                                                       H
                                                       x
                                                       y));
      try abstract typeclasses eauto;
      abstract (
          simpl;
          intros;
          compute;
          match goal with
            | [ H : EquivalenceOf _ _ _ |- _ ] => induction H
          end;
          destruct_head_hnf @inhabited;
          intuition;
          solve [ etransitivity; eassumption ]
        ).
  Defined.

  Local Ltac t_disc :=
    repeat match goal with
             | _ => reflexivity
             | _ => apply Functor_Eq
             | _ => intro
             | _ => apply functional_extensionality_dep
             | _ => progress simpl in *
             | _ => progress hnf in *
             | _ => rewrite apply_to_classOf
             | _ => apply ProofIrrelevance.proof_irrelevance
             | _ => apply f_equal2
             | _ => progress unfold LiftConnectedFunctor
             | [ x : EquivalenceClass _ |- _ ] => let x' := fresh "x'" in
                                                  let H := fresh "H" in
                                                  destruct (ClassInhabited x) as [x' H];
                                                    rewrite (InClass_classOf_eq' x x' H)
           end.

  Let Disc : Functor CategoryOfTypes CategoryOfCategories := DiscreteFunctor.

  Let p : Functor CategoryOfCategories CategoryOfTypes.
    refine (Build_Functor CategoryOfCategories CategoryOfTypes
                          (fun x => ConnectedComponents (projT2 x))
                          (fun s d m => LiftConnectedFunctor m)
                          _
                          _);
    simpl;
    abstract t_disc.
  Defined.

  Lemma equiv_helper T x y
  : EquivalenceOf (λ x y : T, inhabited (x = y)) x y
    -> x = y.
    clear.
    induction 1;
      destruct_head_hnf @inhabited;
      subst; reflexivity.
  Qed.

  Local Open Scope functor_scope.

  (** We define the adjunction by defining the unit and counit and
      then using a bunch of tactics exhaustively to prove the zig-zag
      equations. *)

  Definition Exercise_5_1_1_9_Unit
  : NaturalTransformation (IdentityFunctor _) (Disc o p).
    refine (Build_NaturalTransformation (IdentityFunctor _) (Disc o p)
                                        (fun x => ConnectedComponentsProjectionFunctor _)
                                        _).
    subst_body;
      abstract t_disc.
  Defined.

  Local Ltac t_disc_counit :=
    repeat match goal with
             | _ => intro
             | _ => reflexivity
             | [ H : _ |- _ ] => apply equiv_helper in H
             | [ |- appcontext[match ?E with _ => _ end] ] => case E
             | _ => progress simpl in *
             | _ => progress destruct_head_hnf @ex
             | _ => progress destruct_head_hnf @inhabited
             | _ => progress split_and
             | _ => progress subst
             | _ => progress expand
             | _ => progress unfold id in *
             | _ => progress unfold ConnectedComponentsInjectionFunction
             | _ => progress unfold EquivalenceClass_eq_lift
             | _ => progress clear_InClass
             | _ => progress hnf in * |-
             | _ => apply functional_extensionality_dep
             | _ => etransitivity; eassumption
             | _ => progress intuition
           end.


  Definition Exercise_5_1_1_9_Counit
  : NaturalTransformation (p o Disc) (IdentityFunctor _).
    exists ConnectedComponentsInjectionFunction.
    subst p Disc.
    abstract t_disc_counit.
  Defined.

  Example Exercise_5_1_1_9 : p -| Disc.
  Proof.
    refine (_ : AdjunctionUnitCounit _ _).
    exists Exercise_5_1_1_9_Unit
           Exercise_5_1_1_9_Counit;
      simpl;
      subst_body; simpl;
      abstract (
          repeat match goal with
                   | _ => intro
                   | _ => split
                   | _ => assumption
                   | _ => apply Functor_Eq
                   | [ |- appcontext[match ?E with _ => _ end] ] => (case E; simpl)
                   | _ => apply functional_extensionality_dep
                   | [ H : _ |- _ ] => apply equiv_helper in H
                   | _ => progress subst
                   | _ => progress destruct_head_hnf @ex
                   | _ => progress split_and
                   | _ => progress simpl in *
                   | _ => progress unfold ConnectedComponentsInjectionFunction
                   | _ => progress unfold EquivalenceClass_eq_lift
                   | _ => progress unfold id
                   | _ => apply sameClass_eq
                   | _ => progress clear_InClass
                   | _ => apply ProofIrrelevance.proof_irrelevance
                 end
        ).
  Defined.
End Exercise_5_1_1_9.
(** ------------------------------------------------------------------------ *)
