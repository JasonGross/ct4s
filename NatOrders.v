(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8 Setoid.
Require Import Omega.
Require Import NPeano.
Require Import Classes.RelationClasses.
Require Export Compare_dec Arith.Euclid.
Require Export Orders OrderProduct OrderCoproduct.
Require Import Common Notations.

Set Implicit Arguments.

Generalizable All Variables.

(** * Orders on the natural numbers *)

(** ** The order "less than or equal to" *)
Section nat_le_order.
  Local Obligation Tactic := Tactics.program_simpl; repeat (omega || compute || intro || split).

  Global Program Instance le_refl' : RelationClasses.Reflexive le.
  Global Program Instance le_trans' : RelationClasses.Transitive le.
  Global Program Instance le_pre_order' : RelationClasses.PreOrder le.
  Global Program Instance le_antisym' : RelationClasses.Antisymmetric _ _ le.
  Global Program Instance le_partial_order' : RelationClasses.PartialOrder _ le.
  Global Program Instance le_comp' : Comparable le.
  Global Program Instance le_linear_order' : LinearOrder le.
  Global Instance le_dec' : RelationDecidable le := le_dec.
End nat_le_order.

(** ** The order "divides" *)
Definition divides n m := exists p, m = p * n.
Notation "( x | y )" := (divides x y) (at level 0) : nat_scope.

Create HintDb nat_orders discriminated.
Create HintDb nat_orders_simple discriminated.

Hint Rewrite mult_assoc plus_assoc mult_0_r plus_0_r : nat_orders_simple.
Hint Rewrite mult_assoc plus_assoc mult_0_r plus_0_r mult_plus_distr_l : nat_orders.

Section nat_le_div.
  Local Ltac t := repeat ((abstract omega)
                            || (simpl in *; cbv beta iota zeta delta -[mult plus] in *; idtac)
                            || intro
                            || split
                            || split_and
                            || destruct_head_hnf @ex
                            || subst
                            || (progress autorewrite with nat_orders_simple; idtac)
                            || (eexists; eassumption)
                            || (exists 0; solve [ t ])
                            || (exists 1; solve [ t ])
                            || (exists 2; solve [ t ])
                            || (esplit; solve [ eauto; t; eauto ])
                            || match goal with
                                 | [ H : _ |- _ ] => (exists H; solve [ t ])
                                 | [ H : _ |- _ ] => solve [ inversion H ]
                                 | [ H : S ?x = S ?y |- _ ] => assert (x = y) by (abstract omega); clear H
                               end).
  Local Obligation Tactic :=
    Tactics.program_simpl; t.

  Local Ltac t2 :=
    repeat (t
              || (progress autorewrite with nat_orders in *; idtac)
              || (match goal with
                    | [ H : context[?x * S ?y] |- _ ] => (rewrite (mult_comm x (S y)) in H; simpl in H)
                    | [ |- context[?x * S ?y] ] => (rewrite (mult_comm x (S y)); simpl)
                    | [ H : context[?x + S ?y] |- _ ] => (rewrite (plus_comm x (S y)) in H; simpl in H)
                    | [ |- context[?x + S ?y] ] => (rewrite (plus_comm x (S y)); simpl)
                  end)).

  Global Program Instance divides_refl : RelationClasses.Reflexive divides.
  Global Program Instance divides_trans : RelationClasses.Transitive divides.
  Global Program Instance divides_pre_order : RelationClasses.PreOrder divides.
  Global Program Instance divides_antisym : RelationClasses.Antisymmetric _ _ divides.
  Next Obligation.
    match goal with
      | [ |- ?x = _ ] => destruct x; t
    end.
    match goal with
      | [ a : ℕ, b : ℕ, c : ℕ |- _ ] => (destruct a; t; try destruct a; t);
                                       (destruct b; t; try destruct b; t);
                                       (destruct c; t; try destruct c; t)
    end.
    match goal with
      | [ H : ?x = ?x + S ?y + ?z |- _ ] => destruct z; destruct y; t
    end.
  Qed.
  Global Program Instance divides_partial_order : RelationClasses.PartialOrder _ divides.
  Next Obligation.
    apply divides_antisym; t.
  Qed.
  Global Instance divides_dec : RelationDecidable divides.
  hnf.
  refine (fun x y => match x, y with
                       | _, 0 => left (ex_intro _ 0 eq_refl)
                       | 0, S y' => right (fun H => match H return False with
                                                      | ex_intro p H' => _
                                                    end)
                       | S x', S y' => match Euclid.modulo (S x') _ (S y') with
                                         | exist r H => match r as n
                                                              return
                                                              ((∃ q : ℕ, S y' = q * S x' + n ∧ S x' > n)
                                                               → {divides (S x') (S y')} + {¬divides (S x') (S y')})
                                                        with
                                                          | 0 => fun H' => left _
                                                          | S r' => fun H' => right _
                                                        end H
                                       end
                     end);
    try abstract t2;
    abstract (
        intro;
        destruct_head_hnf @ex;
        split_and;
        match goal with
          | [ H : ?x = ?y, H' : ?x = ?z |- _ ] => let x' := fresh in
                                                  set (x' := x) in *;
                                                    clearbody x';
          subst x'
        end;
        match goal with
          | [ H : ?x * S ?x' = ?x0 * S ?x' + _ |- _ ] =>
            assert (x < S x0) by (apply (Nat.mul_lt_mono_pos_r (S x')); simpl; omega);
          assert (x0 < x) by (apply (Nat.mul_lt_mono_pos_r (S x')); simpl; omega);
          omega
        end
      ).
  Defined.
End nat_le_div.
