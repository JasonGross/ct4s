(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import FunctionalExtensionality.
Require Export Category SetCategory Product Coproduct.
Require Import DiscreteCategory CategoryMorphisms CategoryObjects.
Require Import Common Morphism.

Set Implicit Arguments.

Generalizable All Variables.

(** * Initial and terminal objects of the category of sets. *)

(** We use notations to get around universe level instantiation again. *)
Notation IndexedTInitialOf obj coerce initial_obj :=
  ((fun z => exist _
                   (fun x : initial_obj%type => match x with end)
                   (fun _ => functional_extensionality_dep _ _ (fun x : initial_obj%type => match x with end)))
   : IsInitialObject (C := IndexedCategoryOf obj coerce) initial_obj%type).

Notation IndexedTTerminalOf obj coerce terminal_obj constr all_eq :=
  ((fun z : obj => exist (fun m : z -> terminal_obj => forall x : z -> terminal_obj, x = m)
                         (fun _ : z => constr)
                         (fun H : z -> terminal_obj => functional_extensionality_dep H
                                                                                     (fun _ : z => constr)
                                                                                     (fun x : z => all_eq _ _)))
   : IsTerminalObject (C := IndexedCategoryOf obj coerce) terminal_obj%type).

Notation IndexedEmptySetInitialOf obj coerce := (IndexedTInitialOf obj coerce ∅).
Notation IndexedFalseInitialOf obj coerce := (IndexedTInitialOf obj coerce False).

Notation IndexedUnitTerminalOf obj coerce := (IndexedTTerminalOf obj coerce unit tt unit_eq).
Notation IndexedTrueTerminalOf obj coerce := (IndexedTTerminalOf obj coerce True I True_eq).

Notation EmptySetInitialOf obj := (IndexedEmptySetInitialOf obj (fun x => x)).
Notation FalseInitialOf obj := (IndexedFalseInitialOf obj (fun x => x)).

Notation UnitTerminalOf obj := (IndexedUnitTerminalOf obj (fun x => x)).
Notation TrueTerminalOf obj := (IndexedTrueTerminalOf obj (fun x => x)).

Notation CoercedEmptySetInitialOf obj T := (IndexedEmptySetInitialOf obj (fun x => x : T)).
Notation CoercedFalseInitialOf obj T := (IndexedFalseInitialOf obj (fun x => x : T)).

Notation CoercedUnitTerminalOf obj T := (IndexedUnitTerminalOf obj (fun x => x : T)).
Notation CoercedTrueTerminalOf obj T := (IndexedTrueTerminalOf obj (fun x => x : T)).

Section InitialTerminal.
  Definition CategoryOfTypesFalseInitial : IsInitialObject (C := CategoryOfTypes) False := Eval simpl in FalseInitialOf Type.
  Definition CategoryOfSetsFalseInitial : IsInitialObject (C := CategoryOfSets) False := Eval simpl in FalseInitialOf Set.
  Definition CategoryOfPropsFalseInitial : IsInitialObject (C := CategoryOfProps) False := Eval simpl in FalseInitialOf Prop.

  Definition CategoryOfTypesEmptyInitial : IsInitialObject (C := CategoryOfTypes) ∅ := Eval simpl in EmptySetInitialOf Type.
  Definition CategoryOfSetsEmptyInitial : IsInitialObject (C := CategoryOfSets) ∅ := Eval simpl in EmptySetInitialOf Set.

  Definition CategoryOfTypesTrueTerminal : IsTerminalObject (C := CategoryOfTypes) True := Eval simpl in TrueTerminalOf Type.
  Definition CategoryOfSetsTrueTerminal : IsTerminalObject (C := CategoryOfSets) True := Eval simpl in TrueTerminalOf Set.
  Definition CategoryOfPropsTrueTerminal : IsTerminalObject (C := CategoryOfProps) True := Eval simpl in TrueTerminalOf Prop.

  Definition CategoryOfTypesUnitTerminal : IsTerminalObject (C := CategoryOfTypes) unit := Eval simpl in UnitTerminalOf Type.
  Definition CategoryOfSetsUnitTerminal : IsTerminalObject (C := CategoryOfSets) unit := Eval simpl in UnitTerminalOf Set.

  Definition CategoryOfTypesSingletonTerminal : IsTerminalObject (C := CategoryOfTypes) unit := Eval hnf in CategoryOfTypesUnitTerminal.
  Definition CategoryOfSetsSingletonTerminal : IsTerminalObject (C := CategoryOfSets) unit := Eval hnf in CategoryOfSetsUnitTerminal.
End InitialTerminal.

Section EpiMono.
  Variables S : Type.

  Local Ltac t' :=
    match goal with
      | _ => progress (intros; subst; trivial)
      | _ => eexists; reflexivity
      | _ => discriminate
      | [ H : _ -> False |- _ ] => contradict H; solve [ t' ]
      | [ H : ~_ |- _ ] => contradict H; solve [ t' ]
      | [ dec : forall _, {_} + {_} |- _ ] =>
        match goal with
          | [ _ : appcontext[dec ?x] |- _ ] => destruct (dec x)
          | [ |- appcontext[dec ?x] ] => destruct (dec x)
        end
      | _ => apply functional_extensionality_dep; intro
      | _ => progress (unfold compose in *; simpl in *; fg_equal)
      | _ => progress apply_hyp'
      | _ => progress destruct_type bool
      | [ H : (_ -> exists _, _), x : _ |- _ ] => destruct (H x); clear H
      | _ => progress specialize_uniquely
    end.

  Local Ltac t :=
    repeat match goal with
             | _ => t'
             | [ H : ?A -> _ |- _ ] =>
               match goal with
                 | [ _ : A |- _ ] => fail 1 (* don't make an [A] if we already have one *)
                 | _ => let a := fresh in assert (a : A) by (repeat t'); specialize (H a)
               end
           end.

  Lemma InjMono B (f : B -> S) :
    (forall x y : B, f x = f y -> x = y)
    -> (forall A (g g' : A -> B), (compose f g) = (compose f g') -> g = g').
  Proof.
    t.
  Qed.

  Lemma MonoInj B (f : B -> S) :
    (forall A (g g' : A -> B), (compose f g) = (compose f g') -> g = g')
    -> (forall x y : B, f x = f y -> x = y).
  Proof.
    intros H x y; t.
    pose proof (fun H' => H bool (fun b => if b then x else y) (fun _ => y) H' true).
    t.
  Qed.

  Lemma SurjEpi A (f : A -> S) :
    (forall x : S, exists y : A, f y = x)
    -> (forall C (g g' : S -> C), (compose g f) = (compose g' f) -> g = g').
  Proof.
    t.
  Qed.

  Lemma EpiSurj A (f : A -> S) (member_dec : forall x : S, {exists y, f y = x} + {~exists y, f y = x}) :
    (forall C (g g' : S -> C), (compose g f) = (compose g' f) -> g = g')
    -> (forall x : S, exists y : A, f y = x).
  Proof.
    intro H.
    assert (H' := fun H' => H bool (fun y => if member_dec y then true else false) (fun y => true) H').
    clear H.
    t.
  Qed.
End EpiMono.

Section set_cat_has_prod.
  Local Ltac prod_t :=
    repeat match goal with
             | _ => apply functional_extensionality_dep
             | _ => progress intros []
             | _ => intro
             | _ => progress simpl_eq
             | _ => progress fg_equal
             | _ => progress intuition
             | [ |- @eq (_ /\ _) (?f ?x) _ ] => destruct (f x)
           end.

  Global Instance prodT_is_product X Y : is_product CategoryOfTypes X Y (X * Y)%type.
  refine (@Build_is_product _ _
                            X Y (X * Y)%type
                            (@fst _ _)
                            (@snd _ _)
                            (fun A f g => fun x => (f x, g x))
                            _
                            _
                            _);
    simpl; try reflexivity;
    abstract prod_t.
  Defined.

  Global Instance prod_is_product X Y : is_product CategoryOfSets X Y (X * Y)%type.
  refine (@Build_is_product _ _
                            X Y (X * Y)%type
                            (@fst _ _)
                            (@snd _ _)
                            (fun A f g => fun x => (f x, g x))
                            _
                            _
                            _);
    simpl; try reflexivity;
    abstract prod_t.
  Defined.

  Global Instance conj_is_product X Y : is_product CategoryOfProps X Y (X /\ Y).
  refine (@Build_is_product _ _
                            X Y (X /\ Y)
                            (fun H => match H with conj A _ => A end)
                            (fun H => match H with conj _ A => A end)
                            (fun A f g => fun x => conj (f x) (g x))
                            _
                            _
                            _);
    simpl; try reflexivity;
    abstract prod_t.
  Defined.
End set_cat_has_prod.

Section set_cat_has_coprod.
  Local Ltac coprod_t :=
    repeat match goal with
             | _ => apply functional_extensionality_dep
             | _ => progress intros []
             | _ => intro
             | _ => progress simpl_eq
             | _ => progress fg_equal
             | _ => progress intuition
             | [ |- @eq (_ /\ _) (?f ?x) _ ] => destruct (f x)
           end.

  Global Instance sumT_is_coproduct X Y : is_coproduct CategoryOfTypes X Y (X + Y)%type.
  refine (@Build_is_coproduct _ _
                            X Y (X + Y)%type
                            (@inl _ _)
                            (@inr _ _)
                            (fun A f g => fun x => match x with inl x => f x | inr x => g x end)
                            _
                            _
                            _);
    simpl; try reflexivity;
    abstract coprod_t.
  Defined.

  Global Instance sum_is_coproduct X Y : is_coproduct CategoryOfSets X Y (X + Y)%type.
  refine (@Build_is_coproduct _ _
                            X Y (X + Y)%type
                            (@inl _ _)
                            (@inr _ _)
                            (fun A f g => fun x => match x with inl x => f x | inr x => g x end)
                            _
                            _
                            _);
    simpl; try reflexivity;
    abstract coprod_t.
  Defined.

  Global Instance or_is_coproduct X Y : is_coproduct CategoryOfProps X Y (X \/ Y).
  refine (@Build_is_coproduct _ _
                            X Y (X \/ Y)
                            (@or_introl _ _)
                            (@or_intror _ _)
                            (fun A f g => fun x => match x with or_introl x => f x | or_intror x => g x end)
                            _
                            _
                            _);
    simpl; try reflexivity;
    abstract coprod_t.
  Defined.
End set_cat_has_coprod.
