(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import FunctionalExtensionality ProofIrrelevance.

Set Implicit Arguments.

Generalizable All Variables.

Record ComputationalMonoid (M : Type) :=
  {
    monoid_obj :> _ := M;
    id : monoid_obj;
    comp : monoid_obj -> monoid_obj -> monoid_obj
  }.

Arguments id {M _}.

Infix "★" := (comp _) (at level 40, left associativity).

Class IsMonoid (M : Type) (cmonoid : ComputationalMonoid M) : Prop :=
  {
    left_id : forall x : cmonoid, id ★ x = x;
    right_id : forall x : cmonoid, x ★ id = x;
    assoc : forall a b c : cmonoid, (a ★ b) ★ c = a ★ (b ★ c)
  }.

Create HintDb monoid discriminated.
Hint Resolve left_id right_id : monoid.
Hint Immediate @assoc @left_id @right_id : monoid.
Hint Rewrite @left_id @right_id using typeclasses eauto : monoid.

Record Monoid (M : Type) :=
  {
    cmonoid :> ComputationalMonoid M;
    is_monoid :> @IsMonoid M cmonoid
  }.

Definition is_commutative M (M' : Monoid M) := forall a b : M', a ★ b = b ★ a.

(** ** Monoid Action *)
Class IsMonoidAction G' (G : ComputationalMonoid G') (S : Type) (f : G -> S -> S) : Prop :=
  { id_action : forall s, f id s = s;
    action_respectful : forall g g' s, f g (f g' s) = f (g ★ g') s }.

Record MonoidAction G' (G : ComputationalMonoid G') (S : Type) :=
  {
    monoid_action :> G -> S -> S;
    is_monoid_action : @IsMonoidAction G' G S monoid_action
  }.

Infix "↷" := (@monoid_action _ _ _) (at level 70).
Infix "↷" := (@MonoidAction _) (at level 70) : type_scope.

(** ** Monoid Homomorphism *)
(** Definition 3.1.4.1. Let [M := ( M, id, ★ ) and [M' := ( M', id', ★
    )] be monoids. A monoid homomorphism [f] from [M] to [M'], denoted
    [f : M -> M'], is a function [f : M -> M'] satisfying two
    conditions:

    - [f(id) = id'], and
    - [f(m1 ★ m2) = f(m1) ★ f(m2)], for all [m1], [m2] in [M].
    *)

Record MonoidHomomorphism `(MH : @IsMonoid M0 M) `(M'H : @IsMonoid M'0 M') :=
  {
    MonoidHomomorphism_Function :> M -> M';
    MonoidHomomorphism_IdentityLaw
    : MonoidHomomorphism_Function id = id;
    MonoidHomomorphism_CompositionLaw
    : forall m1 m2,
        MonoidHomomorphism_Function (m1 ★ m2)
        = (MonoidHomomorphism_Function m1) ★ (MonoidHomomorphism_Function m2)
  }.

Definition identity_monoid_homomorphism `(MH : @IsMonoid M0 M)
: MonoidHomomorphism MH MH.
  exists (fun x => x); reflexivity.
Defined.

Definition compose_monoid_homomorphisms
           `(MH : @IsMonoid M0 M)
           `(MH' : @IsMonoid M0' M')
           `(MH'' : @IsMonoid M0'' M'')
: MonoidHomomorphism MH' MH''
  -> MonoidHomomorphism MH MH'
  -> MonoidHomomorphism MH MH''.
  intros m1 m2.
  exists (fun x => m1 (m2 x));
    abstract (
        intros;
        repeat rewrite MonoidHomomorphism_IdentityLaw;
        repeat rewrite MonoidHomomorphism_CompositionLaw;
        reflexivity
      ).
Defined.

Lemma MonoidHomomorphism_Eq
      `(MH : @IsMonoid M0 M)
      `(M'H : @IsMonoid M'0 M')
      (M1 M2 : MonoidHomomorphism MH M'H)
: (forall x, MonoidHomomorphism_Function M1 x = MonoidHomomorphism_Function M2 x)
  -> M1 = M2.
  intro H.
  assert (H0 : MonoidHomomorphism_Function M1 = MonoidHomomorphism_Function M2) by
      (apply functional_extensionality_dep; assumption).
  destruct M1, M2; simpl in *; subst; f_equal; apply proof_irrelevance.
Qed.
