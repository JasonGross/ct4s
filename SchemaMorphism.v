(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import Setoid FunctionalExtensionality ProofIrrelevance JMeq Eqdep.
Require Export Schema.
Require Import Common Notations FEqualDep.

Set Implicit Arguments.

Generalizable All Variables.

(** * Schema Morphisms *)

Section Schemas.
  Variables C D : Schema.

  Section transferPath.
    Variable vertexOf : C -> D.
    Variable pathOf : forall s d, C.(SEdge) s d -> path (SEdge D) (vertexOf s) (vertexOf d).

    Fixpoint transferPath s d (p : path (SEdge C) s d) : path (SEdge D) (vertexOf s) (vertexOf d) :=
      match p with
        | NoEdges => NoEdges
        | AddEdge _ _ p' E => concatenate (transferPath p') (pathOf _ _ E)
      end.

    Hint Rewrite concatenate_noedges_p concatenate_p_noedges.
    Hint Rewrite <- concatenate_associative.

    Lemma concatenate_transferPath s d d' (p : path (SEdge C) s d) (p' : path (SEdge C) d d') :
      transferPath (concatenate p p') = concatenate (transferPath p) (transferPath p').
      induction p'; t_with t'.
    Qed.
  End transferPath.

  Record SchemaMorphism := {
    VertexOf :> C -> D;
    PathOf : forall s d, C.(SEdge) s d -> path (SEdge D) (VertexOf s) (VertexOf d);
    TransferPath := (fun s d (p : path (SEdge C) s d) => transferPath VertexOf PathOf p);
    TEquivalenceOf : forall s d (p1 p2 : path (SEdge C) s d),
      PathsEquivalent C p1 p2
      -> PathsEquivalent D (TransferPath _ _ p1) (TransferPath _ _ p2)
  }.

  Global Add Parametric Morphism s d T :
    (@TransferPath T s d)
    with signature (@PathsEquivalent C _ _) ==> (@PathsEquivalent D _ _)
      as TransferPath_mor.
    exact (@TEquivalenceOf T s d).
  Qed.

  Lemma concatenate_TransferPath s d d' (p : path (SEdge C) s d) (p' : path (SEdge C) d d') T :
      TransferPath T (concatenate p p') = concatenate (TransferPath T p) (TransferPath T p').
    unfold TransferPath; simpl.
    apply concatenate_transferPath.
  Qed.

  Lemma TransferPath_NoEdges x T :
    TransferPath T (@NoEdges _ _ x) = NoEdges.
    reflexivity.
  Qed.
End Schemas.

Hint Rewrite concatenate_transferPath concatenate_TransferPath.

Section SchemaMorphisms_Equal.
  Lemma SchemaMorphism_Eq
  : forall C D (F G : SchemaMorphism C D),
      (forall x, VertexOf F x = VertexOf G x)
      -> (forall s d m, PathOf F s d m == PathOf G s d m)
      -> F = G.
    intros C D F G H H'.
    assert (VertexOf F = VertexOf G) by (apply functional_extensionality_dep; assumption).
    clear H.
    assert (PathOf F == PathOf G);
      destruct F, G;
      subst_body;
      simpl in *;
      repeat subst;
      JMeq_eq;
      repeat (apply functional_extensionality_dep; intro);
      try solve [ apply JMeq_eq; intuition ].
    f_equal.
    apply proof_irrelevance.
  Qed.

  Lemma SchemaMorphism_equal_parts : forall C D (F G : SchemaMorphism C D),
    F = G -> VertexOf F = VertexOf G /\ PathOf F == PathOf G.
    intros; repeat subst; split; trivial.
  Qed.
End SchemaMorphisms_Equal.

Section SchemaMorphismComposition.
  Variable B C D E : Schema.

  Hint Resolve concatenate_transferPath.

  Lemma compose_transferPath (vertexOf : C -> D) pathOf (vertexOf' : D -> E) pathOf' : forall s d (p : path (SEdge C) s d),
    (transferPath _ _ (fun c : C => vertexOf' (vertexOf c))
      (fun (s0 d0 : C) (e : SEdge C s0 d0) =>
        transferPath _ _ vertexOf' pathOf' (pathOf s0 d0 e)) p) =
    transferPath _ _ vertexOf' pathOf' (transferPath _ _ vertexOf pathOf p).
  Proof.
    induction p; reflexivity || symmetry; t_with t'.
  Qed.

  Hint Rewrite compose_transferPath.
  Hint Resolve TEquivalenceOf.

  Definition ComposeSchemaMorphisms (G : SchemaMorphism D E) (F : SchemaMorphism C D) : SchemaMorphism C E.
    refine {| VertexOf := (fun c => G (F c));
      PathOf := (fun _ _ e => G.(TransferPath) (F.(PathOf) _ _ e))
    |}; abstract (unfold TransferPath; t_with t'; repeat apply TEquivalenceOf; assumption).
  Defined.
End SchemaMorphismComposition.

Implicit Arguments ComposeSchemaMorphisms [C D E].

Section IdentitySchemaMorphsims.
  Variable C D : Schema.

  (* There is an identity translation.  It does the obvious thing. *)
  Definition IdentitySchemaMorphism : SchemaMorphism C C.
    refine {| VertexOf := (fun x => x);
      PathOf := (fun _ _ x => AddEdge NoEdges x)
    |}; abstract (
      intros ? ? p1 p2 ?;
        transitivity p1;
          try solve [ induction p1; try apply AddEdge_mor; try apply (IHp1 p1); reflexivity ];
            transitivity p2;
              try solve [ induction p2; try apply AddEdge_mor; try apply (IHp2 p2); reflexivity ];
                assumption
    ).
  Defined.

  Hint Unfold ComposeSchemaMorphisms IdentitySchemaMorphism VertexOf PathOf.

  Lemma LeftIdentitySchemaMorphism (F : SchemaMorphism D C) : ComposeSchemaMorphisms IdentitySchemaMorphism F = F.
    apply SchemaMorphism_Eq; try reflexivity; simpl; intros.
    JMeq_eq.
    match goal with
      | [ |- ?a = ?b ] => induction b; t_with t'
    end.
  Qed.

  Lemma RightIdentitySchemaMorphism (F : SchemaMorphism C D) : ComposeSchemaMorphisms F IdentitySchemaMorphism = F.
    apply SchemaMorphism_Eq; try reflexivity; simpl; intros.
    t_with t'.
  Qed.
End IdentitySchemaMorphsims.

Section SchemaMorphismCompositionLemmas.
  Variable B C D E : Schema.

  Lemma ComposeSchemaMorphismsAssociativity (F : SchemaMorphism B C) (G : SchemaMorphism C D) (H : SchemaMorphism D E) :
    ComposeSchemaMorphisms (ComposeSchemaMorphisms H G) F = ComposeSchemaMorphisms H (ComposeSchemaMorphisms G F).
    unfold ComposeSchemaMorphisms; apply SchemaMorphism_Eq; try reflexivity; simpl; intros.
    JMeq_eq.
    match goal with
      | [ |- TransferPath _ ?p = _ ] => induction p; t_with t'
    end.
  Qed.
End SchemaMorphismCompositionLemmas.

Section SchemaMorphismsEquivalent.
  Variables C D : Schema.
  Variables F G : SchemaMorphism C D.

  Definition SchemaMorphismsEquivalent :=
    exists vo po po' eo eo',
      F = {| VertexOf := vo; PathOf := po; TEquivalenceOf := eo |} /\
      G = {| VertexOf := vo; PathOf := po'; TEquivalenceOf := eo' |} /\
      forall s d (e : C.(SEdge) s d), PathsEquivalent _ (po _ _ e) (po' _ _ e).

  Lemma SchemaMorphisms_equivalent :
    (forall x, VertexOf F x = VertexOf G x)
    -> (VertexOf F = VertexOf G ->
        forall s d (e : C.(SEdge) s d), GeneralizedPathsEquivalent _ (PathOf F _ _ e) (PathOf G _ _ e))
    -> SchemaMorphismsEquivalent.
    intro H.
    assert (H' : VertexOf F = VertexOf G) by (apply functional_extensionality_dep; assumption);
      clear H;
      revert H'.
    unfold SchemaMorphismsEquivalent;
      destruct F as [ vo po tp eo ], G as [ vo' po' tp' eo' ];
        simpl; intros; subst tp tp'; intuition; repeat subst;
          repeat esplit; f_equal; intros.
    match goal with
      | [ s : _, d : _, e : _, H : _ |- _ ] => specialize (H s d e); simpl_GeneralizedPathsEquivalent; assumption
    end.
  Qed.
End SchemaMorphismsEquivalent.

Section SchemaMorphismsEquivalent_Relation.
  Variables C D E : Schema.

  Local Ltac t0 :=
    repeat ((apply SchemaMorphisms_equivalent)
              || reflexivity
              || (progress repeat subst)
              || (progress (simpl in *; JMeq_eq; intuition eauto))
              || (progress destruct_hypotheses)
              || intro
              || constructor
              || (match goal with
                    | [ H : _ |- _ ] => apply SchemaMorphism_equal_parts in H
                  end)
              || (progress split_and)
              || solve [ etransitivity; eauto ]).

  Lemma SchemaMorphismsEquivalent_refl (T : SchemaMorphism C D) : SchemaMorphismsEquivalent T T.
    t0.
  Qed.

  Lemma SchemaMorphismsEquivalent_sym (T U : SchemaMorphism C D) :
    SchemaMorphismsEquivalent T U -> SchemaMorphismsEquivalent U T.
    intro H; destruct H; t0.
    symmetry.
    t0.
  Qed.

  Lemma SchemaMorphismsEquivalent_trans (T U V : SchemaMorphism C D) :
    SchemaMorphismsEquivalent T U -> SchemaMorphismsEquivalent U V -> SchemaMorphismsEquivalent T V.
    intros H0 H1; destruct H0, H1; t0.
  Qed.

  Hint Resolve TEquivalenceOf.

  Lemma PreComposeSchemaMorphismsEquivalent (T T' : SchemaMorphism C D) (U : SchemaMorphism D E) :
    SchemaMorphismsEquivalent T T' -> SchemaMorphismsEquivalent (ComposeSchemaMorphisms U T) (ComposeSchemaMorphisms U T').
    intro H; destruct H. t0.
  Qed.

  Hint Resolve concatenate_mor.

  Lemma PostComposeSchemaMorphismsEquivalent (T : SchemaMorphism C D) (U U' : SchemaMorphism D E) :
    SchemaMorphismsEquivalent U U' -> SchemaMorphismsEquivalent (ComposeSchemaMorphisms U T) (ComposeSchemaMorphisms U' T).
    intro H; destruct H; t0.
    destruct T; unfold TransferPath; t0.
    match goal with
      | [ |- ?Rel (transferPath _ _ _ _ ?p) (transferPath _ _ _ _ ?p) ] => induction p; simpl; try reflexivity
    end; eauto.
  Qed.
End SchemaMorphismsEquivalent_Relation.

Add Parametric Relation C D : _ (@SchemaMorphismsEquivalent C D)
  reflexivity proved by (@SchemaMorphismsEquivalent_refl _ _)
  symmetry proved by (@SchemaMorphismsEquivalent_sym _ _)
  transitivity proved by (@SchemaMorphismsEquivalent_trans _ _)
    as SchemaMorphismsEquivalent_rel.

Add Parametric Morphism C D E : (@ComposeSchemaMorphisms C D E)
  with signature (@SchemaMorphismsEquivalent _ _) ==> (@SchemaMorphismsEquivalent _ _) ==> (@SchemaMorphismsEquivalent _ _)
    as ComposeSchemaMorphisms_mor.
  intros ? ? H0 ? ? H1.
  etransitivity; try apply PostComposeSchemaMorphismsEquivalent; eauto;
    apply PreComposeSchemaMorphismsEquivalent; eauto.
Qed.
