(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing ≄ %\ensuremath{\not\simeq}% #&#8772;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
(** printing ℙ %\ensuremath{\mathbb{P}}% #&#x2119;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ↦ %\ensuremath{\mapsto}% #&#21A6# *)
(** printing ↪ %\ensuremath{\hookrightarrow}% #&rarrhk;# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ∫ %\ensuremath{\int}% #&int;# *)
(** printing ▻ %\ensuremath{\triangleright}% #&#x25BB;# *)
(** printing ◅ %\ensuremath{\triangleleft}% #&#x25C5;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ≰ %\ensuremath{\not\le}% #&#x2270;# *)
(** printing ≱ %\ensuremath{\not\ge}% #&#x2271;# *)
(** printing ≼ %\ensuremath{\preceq}% #&#x227c;# *)
(** printing ≽ %\ensuremath{\succeq}% #&#x227d;# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import ProofIrrelevance FunctionalExtensionality.
Require Import String.
Require Import Category PathsCategory Functor SetCategory Grothendieck.
Require Import Common Notations.

Set Implicit Arguments.

Generalizable All Variables.

(** ------------------------------------------------------------------------ *)

(** * Exercise 4.6.2.4 *)
Module Exercise_4_6_2_4.
  (** ** Problem *)
  (** Come up with a schema and instance whose category of elements
      contains (at least) the data from (4.21):

<<
      Subject | Predicate         | Object
      -----------------------------------------------------------------
      A01     | occuredOn         | D13114
      A01     | performedBy       | P44
      A01     | actionDescription | Told congress to raise debt ceiling
      D13114  | hasYear           | 2013
      D13114  | hasMonth          | January
      D13114  | hasDay            | 14
      P44     | FirstName         | Barack
      P44     | LastName          | Obama
>>

 *)
  (** ** Solution *)
  (** The schema has as objects: action ids, people ids, date ids,
      strings, and months.  It has as morphisms the listed predicates.
      The instance is the obvious one, filled out below. *)

  (** Define the data types *)
  Inductive DateIds := D13114.
  Inductive PersonIds := P44.
  Inductive ActionIds := A01.
  Inductive Months := January | February | March | April | May | June
                      | July | August | September | October | November
                      | December.

  (** Define the type of objects. *)
  Inductive objC := ActionId | DateId | PersonId | String | Year | Day | Month.

  (** Define the type of morphisms by specifying which edges exist. *)

  Inductive morC : objC -> objC -> Type :=
  | occuredOn         : ActionId ~~> DateId
  | performedBy       : ActionId ~~> PersonId
  | actionDescription : ActionId ~~> String
  | hasYear           : DateId   ~~> Year
  | hasMonth          : DateId   ~~> Month
  | hasDay            : DateId   ~~> Day
  | FirstName         : PersonId ~~> String
  | LastName          : PersonId ~~> String
                        where "a ~~> b" := (morC a b).

  Local Infix "~~>" := morC.
  Local Infix "~~~>" := (path morC).

  (** Define the schema *)
  Definition C : @Category objC
    := PathsCategory morC.

  (** Define the action of the instance on objects. *)
  Definition Inst_ObjectOf : C -> Set
    := fun x => match x with
                  | ActionId => ActionIds
                  | DateId => DateIds
                  | PersonId => PersonIds
                  | String => string
                  | Year => nat
                  | Day => nat
                  | Month => Months
                end.

  (** Define the generating function of the action of the instance on
      morphisms (here, edges). *)

  Definition Inst_MorphismOf_Gen s d
  : morC s d -> (Inst_ObjectOf s -> Inst_ObjectOf d)
    := fun m => match m in s ~~> d return (Inst_ObjectOf s -> Inst_ObjectOf d) with
                  | occuredOn
                    => fun x : ActionIds
                       => match x return DateIds with
                            | A01 => D13114
                          end
                  | performedBy
                    => fun x : ActionIds
                       => match x return PersonIds with
                            | A01 => P44
                          end
                  | actionDescription
                    => fun x : ActionIds
                       => match x return string with
                            | A01 => "Told congress to raise debt ceiling"%string
                          end
                  | hasYear
                    => fun x : DateIds
                       => match x return nat with
                            | D13114 => 2013
                          end
                  | hasMonth
                    => fun x : DateIds
                       => match x return Months with
                            | D13114 => January
                          end
                  | hasDay
                    => fun x : DateIds
                       => match x return nat with
                            | D13114 => 14
                          end
                  | FirstName
                    => fun x : PersonIds
                       => match x return string with
                            | P44 => "Barack"%string
                          end
                  | LastName
                    => fun x : PersonIds
                       => match x return string with
                            | P44 => "Obama"%string
                          end
                end.

  (** Lift the action on edges to an action on paths. *)

  Definition Inst_MorphismOf s d (m : Morphism C s d)
  : Morphism CategoryOfTypes (Inst_ObjectOf s) (Inst_ObjectOf d)
  := compose_path Inst_ObjectOf Inst_MorphismOf_Gen m.

  (** To prove that the instance is a functor, we do some combination
      of: path induction, applying [reflexivity], applying [simpl],
      using functional extensionality, rewriting with the induction
      hypothesis, and rewriting with hypotheses. *)

  Local Ltac t_fin :=
    repeat match goal with
             | _ => reflexivity
             | _ => intro
             | _ => progress simpl in *
             | _ => apply functional_extensionality_dep
             | _ => apply f_equal
             | [ H : _, m : _ |- _ ] => rewrite (H _ m); reflexivity
             | _ => progress hnf in *
           end.

  Local Ltac revert_all_but H :=
    repeat match goal with
             | [ H' : _ |- _ ] => (constr_eq H' H; fail 1) || revert H'
           end.

  Local Ltac inst_t :=
    try t_fin;
    match goal with
      | [ H : _ |- _ ] => revert_all_but H; induction H; solve [ t_fin ]
    end.

  Definition I : Functor C CategoryOfTypes.
    refine {| MorphismOf := Inst_MorphismOf |};
    abstract inst_t.
  Defined.

  (** Define the type of RDF triples, the [CategoryOfElements]. *)

  Definition RDF := ∫ I.

  Local Notation "[ a ]" := (AddEdge NoEdges a).

  (** Define a helper function for the type of morphisms in [RDF] (the
      type is [sigT P], and a helper notation/alias for building
      elements in the RDF store. *)

  Definition P := (fun sd : RDF * RDF => Morphism RDF (fst sd) (snd sd)).
  Notation Build_RDF a b e c d :=
    (existT P
            (Build_GrothendieckPair I a b,
             Build_GrothendieckPair I c d)
            (exist _ e eq_refl)).

  Local Open Scope string_scope.
  (** Since Coq is bad at dealing with big numbers (they're stored in
      unary), we need to alias 2013. *)

  Let Year_2013 := 2013.

  (** Now we show that all of the relevant examples are captured by
      our RDF. *)

  Example RDF_1 := Build_RDF  ActionId A01     [occuredOn]         DateId   D13114.
  Example RDF_2 := Build_RDF  ActionId A01     [performedBy]       PersonId P44.
  Example RDF_3 := Build_RDF  ActionId A01     [actionDescription] String   "Told congress to raise debt ceiling".
  Example RDF_4 := Build_RDF  DateId   D13114  [hasYear]           Year     Year_2013.
  Example RDF_5 := Build_RDF  DateId   D13114  [hasMonth]          Month    January.
  Example RDF_6 := Build_RDF  DateId   D13114  [hasDay]            Day      14.
  Example RDF_7 := Build_RDF  PersonId P44     [FirstName]         String   "Barack".
  Example RDF_8 := Build_RDF  PersonId P44     [LastName]          String   "Obama".

  (** Note that [Build_RDF] fails if we have an RDF triple that
      doesn't come from the given instance. *)

  Fail Example RDF_bad := Build_RDF  PersonId P44     [LastName]          String   "Barck".
End Exercise_4_6_2_4.
(** ------------------------------------------------------------------------ *)
