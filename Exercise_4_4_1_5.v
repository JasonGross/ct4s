(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing ≄ %\ensuremath{\not\simeq}% #&#8772;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import FunctionalExtensionality JMeq EqdepFacts Relation_Definitions.
Require Import Schema SchemaMorphism Path.
Require Import Common Notations FEqualDep.

Set Implicit Arguments.

Generalizable All Variables.

(** ------------------------------------------------------------------------ *)

(** * Exercise 4.4.1.5 *)
Module Exercise_4_4_1_5.
  (** ** Problem *)
  (**
<<
              g
           a ---> b
     C :=   \     |
            i \   | h
                ↘ ↓
                  c

>>

      Consider the schema [[2]] and the schema [C] pictured above,
      except where this time we do not impose any path equivalence
      declarations on [C], so [[g, h] ≄ [i]] in our current version of
      [C].

      (a) How many schema morphisms are there [[2] -> C] that send
          [0] to [a]?

      (b) How many schema morphisms are there [C -> [2]] that send [a]
          to [0]? *)
  (** ** Solution *)
  (** (a) There are 8.  See the definitions of
          [Exercise_4_4_1_5_a_SchemaMorphism]n for a list.

      (b) There is at most one path between any two vertices in [[2]].
          Thus the map is uniquely determined by where the vertices
          are sent.  If we send [c] to [0], then we must send [b] to
          [0].  If we send [c] to [1], then we can send [b] to [0] or
          [1].  If we send [c] to [2], we can send [b] to [0], [1], or
          [2].  Thus we have 6 morphisms which send [a] to [0].  *)

  Inductive C_Vertex := a | b | c.
  Inductive C_Edge : C_Vertex -> C_Vertex -> Set :=
  | g : C_Edge a b
  | h : C_Edge b c
  | i : C_Edge a c.
  Definition C : Schema.
    refine (@Build_Schema C_Vertex
                          C_Edge
                          (fun _ _ => @eq _)
                          _
                          _
                          _);
    abstract (repeat (intro || split); subst; reflexivity).
  Defined.

  (** The graph [2] is [0 -> 1 -> 2]; we have three vertices, and an
      edge from [Zero] to [One], and one from [One] to [Two] *)
  Inductive LinearOrder2Schema_Vertex := Zero | One | Two.
  Inductive LinearOrder2Schema_Edge
  : LinearOrder2Schema_Vertex -> LinearOrder2Schema_Vertex -> Set :=
  | Zero_One : LinearOrder2Schema_Edge Zero One
  | One_Two : LinearOrder2Schema_Edge One Two.
  Definition LinearOrder2Schema : Schema.
    refine (@Build_Schema LinearOrder2Schema_Vertex
                          LinearOrder2Schema_Edge
                          (fun _ _ => @eq _)
                          _
                          _
                          _);
    abstract (repeat (intro || split); subst; reflexivity).
  Defined.

  (** Since the relation is equality, we don't need to prove anything
      about path equivalence each time. *)
  Definition SchemaMorphism_template
             (VO : LinearOrder2Schema -> C)
             (PO : forall s d,
                     SEdge LinearOrder2Schema s d
                     -> path (SEdge C) (VO s) (VO d))
  : SchemaMorphism LinearOrder2Schema C.
    refine (@Build_SchemaMorphism LinearOrder2Schema C
                                  VO
                                  PO
                                  _).
    abstract (intros; hnf in *; subst; reflexivity).
  Defined.

  Definition SchemaMorphism_template'
             (VO : C -> LinearOrder2Schema)
             (PO : forall s d,
                     SEdge C s d
                     -> path (SEdge LinearOrder2Schema) (VO s) (VO d))
  : SchemaMorphism C LinearOrder2Schema.
    refine (@Build_SchemaMorphism C LinearOrder2Schema
                                  VO
                                  PO
                                  _).
    abstract (intros; hnf in *; subst; reflexivity).
  Defined.

  (** We prove uniqueness of paths by repeatedly destructing paths,
        and observing that we have caught all of the values which
        type-check.  All of the extra tactic code here is to deal with
        annoyances in dependent typing. *)
  Local Ltac paths_unique_t :=
    intros; compute;
    try apply JMeq_eq;
    repeat match goal with
             | [ |- ?a = ?b \/ ?c = ?d ] =>
               cut (a == b \/ c == d);
                 [
                   intros [? | ?]; solve [ left; apply JMeq_eq; assumption
                                         | right; apply JMeq_eq; assumption ]
                 | ]
             | [ |- AddEdge _ _ == NoEdges ] => exfalso
             | [ H : _ |- _ ] => inversion H; subst;
                                 match goal with
                                   | [ H : _ |- _ ] => solve [ inversion H ]
                                 end
             | [ H : C_Edge _ _ |- _ ] => destruct H
             | [ H : LinearOrder2Schema_Edge _ _ |- _ ] => destruct H
             | _ => subst; apply eq_JMeq; apply f_equal2; try reflexivity; []; apply JMeq_eq
             | _ => subst; right; apply eq_JMeq; apply f_equal2; try reflexivity; []; apply JMeq_eq
             | _ => subst; left; apply eq_JMeq; apply f_equal2; try reflexivity; []; apply JMeq_eq
             | [ p : path ?E ?x ?y |- _ ]
               => let x' := fresh in
                  let y' := fresh in
                  pose x as x';
                    pose y as y';
                    assert (x = x') by reflexivity;
                    assert (y = y') by reflexivity;
                    change (path E x y) with (path E x' y') in p;
                    repeat match goal with
                             | [ |- context[@JMeq (path E x y) p ?T ?p'] ] =>
                               progress (change (@JMeq (path E x y) p T p')
                                         with (@JMeq (path E x' y') p T p'))
                           end;
                    clearbody x' y';
                    destruct p;
                    try (subst; reflexivity)
           end.

  Local Ltac mk_f_x f x fx :=
    let H := fresh in
    pose (f x) as fx; assert (f x = fx) by reflexivity; clearbody fx.

  (** This tactic will solve the monster uniqueness proof at the
        end; it attempts to prove that two schema morphisms are equal
        by rewriting with hypotheses and reflexivity. *)
  Local Ltac t_unique_solve :=
    solve [
        apply SchemaMorphism_Eq; simpl;
        intros;
        destruct_head_hnf LinearOrder2Schema_Edge;
        destruct_head_hnf C_Edge;
        try assumption;
        match goal with
          | [ H : _ |- _ ] => rewrite H; reflexivity
        end
      ].

  (** When we have all of the information we need about a function,
        we use this tactic to (exhaustively) figure out which branch
        of the [or] we can prove. *)
  Local Ltac t_unique_solve_recr :=
    t_unique_solve || (left; t_unique_solve_recr) || (right; t_unique_solve_recr).

  Section part_a.
    (** We define the possibilities of what the morphisms does on
        vertices. *)
    Definition a_OnVertices0 : LinearOrder2Schema -> C :=
      fun v => match v with Zero => a | One => a | Two => a end.
    Definition a_OnVertices1 : LinearOrder2Schema -> C :=
      fun v => match v with Zero => a | One => a | Two => b end.
    Definition a_OnVertices2 : LinearOrder2Schema -> C :=
      fun v => match v with Zero => a | One => a | Two => c end.
    Definition a_OnVertices3 : LinearOrder2Schema -> C :=
      fun v => match v with Zero => a | One => b | Two => a end.
    Definition a_OnVertices4 : LinearOrder2Schema -> C :=
      fun v => match v with Zero => a | One => b | Two => b end.
    Definition a_OnVertices5 : LinearOrder2Schema -> C :=
      fun v => match v with Zero => a | One => b | Two => c end.
    Definition a_OnVertices6 : LinearOrder2Schema -> C :=
      fun v => match v with Zero => a | One => c | Two => a end.
    Definition a_OnVertices7 : LinearOrder2Schema -> C :=
      fun v => match v with Zero => a | One => c | Two => b end.
    Definition a_OnVertices8 : LinearOrder2Schema -> C :=
      fun v => match v with Zero => a | One => c | Two => c end.

    (** We define the possibilities of what the morphisms does on
        edges. *)
    Definition a_path_a_a_0 : path C_Edge a a := NoEdges.
    Definition a_path_b_b_0 : path C_Edge b b := NoEdges.
    Definition a_path_c_c_0 : path C_Edge c c := NoEdges.
    Definition a_path_a_b_0 : path C_Edge a b := AddEdge NoEdges g.
    Definition a_path_b_c_0 : path C_Edge b c := AddEdge NoEdges h.
    Definition a_path_a_c_0 : path C_Edge a c := AddEdge NoEdges i.
    Definition a_path_a_c_1 : path C_Edge a c := AddEdge (AddEdge NoEdges g) h.

    (** Here we list all the possible morphisms.  We prove that these
        are the only ones below. *)
    Definition Exercise_4_4_1_5_a_SchemaMorphism0 : SchemaMorphism LinearOrder2Schema C
      := SchemaMorphism_template a_OnVertices0 (fun _ _ e => match e with Zero_One => a_path_a_a_0 | One_Two => a_path_a_a_0 end).
    Definition Exercise_4_4_1_5_a_SchemaMorphism1 : SchemaMorphism LinearOrder2Schema C
      := SchemaMorphism_template a_OnVertices1 (fun _ _ e => match e with Zero_One => a_path_a_a_0 | One_Two => a_path_a_b_0 end).
    Definition Exercise_4_4_1_5_a_SchemaMorphism2 : SchemaMorphism LinearOrder2Schema C
      := SchemaMorphism_template a_OnVertices2 (fun _ _ e => match e with Zero_One => a_path_a_a_0 | One_Two => a_path_a_c_0 end).
    Definition Exercise_4_4_1_5_a_SchemaMorphism3 : SchemaMorphism LinearOrder2Schema C
      := SchemaMorphism_template a_OnVertices2 (fun _ _ e => match e with Zero_One => a_path_a_a_0 | One_Two => a_path_a_c_1 end).
    Definition Exercise_4_4_1_5_a_SchemaMorphism4 : SchemaMorphism LinearOrder2Schema C
      := SchemaMorphism_template a_OnVertices4 (fun _ _ e => match e with Zero_One => a_path_a_b_0 | One_Two => a_path_b_b_0 end).
    Definition Exercise_4_4_1_5_a_SchemaMorphism5 : SchemaMorphism LinearOrder2Schema C
      := SchemaMorphism_template a_OnVertices5 (fun _ _ e => match e with Zero_One => a_path_a_b_0 | One_Two => a_path_b_c_0 end).
    Definition Exercise_4_4_1_5_a_SchemaMorphism6 : SchemaMorphism LinearOrder2Schema C
      := SchemaMorphism_template a_OnVertices8 (fun _ _ e => match e with Zero_One => a_path_a_c_0 | One_Two => a_path_c_c_0 end).
    Definition Exercise_4_4_1_5_a_SchemaMorphism7 : SchemaMorphism LinearOrder2Schema C
      := SchemaMorphism_template a_OnVertices8 (fun _ _ e => match e with Zero_One => a_path_a_c_1 | One_Two => a_path_c_c_0 end).

    Lemma a_path_a_a_only : forall x : path _ a a, x = a_path_a_a_0. paths_unique_t. Qed.
    Lemma a_path_b_b_only : forall x : path _ b b, x = a_path_b_b_0. paths_unique_t. Qed.
    Lemma a_path_c_c_only : forall x : path _ c c, x = a_path_c_c_0. paths_unique_t. Qed.
    Lemma a_path_a_b_only : forall x : path _ a b, x = a_path_a_b_0. paths_unique_t. Qed.
    Lemma a_path_b_c_only : forall x : path _ b c, x = a_path_b_c_0. paths_unique_t. Qed.
    Lemma a_path_a_c_only : forall x : path _ a c, x = a_path_a_c_0 \/ x = a_path_a_c_1. paths_unique_t. Qed.
    Lemma a_path_b_a_only : path C_Edge b a -> False. paths_unique_t. Qed.
    Lemma a_path_c_b_only : path C_Edge c b -> False. paths_unique_t. Qed.
    Lemma a_path_c_a_only : path C_Edge c a -> False. paths_unique_t. Qed.


    (** To prove that we have all of the functions on vertices, we
        first prove by extensionality that each function is determined
        by what it does on the three vertices, and we prove by
        assumption that it must be [a] on the first vertex.  We then
        exhastively list all possible options for the other two
        vertices (this is [destruct fOne, fTwo]), and let Coq figure
        out that one of the options is the one we want ([intuition]). *)

    Lemma a_OnVertices_only : forall f : LinearOrder2Schema -> C,
                                f Zero = a
                                -> f = a_OnVertices0
                                   \/ f = a_OnVertices1
                                   \/ f = a_OnVertices2
                                   \/ f = a_OnVertices3
                                   \/ f = a_OnVertices4
                                   \/ f = a_OnVertices5
                                   \/ f = a_OnVertices6
                                   \/ f = a_OnVertices7
                                   \/ f = a_OnVertices8.
      intros f H.
      mk_f_x f Zero fZero.
      mk_f_x f One fOne.
      mk_f_x f Two fTwo.
      let H := fresh in
      assert (H : f = fun v => match v with Zero => fZero | One => fOne | Two => fTwo end)
        by (apply functional_extensionality_dep; intros []; intuition);
        repeat rewrite H; clear H;
        subst fZero;
        match goal with
          | [ H : f Zero = _ |- _ ] => rewrite H
        end;
        clear;
        compute;
        destruct fOne, fTwo;
        intuition.
    Qed.

    (** We now prove that all schema morphisms we're interested in
        come from [SchemaMorphism_template]. *)
    Lemma a_schema_morphism_all_template
    : forall F : SchemaMorphism LinearOrder2Schema C,
        F = SchemaMorphism_template (VertexOf F) (PathOf F).
      intros.
      apply SchemaMorphism_Eq; simpl;
      reflexivity.
    Qed.

    Lemma a_schema_morphsim_on_paths
          VO
          (PO : forall s d : LinearOrder2Schema,
                  SEdge LinearOrder2Schema s d → path (SEdge C) (VO s) (VO d))
    : PO = (fun _ _ e => match e with Zero_One => PO _ _ Zero_One | One_Two => PO _ _ One_Two end).
      repeat (apply functional_extensionality_dep; intro).
      match goal with | [ |- context[match ?E with _ => _ end] ] => destruct E end;
        reflexivity.
    Qed.


    (** Now we get to this monster of a proof, where we prove that
        we've found all of the schema morphisms.  By exhaustion.  (The
        proof is exhaustive, but not intentionally exhausing.) *)

    (** Try to pose each of the uniqueness lemmas about path uniqueness. *)
    Local Ltac pose_path_uniqueness_proof p :=
      ((pose proof (a_path_a_a_only p))
         || (pose proof (a_path_a_b_only p))
         || (pose proof (a_path_a_c_only p))
         || (pose proof (a_path_b_a_only p))
         || (pose proof (a_path_b_b_only p))
         || (pose proof (a_path_b_c_only p))
         || (pose proof (a_path_c_a_only p))
         || (pose proof (a_path_c_b_only p))
         || (pose proof (a_path_c_c_only p))).

    (** Now, the proof.  We use the lemmas we've proven above about
        uniqueness of schema morphism parts.  The gigantic [match]
        statement is mostly silliness with dependent types done to
        appease Coq.  The key part of it is where we get to
        [pose_path_uniqueness_proof] of the paths at the end of the
        match, and then use the information to figure out which branch
        of the [or] we can prove. *)
    Theorem a_schema_morphism_all
    : forall F : SchemaMorphism LinearOrder2Schema C,
        F Zero = a
        -> F = Exercise_4_4_1_5_a_SchemaMorphism0
           \/ F = Exercise_4_4_1_5_a_SchemaMorphism1
           \/ F = Exercise_4_4_1_5_a_SchemaMorphism2
           \/ F = Exercise_4_4_1_5_a_SchemaMorphism3
           \/ F = Exercise_4_4_1_5_a_SchemaMorphism4
           \/ F = Exercise_4_4_1_5_a_SchemaMorphism5
           \/ F = Exercise_4_4_1_5_a_SchemaMorphism6
           \/ F = Exercise_4_4_1_5_a_SchemaMorphism7.
      intros F H.
      rewrite (a_schema_morphism_all_template F).
      rewrite (@a_schema_morphsim_on_paths _ (PathOf F)).
      destruct (a_OnVertices_only F H); clear H;
      destruct_head_hnf @or;
      match goal with
        | [ H : VertexOf ?F = ?G |- _ ]
          => let p01 := fresh in
             let H01 := fresh in
             let p12 := fresh in
             let H12 := fresh in
             let f0 := fresh in
             let f1 := fresh in
             let f2 := fresh in
             let fH0 := fresh in
             let fH1 := fresh in
             let fH2 := fresh in
             pose (VertexOf F Zero) as f0;
               pose (VertexOf F One) as f1;
               pose (VertexOf F Two) as f2;
               assert (fH0 : VertexOf F Zero = f0) by reflexivity;
               assert (fH1 : VertexOf F One = f1) by reflexivity;
               assert (fH2 : VertexOf F Two = f2) by reflexivity;
               pose (PathOf F _ _ Zero_One : path _ f0 f1) as p01;
               pose (PathOf F _ _ One_Two : path _ f1 f2) as p12;
               assert (H01 : PathOf F _ _ Zero_One == p01) by reflexivity;
               assert (H12 : PathOf F _ _ One_Two == p12) by reflexivity;
               clearbody p01 p12 f0 f1 f2;
               rewrite H in fH0, fH1, fH2;
               subst; simpl in *;
               pose_path_uniqueness_proof p01;
               pose_path_uniqueness_proof p12
      end;
      destruct_head_hnf False;
      destruct_head_hnf @or;
      subst;
      t_unique_solve_recr.
    Qed.
  End part_a.

  Section part_b.
    (** We define the possibilities of what the morphisms does on
        vertices. *)
    Definition b_OnVertices0 : C -> LinearOrder2Schema :=
      fun v => match v with a => Zero | b => Zero | c => Zero end.
    Definition b_OnVertices1 : C -> LinearOrder2Schema :=
      fun v => match v with a => Zero | b => Zero | c => One  end.
    Definition b_OnVertices2 : C -> LinearOrder2Schema :=
      fun v => match v with a => Zero | b => Zero | c => Two  end.
    Definition b_OnVertices3 : C -> LinearOrder2Schema :=
      fun v => match v with a => Zero | b => One  | c => Zero end.
    Definition b_OnVertices4 : C -> LinearOrder2Schema :=
      fun v => match v with a => Zero | b => One  | c => One  end.
    Definition b_OnVertices5 : C -> LinearOrder2Schema :=
      fun v => match v with a => Zero | b => One  | c => Two  end.
    Definition b_OnVertices6 : C -> LinearOrder2Schema :=
      fun v => match v with a => Zero | b => Two  | c => Zero end.
    Definition b_OnVertices7 : C -> LinearOrder2Schema :=
      fun v => match v with a => Zero | b => Two  | c => One  end.
    Definition b_OnVertices8 : C -> LinearOrder2Schema :=
      fun v => match v with a => Zero | b => Two  | c => Two  end.

    (** We define the possibilities of what the morphisms does on
        edges. *)
    Definition b_path_0_0 : path LinearOrder2Schema_Edge Zero Zero := NoEdges.
    Definition b_path_1_1 : path LinearOrder2Schema_Edge One One := NoEdges.
    Definition b_path_2_2 : path LinearOrder2Schema_Edge Two Two := NoEdges.
    Definition b_path_0_1 : path LinearOrder2Schema_Edge Zero One := AddEdge NoEdges Zero_One.
    Definition b_path_1_2 : path LinearOrder2Schema_Edge One Two := AddEdge NoEdges One_Two.
    Definition b_path_0_2 : path LinearOrder2Schema_Edge Zero Two := AddEdge (AddEdge NoEdges Zero_One) One_Two.

    (** Here we list all the possible morphisms.  We prove that these
        are the only ones below. *)
    Definition Exercise_4_4_1_5_b_SchemaMorphism0 : SchemaMorphism C LinearOrder2Schema
      := SchemaMorphism_template' b_OnVertices0 (fun _ _ e => match e with g => b_path_0_0 | h => b_path_0_0 | i => b_path_0_0 end).
    Definition Exercise_4_4_1_5_b_SchemaMorphism1 : SchemaMorphism C LinearOrder2Schema
      := SchemaMorphism_template' b_OnVertices1 (fun _ _ e => match e with g => b_path_0_0 | h => b_path_0_1 | i => b_path_0_1 end).
    Definition Exercise_4_4_1_5_b_SchemaMorphism2 : SchemaMorphism C LinearOrder2Schema
      := SchemaMorphism_template' b_OnVertices2 (fun _ _ e => match e with g => b_path_0_0 | h => b_path_0_2 | i => b_path_0_2 end).
    Definition Exercise_4_4_1_5_b_SchemaMorphism3 : SchemaMorphism C LinearOrder2Schema
      := SchemaMorphism_template' b_OnVertices4 (fun _ _ e => match e with g => b_path_0_1 | h => b_path_1_1 | i => b_path_0_1 end).
    Definition Exercise_4_4_1_5_b_SchemaMorphism4 : SchemaMorphism C LinearOrder2Schema
      := SchemaMorphism_template' b_OnVertices5 (fun _ _ e => match e with g => b_path_0_1 | h => b_path_1_2 | i => b_path_0_2 end).
    Definition Exercise_4_4_1_5_b_SchemaMorphism5 : SchemaMorphism C LinearOrder2Schema
      := SchemaMorphism_template' b_OnVertices8 (fun _ _ e => match e with g => b_path_0_2 | h => b_path_2_2 | i => b_path_0_2 end).


    Lemma b_path_0_0_only : forall x : path _ Zero Zero, x = b_path_0_0. paths_unique_t. Qed.
    Lemma b_path_1_1_only : forall x : path _ One One, x = b_path_1_1. paths_unique_t. Qed.
    Lemma b_path_2_2_only : forall x : path _ Two Two, x = b_path_2_2. paths_unique_t. Qed.
    Lemma b_path_0_1_only : forall x : path _ Zero One, x = b_path_0_1. paths_unique_t. Qed.
    Lemma b_path_1_2_only : forall x : path _ One Two, x = b_path_1_2. paths_unique_t. Qed.
    Lemma b_path_0_2_only : forall x : path _ Zero Two, x = b_path_0_2. paths_unique_t. Qed.
    Lemma b_path_1_0_only : path LinearOrder2Schema_Edge One Zero -> False. paths_unique_t. Qed.
    Lemma b_path_2_1_only : path LinearOrder2Schema_Edge Two One -> False. paths_unique_t. Qed.
    Lemma b_path_2_0_only : path LinearOrder2Schema_Edge Two Zero -> False. paths_unique_t. Qed.


    (** To prove that we have all of the functions on vertices, we
        first prove by extensionality that each function is determined
        by what it does on the three vertices, and we prove by
        assumption that it must be [a] on the first vertex.  We then
        exhastively list all possible options for the other two
        vertices (this is [destruct fOne, fTwo]), and let Coq figure
        out that one of the options is the one we want ([intuition]). *)

    Lemma b_OnVertices_only : forall f : C -> LinearOrder2Schema,
                                f a = Zero
                                -> f = b_OnVertices0
                                   \/ f = b_OnVertices1
                                   \/ f = b_OnVertices2
                                   \/ f = b_OnVertices3
                                   \/ f = b_OnVertices4
                                   \/ f = b_OnVertices5
                                   \/ f = b_OnVertices6
                                   \/ f = b_OnVertices7
                                   \/ f = b_OnVertices8.
      intros f H.
      mk_f_x f a fa.
      mk_f_x f b fb.
      mk_f_x f c fc.
      let H := fresh in
      assert (H : f = fun v => match v with a => fa | b => fb | c => fc end)
        by (apply functional_extensionality_dep; intros []; intuition);
        repeat rewrite H; clear H;
        subst fa;
        match goal with
          | [ H : f a = _ |- _ ] => rewrite H
        end;
        clear;
        compute;
        destruct fb, fc;
        intuition.
    Qed.

    (** We now prove that all schema morphisms we're interested in
        come from [SchemaMorphism_template]. *)
    Lemma b_schema_morphism_all_template'
    : forall F : SchemaMorphism C LinearOrder2Schema,
        F = SchemaMorphism_template' (VertexOf F) (PathOf F).
      intros.
      apply SchemaMorphism_Eq; simpl;
      reflexivity.
    Qed.

    Lemma b_schema_morphsim_on_paths
          VO
          (PO : forall s d : C,
                  SEdge C s d → path (SEdge LinearOrder2Schema) (VO s) (VO d))
    : PO = (fun _ _ e => match e with g => PO _ _ g | h => PO _ _ h | i => PO _ _ i end).
      repeat (apply functional_extensionality_dep; intro).
      match goal with | [ |- context[match ?E with _ => _ end] ] => destruct E end;
        reflexivity.
    Qed.


    (** Now we get to this monster of a proof, where we prove that
        we've found all of the schema morphisms.  By exhaustion.  (The
        proof is exhaustive, but not intentionally exhausing.) *)

    (** Try to pose each of the uniqueness lemmas about path uniqueness. *)
    Local Ltac pose_path_uniqueness_proof p :=
      ((pose proof (b_path_0_0_only p))
         || (pose proof (b_path_0_1_only p))
         || (pose proof (b_path_0_2_only p))
         || (pose proof (b_path_1_0_only p))
         || (pose proof (b_path_1_1_only p))
         || (pose proof (b_path_1_2_only p))
         || (pose proof (b_path_2_0_only p))
         || (pose proof (b_path_2_1_only p))
         || (pose proof (b_path_2_2_only p))).

    (** Now, the proof.  We use the lemmas we've proven above about
        uniqueness of schema morphism parts.  The gigantic [match]
        statement is mostly silliness with dependent types done to
        appease Coq.  The key part of it is where we get to
        [pose_path_uniqueness_proof] of the paths at the end of the
        match, and then use the information to figure out which branch
        of the [or] we can prove. *)
    Theorem b_schema_morphism_all
    : forall F : SchemaMorphism C LinearOrder2Schema,
        F a = Zero
        -> F = Exercise_4_4_1_5_b_SchemaMorphism0
           \/ F = Exercise_4_4_1_5_b_SchemaMorphism1
           \/ F = Exercise_4_4_1_5_b_SchemaMorphism2
           \/ F = Exercise_4_4_1_5_b_SchemaMorphism3
           \/ F = Exercise_4_4_1_5_b_SchemaMorphism4
           \/ F = Exercise_4_4_1_5_b_SchemaMorphism5.
      intros F H.
      rewrite (b_schema_morphism_all_template' F).
      rewrite (@b_schema_morphsim_on_paths _ (PathOf F)).
      destruct (b_OnVertices_only F H); clear H;
      destruct_head_hnf @or;
      match goal with
        | [ H : VertexOf ?F = ?G |- _ ]
          => let pab := fresh in
             let Hab := fresh in
             let pbc := fresh in
             let Hbc := fresh in
             let pac := fresh in
             let Hac := fresh in
             let fa := fresh in
             let fb := fresh in
             let fc := fresh in
             let fHa := fresh in
             let fHb := fresh in
             let fHc := fresh in
             pose (VertexOf F a) as fa;
               pose (VertexOf F b) as fb;
               pose (VertexOf F c) as fc;
               assert (fHa : VertexOf F a = fa) by reflexivity;
               assert (fHb : VertexOf F b = fb) by reflexivity;
               assert (fHc : VertexOf F c = fc) by reflexivity;
               pose (PathOf F _ _ g : path _ fa fb) as pab;
               pose (PathOf F _ _ h : path _ fb fc) as pbc;
               pose (PathOf F _ _ i : path _ fa fc) as pac;
               assert (Hab : PathOf F _ _ g == pab) by reflexivity;
               assert (Hbc : PathOf F _ _ h == pbc) by reflexivity;
               assert (Hac : PathOf F _ _ i == pac) by reflexivity;
               clearbody pab pbc pac fa fb fc;
               rewrite H in fHa, fHb, fHc;
               subst; simpl in *;
               pose_path_uniqueness_proof pab;
               pose_path_uniqueness_proof pbc;
               pose_path_uniqueness_proof pac
      end;
      destruct_head_hnf False;
      destruct_head_hnf @or;
      subst;
      t_unique_solve_recr.
    Qed.
  End part_b.
End Exercise_4_4_1_5.

(** ------------------------------------------------------------------------ *)
