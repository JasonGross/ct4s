(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing ≄ %\ensuremath{\not\simeq}% #&#8772;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
(** printing ℙ %\ensuremath{\mathbb{P}}% #&#x2119;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ↦ %\ensuremath{\mapsto}% #&#21A6# *)
(** printing ↪ %\ensuremath{\hookrightarrow}% #&rarrhk;# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ▻ %\ensuremath{\triangleright}% #&#x25BB;# *)
(** printing ◅ %\ensuremath{\triangleleft}% #&#x25C5;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ≰ %\ensuremath{\not\le}% #&#x2270;# *)
(** printing ≱ %\ensuremath{\not\ge}% #&#x2271;# *)
(** printing ≼ %\ensuremath{\preceq}% #&#x227c;# *)
(** printing ≽ %\ensuremath{\succeq}% #&#x227d;# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import ProofIrrelevance FunctionalExtensionality.
Require Import ClassicalFacts.
Require Import Ensembles.
Require Import Orders PropPreOrder PreOrderCategory.
Require Import Duals.
Require Import SetCategory EnsemblePreOrder.
Require Import Common Notations FEqualDep TopologyCategory Functor Morphism IndiscreteTopology DiscreteTopology.
Require Import Common Notations Orders PropPreOrder PreOrderCategory Duals.

Set Implicit Arguments.

Generalizable All Variables.

(** ------------------------------------------------------------------------ *)

(** * Exercise 4.6.1.5 *)
Module Exercise_4_6_1_5.
  Local Open Scope topology_scope.
  (** ** Problem *)
  (** In Exercises 4.2.3.2, 4.2.4.3, and 4.2.4.4 there were questions
      about whether a certain function [Ob(C) -> Ob(D)] extended to a
      functor [C -> D]. In each case, see if the proposed function would
      extend to a "contravariant functor" i.e. to a functor [C ᵒᵖ -> D]. *)

  (** *** Exercise 4.2.3.2 *)
  Section Exercise_4_2_3_2.
    (** **** Problem *)

    Record > EOpenSet `(Topology X) :=
      {
       OpenSetSet :> Ensemble X;
        OpenSetOpen :> Open OpenSetSet
      }.

    Lemma OpenSet_eq `(T : Topology X) (A B : EOpenSet T)
    : OpenSetSet A = OpenSetSet B
      -> A = B.
      destruct A, B; simpl; intro; subst;
      f_equal; apply ProofIrrelevance.proof_irrelevance.
    Qed.

    Global Instance opens_ordered_by_inclusion `(Topology X)
    : @PreOrder (EOpenSet _) (fun U V => U ⊆ V).
    split; firstorder.
    Qed.

    Definition continuous_induced_functor_object_of
               s d (m : Morphism CategoryOfTopologies s d)
    : (opens_ordered_by_inclusion d) -> (opens_ordered_by_inclusion s).
      intro; hnf in *.
      exists (inverse_image (proj1_sig m) X);
        simpl.
      abstract (
          destruct m as [f c];
          apply c;
          destruct X;
          assumption
        ).
    Defined.

    Definition continuous_induced_functor_morphism_of
               s d (m : Morphism CategoryOfTopologies s d)
    : forall s' d' (m' : Morphism (PreOrderCategory (opens_ordered_by_inclusion d))
                                  s'
                                  d'),
        Morphism (PreOrderCategory (opens_ordered_by_inclusion s))
                 (continuous_induced_functor_object_of m s')
                 (continuous_induced_functor_object_of m d').
      intros s' d' m' x H.
      hnf in m, m'.
      simpl in *.
      destruct m as [ f c ]; simpl in *.
      repeat unfold Ensembles.In, inverse_image in *.
      intuition.
    Qed.

    Definition continuous_induced_functor
               s d (m : Morphism CategoryOfTopologies d s)
    : Morphism CategoryOfPreOrders
               (opens_ordered_by_inclusion s)
               (opens_ordered_by_inclusion d).
      refine {| ObjectOf := (continuous_induced_functor_object_of m);
                MorphismOf := (continuous_induced_functor_morphism_of m) |};
      abstract (intros; simpl; apply ProofIrrelevance.proof_irrelevance).
    Defined.
    Definition PreOrderedSets
    : Functor (OppositeCategory CategoryOfTopologies) CategoryOfPreOrders.
      refine (Build_Functor (OppositeCategory CategoryOfTopologies)
                            CategoryOfPreOrders
                            (fun x => opens_ordered_by_inclusion x)
                            continuous_induced_functor
                            _
                            _);
      abstract (repeat (
                    reflexivity
                      || (progress (simpl; intros; expand))
                      || (progress destruct_head_hnf @EOpenSet)
                      || (apply f_equal)
                      || (apply ProofIrrelevance.proof_irrelevance)
                      || (apply proof_irrelevance_JMeq)
                      || (apply Functor_Eq)
               )).
    Defined.
  End Exercise_4_2_3_2.
  (** ------------------------------------------------------------------------ *)

  (** *** Exercise 4.2.4.3 *)
  Module Exercise_4_2_4_3.
    (** **** Problem *)

    Variable Law : Type.
    Variable LawAsProp : Law -> Prop.
    Variable Jurisdiction : Type.
    Variable LawsOf : Jurisdiction -> Ensemble Law.

    Local Infix "<=" := impl.
    Local Infix "≤" := impl.

    Section LawOfTheLand.
      Variable V : Jurisdiction.
      Let V_Laws : Ensemble Law := LawsOf V.
      Let V_LawsAsProp : Ensemble Prop := fun P =>
                                            exists L,
                                              L ∈ V_Laws
                                              /\ LawAsProp L = P.
      Definition LawOfTheLand := PropHasEnsembleMeets V_LawsAsProp.
    End LawOfTheLand.

    Lemma LawOfTheLand_subset_flip (U V : Jurisdiction) (P := Prop_PreOrder)
          (LawOfTheVLand := EnsembleMeetElement (EnsembleMeetOf := LawOfTheLand V))
          (LawOfTheULand := EnsembleMeetElement (EnsembleMeetOf := LawOfTheLand U))
    : LawsOf V ⊆ LawsOf U
      -> LawOfTheULand ≤ LawOfTheVLand.
    Proof.
      firstorder.
    Qed.

    Global Instance JurisdictionPreOrder
    : @PreOrder Jurisdiction (fun U V => LawsOf V ⊆ LawsOf U).
    firstorder.
    Qed.

    Definition LawOfTheLandFunctor
    : Functor (PreOrderCategory JurisdictionPreOrder)
              (PreOrderCategory Prop_PreOrder).
      refine (Build_Functor (PreOrderCategory JurisdictionPreOrder)
                            (PreOrderCategory Prop_PreOrder)
                            (fun V : Jurisdiction =>
                               EnsembleMeetElement
                                 (EnsembleMeetOf := LawOfTheLand V))
                            (fun s d (m : Morphism (PreOrderCategory JurisdictionPreOrder) s d)
                             => @LawOfTheLand_subset_flip _ _ m : Morphism (PreOrderCategory Prop_PreOrder) _ _)
                            _
                            _);
      abstract (intros; simpl; apply ProofIrrelevance.proof_irrelevance).
    Defined.
  End Exercise_4_2_4_3.

  (** ------------------------------------------------------------------------ *)

  (** *** Exercise 4.2.4.4 *)
  Module Exercise_4_2_4_4.
    (** **** Problem *)

    Variable Person : Type.
    Definition Jurisdiction := Ensemble Person.
    Variable Law : Type.
    Variable LawAsProp : Law -> Prop.
    Definition SetOfLaws := Ensemble Law.
    Variable RespectedLawsOfPerson : Person -> SetOfLaws.
    Inductive RespectedLawsOf (J : Jurisdiction) : SetOfLaws :=
    | RespectedLawsOfAll : forall law,
                             (forall person,
                                person ∈ J
                                -> law ∈ RespectedLawsOfPerson person)
                             -> law ∈ RespectedLawsOf J.

    Global Instance JurisdictionPreOrder
    : @PreOrder Jurisdiction (fun U V => U ⊆ V).
    firstorder.
    Qed.

    Global Instance SetsPreOrder : @PreOrder SetOfLaws _
      := Ensemble_PreOrder _.

    Hint Extern 1 => constructor.
    Hint Extern 1 => destruct_head_hnf @RespectedLawsOf.
    Definition RespectedLawsOfFunctor_MorphismOf
               s d (m : Morphism (OppositeCategory (PreOrderCategory JurisdictionPreOrder)) s d)
    : Morphism (PreOrderCategory SetsPreOrder)
               (RespectedLawsOf s)
               (RespectedLawsOf d).
      compute in *;
      repeat (split || intro);
      destruct_head_hnf @RespectedLawsOf.
      intuition.
    Qed.
    Definition RespectedLawsOfFunctor
    : Functor (OppositeCategory (PreOrderCategory JurisdictionPreOrder))
              (PreOrderCategory SetsPreOrder).
      refine (Build_Functor (OppositeCategory (PreOrderCategory JurisdictionPreOrder))
                            (PreOrderCategory SetsPreOrder)
                            (RespectedLawsOf)
                            (RespectedLawsOfFunctor_MorphismOf)
                            _
                            _);
      abstract (intros; simpl; apply ProofIrrelevance.proof_irrelevance).
    Defined.

    Section maximal_law.
      Variable S : SetOfLaws.
      Let SetOfLawsAsProp : Ensemble Prop := fun P =>
                                               exists L,
                                                 L ∈ S
                                                 /\ LawAsProp L = P.

      Definition maximal_law : Prop :=
        EnsembleMeetElement (EnsembleMeetOf := PropHasEnsembleMeets SetOfLawsAsProp).
    End maximal_law.
    Definition MaximalRespectedLawOfFunctor_MorphismOf
               s d (m : Morphism (PreOrderCategory JurisdictionPreOrder) s d)
    : Morphism (PreOrderCategory Prop_PreOrder)
               (maximal_law (RespectedLawsOf s))
               (maximal_law (RespectedLawsOf d)).
      repeat match goal with
               | _ => progress compute in *
               | _ => split
               | _ => intro
               | _ => progress destruct_head_hnf @RespectedLawsOf
               | _ => progress destruct_head_hnf @ex
               | _ => progress intuition
               | [ H : _ |- _ ] => apply H; clear H
               | _ => eexists; split; try eassumption; []
               | _ => constructor
               | _ => solve [ firstorder ]
             end.
    Defined.
    Definition MaximalRespectedLawOfFunctor
    : Functor (PreOrderCategory JurisdictionPreOrder)
              (PreOrderCategory Prop_PreOrder).
      refine (Build_Functor (PreOrderCategory JurisdictionPreOrder)
                            (PreOrderCategory Prop_PreOrder)
                            (fun J => maximal_law (RespectedLawsOf J))
                            MaximalRespectedLawOfFunctor_MorphismOf
                            _
                            _);
      abstract (intros; simpl; apply ProofIrrelevance.proof_irrelevance).
    Defined.
  End Exercise_4_2_4_4.
End Exercise_4_6_1_5.
(** ------------------------------------------------------------------------ *)
