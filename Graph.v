(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import JMeq.
Require Import FunctionalExtensionality ProofIrrelevance.
Require Import Common.

Set Implicit Arguments.

(** In a dependently typed programming language like, Coq, it is more
    natural to define a separate set of edges for each pair of
    vertices.  I define both this type of graph and the one in the
    book, and define an almost-isomorphism between them.  It's
    actually only an isomorphism up to isomorphism of types; it
    requires univalence to be a proper isomorphism. *)

Record Graph :=
  {
    Vertex :> Type;
    Edge : Vertex -> Vertex -> Type
  }.

Record Graph' :=
  {
    Vertex' :> Type;
    Arrow' : Type;
    Graph'Source : Arrow' -> Vertex';
    Graph'Target : Arrow' -> Vertex'
  }.

Section graph_equivalence.
  Definition GraphToGraph' (G : Graph) : Graph'
    := {| Vertex' := Vertex G;
          Arrow' := { sd : G × G & Edge G (fst sd) (snd sd) };
          Graph'Source := (fun sdm => fst (projT1 sdm));
          Graph'Target := (fun sdm => snd (projT1 sdm)) |}.

  Definition Graph'ToGraph (G : Graph') : Graph
    := {| Vertex := Vertex' G;
          Edge := (fun s d => { m : Arrow' G
                              | Graph'Source _ m = s
                                /\ Graph'Target _ m = d }) |}.
End graph_equivalence.

(** ** Graph Homomorphisms *)
Section graph_homomorphisms.
  Record GraphHomomorphism (G G' : Graph) :=
    {
      OnVertices :> Vertex G -> Vertex G';
      OnEdges
      : forall src tgt,
          Edge G src tgt
          -> Edge G' (OnVertices src) (OnVertices tgt)
    }.

  Definition identity_graph_homomorphism (G : Graph)
  : GraphHomomorphism G G.
    exists (fun x => x).
    exact (fun _ _ x => x).
  Defined.

  Definition compose_graph_homomorphisms
             (G G' G'' : Graph)
  : GraphHomomorphism G' G'' -> GraphHomomorphism G G' -> GraphHomomorphism G G''.
    intros m1 m2.
    exists (fun x => m1 (m2 x)).
    exact (fun _ _ e => OnEdges m1 _ _ (OnEdges m2 _ _ e)).
  Defined.

  Lemma GraphHomomorphism_Eq (G G' : Graph)
        (m m' : GraphHomomorphism G G')
  : (forall x, OnVertices m x = OnVertices m' x)
    -> (forall src tgt e, OnEdges m src tgt e == OnEdges m' src tgt e)
    -> m = m'.
    intros H1 H2.
    assert (H1' : OnVertices m = OnVertices m')
      by (apply functional_extensionality_dep; assumption);
      destruct m, m';
      simpl in *;
      subst;
      f_equal;
      repeat (apply functional_extensionality_dep; intro);
      apply JMeq_eq;
      intuition.
  Qed.
End graph_homomorphisms.

(** And now the version in the book *)
Section graph'_homomorphisms.
  Record Graph'Homomorphism (G G' : Graph') :=
    {
      OnVertices' :> Vertex' G -> Vertex' G';
      OnArrows' : Arrow' G -> Arrow' G';
      SourceCommutes' : forall x, OnVertices' (Graph'Source G x)
                                  = Graph'Source G' (OnArrows' x);
      TargetCommutes' : forall x, OnVertices' (Graph'Target G x)
                                  = Graph'Target G' (OnArrows' x)
    }.

  Definition identity_graph'_homomorphism (G : Graph')
  : Graph'Homomorphism G G.
    exists (fun x => x) (fun x => x);
    reflexivity.
  Defined.

  Definition compose_graph'_homomorphisms
             (G G' G'' : Graph')
  : Graph'Homomorphism G' G'' -> Graph'Homomorphism G G' -> Graph'Homomorphism G G''.
    intros m1 m2.
    exists (fun x => m1 (m2 x)) (fun x => OnArrows' m1 (OnArrows' m2 x));
      abstract (
          intros;
          simpl;
          repeat rewrite SourceCommutes';
          repeat rewrite TargetCommutes';
          reflexivity
        ).
  Defined.

  Lemma Graph'Homomorphism_Eq (G G' : Graph')
        (m m' : Graph'Homomorphism G G')
  : (forall x, OnVertices' m x = OnVertices' m' x)
    -> (forall x, OnArrows' m x = OnArrows' m' x)
    -> m = m'.
    intros H1 H2.
    assert (H1' : OnVertices' m = OnVertices' m')
      by (apply functional_extensionality_dep; assumption).
    assert (H2' : OnArrows' m = OnArrows' m')
      by (apply functional_extensionality_dep; assumption).
    destruct m, m';
      simpl in *;
      subst;
      f_equal;
      apply ProofIrrelevance.proof_irrelevance.
  Qed.
End graph'_homomorphisms.

Section conversion.
  Definition GraphHomomorphismToGraph'Homomorphism (G G' : Graph) (f : GraphHomomorphism G G')
  : Graph'Homomorphism (GraphToGraph' G) (GraphToGraph' G')
    := Build_Graph'Homomorphism (GraphToGraph' G) (GraphToGraph' G')
                                (OnVertices f)
                                (fun sde => existT _
                                                   (OnVertices f (fst (projT1 sde)),
                                                    OnVertices f (snd (projT1 sde)))
                                                   (OnEdges f _ _ (projT2 sde))
                                            : { sd : G' × G' & Edge G' (fst sd) (snd sd) } )
                                (fun _ => eq_refl)
                                (fun _ => eq_refl).

  Definition Graph'HomomorphismToGraphHomomorphism (G G' : Graph') (f : Graph'Homomorphism G G')
  : GraphHomomorphism (Graph'ToGraph G) (Graph'ToGraph G').
    refine (Build_GraphHomomorphism (Graph'ToGraph G) (Graph'ToGraph G')
                                    (OnVertices' f)
                                    (fun src tgt m => exist _ (OnArrows' f (proj1_sig m)) _));
    abstract (
        split;
        (rewrite <- (SourceCommutes' f) || rewrite <- (TargetCommutes' f));
        destruct_head_hnf @sig;
        split_and;
        subst;
        reflexivity
      ).
  Defined.
End conversion.
