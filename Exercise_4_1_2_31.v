(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import Omega JMeq.
Require Import Common Isomorphism PathsCategory Graph.

Set Implicit Arguments.

Generalizable All Variables.

(** ------------------------------------------------------------------------ *)

(** * Exercise 4.1.2.31 *)
Module Exercise_4_1_2_31.
  (** ** Problem *)
  (** Recall the graph [G] from Example 3.3.1.2. Let [C = F(G)] be the
      free category on [G]. What is [Hom_C(v, x)]? What is [Hom_C(x,
      v)]?

      Here is a picture of the graph [G = (V, A, src, tgt):

<<
                                g
                             ________
               v    f     w /        ↘
               o -------> o           o x
                            \________↗
                                h
      G :=
                          j
                  __   ________
                 /  ↘ /        ↘
              i |    o y        o z
                 \__/ ↖________/
                          k
>>

      We have [V = {v, w, x, y, z}] and [A = {f, g, h, i, j, k}]. The
      source and target functions [src, tgt : A -> V] can be captured in
      the table to the left below:

<<
      A || src | tgt                V
      --------------               ---
      f || v   | w                  v
      g || w   | x                  w
      h || w   | x                  x
      i || y   | y                  y
      j || y   | z                  z
      k || z   | y
>>

   *)
  (** ** Solution *)
  (** We have
      - [Hom_C(v, x) = {gf, hf}]
      - [Hom_C(x, v) = {}]
   *)

  Inductive V := v | w | x | y | z.
  Inductive A : V -> V -> Set :=
  | f : A v w
  | g : A w x
  | h : A w x
  | i : A y y
  | j : A y z
  | k : A z y.

  Definition G : Graph := @Build_Graph V A.
  Definition C : Category := @PathsCategory (Vertex G) (Edge G).

  Inductive Hom_C_v_x := gf | hf.
  Definition Hom_C_x_v := ∅.

  Local Ltac t' tac :=
    repeat match goal with
             | _ => progress (simpl in *; repeat intro; hnf in *; tac; trivial)
             | [ H : _ |- _ ] => solve [ inversion H; trivial ]
             | [ H : _ |- _ ] => solve [ destruct H; trivial ]
             | [ H : _ |- _ ] => solve [ apply JMeq_eq; destruct H; try reflexivity; trivial ]
             | _ => progress subst_eq_refl
             | [ |- context[match ?x return ∅ with _ => _ end] ] => solve [ destruct x ]
           end.

  Local Ltac t'' tac :=
    repeat match goal with
             | [ e : A ?a ?b |- _ ] =>  let a' := fresh in
                                        let b' := fresh in
                                        set (a' := a) in *;
                                          set (b' := b) in *;
                                          cut (a = a'); [ | reflexivity ];
                                          cut (b = b'); [ | reflexivity ];
                                          destruct e;
                                          t' tac
             | _ => progress (repeat f_equal)
             | _ => progress clear
             | _ => progress (t' tac)
           end.

  Local Ltac t''' tac :=
    t'' tac; try (apply JMeq_eq; solve [ t'' tac ]).

  Local Ltac t'''' tac :=
    repeat match goal with
             | _ => progress (t'' tac; try solve [ left; t''' idtac | right; t''' idtac ])
             | [ H : _ = _ |- _ ] => destruct H
           end.

  (** We first show that [Hom_C(x, v)] contains no elements. *)
  Lemma Hom_C_x_v_empty_helper : Morphism C x v -> False.
    intro m; hnf in m.
    match goal with
      | [ m : path _ ?a ?b |- _ ] => let a' := fresh in
                                     let b' := fresh in
                                     set (a' := a) in *;
                                       set (b' := b) in *;
                                       cut (a = a'); [ | reflexivity ];
                                       cut (b = b'); [ | reflexivity ];
                                       clearbody a' b';
                                       induction m;
                                       t' subst
    end.
  Qed.

  (** We now show that [Hom_C(v, x)] contains only gf and hf. *)
  Lemma Hom_C_v_x_only_helper S D (m : Morphism C S D)
        (Hs : v = S)
        (Hd : x = D)
        (g' : Morphism C _ _ := AddEdge NoEdges g)
        (f' : Morphism C _ _ := AddEdge NoEdges f)
        (h' : Morphism C _ _ := AddEdge NoEdges h)
  : (m = match Hs with
           | eq_refl => (match Hd with
                           | eq_refl => g'
                         end o f')%morphism
         end)
    + (m = match Hs with
             | eq_refl => (match Hd with
                             | eq_refl => h'
                           end o f')%morphism
           end).
    hnf in m;
    subst g' f' h'; simpl.
    induction m; [ subst | ]; t' idtac.
    induction m; [ subst | ]; t' idtac.
    induction m; [ | ]; t' idtac;
    t'''' idtac.
  Qed.

  Let Hom {obj} C := @Morphism obj C.

  (** Now, the relevant proofs.  I first show that [Hom_C(x, v)] is
      isomorphic to the empty set *)
  Lemma Hom_C_x_v_empty : (Hom C x v ≅ ∅).
  Proof.
    exists (fun x : Hom C x v => match Hom_C_x_v_empty_helper x return ∅ with end).
    exists (fun x : ∅ => match x return _ with end);
      simpl;
      intro; t' idtac.
  Qed.

  (** Now, I show that [Hom_C(v, x)] is isomorphic to a two element set. *)
  Lemma Hom_C_v_x_empty : (Hom C v x ≅ Hom_C_v_x).
  Proof.
    exists (fun x : Hom C v x => match Hom_C_v_x_only_helper x eq_refl eq_refl with
                                   | inl _ => gf
                                   | inr _ => hf
                                 end).
    exists (let g' := AddEdge NoEdges g : Morphism C _ _ in
            let f' := AddEdge NoEdges f : Morphism C _ _ in
            let h' := AddEdge NoEdges h : Morphism C _ _ in
            (fun x : Hom_C_v_x => match x return _ with
                                    | gf => (g' o f')%morphism
                                    | hf => (h' o f')%morphism
                                  end));
      simpl;
      try intros [ | ];
      intros;
      try match goal with
            | [ |- context[match ?x with _ => _ end] ] => solve [ destruct x; t' idtac ]
          end.
  Qed.
End Exercise_4_1_2_31.

(** ------------------------------------------------------------------------ *)
