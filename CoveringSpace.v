(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing ⋂ %\ensuremath{\bigcap}% #&#8898;# *)
(** printing ⋃ %\ensuremath{\bigcup}% #&#8899;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8 Setoid.
Require Import ProofIrrelevance FunctionalExtensionality.
Require Import Finite_sets Classical IndefiniteDescription.
Require Import Classes.RelationClasses Morphisms.
Require Export Topology OpenCover TopologicalContinuity Homeomorphism SubspaceTopology.
Require Import Notations Common Morphism.

Set Implicit Arguments.

Generalizable All Variables.

(** * Topology *)
(** ** Covering Spaces *)

Local Open Scope topology_scope.

Section covering_space.
  Variable X : Type.
  Variable T : Topology X.

  Record IsCoveringSpace (X' : Type) (T' : Topology X') (p : X' -> X) :=
    {
      CoveringSpaceMap_continuous : continuous _ _ p;
      CoveringSpace_Cover :> Cover X;
      CoveringSpace_CoverOpen : cover_open T CoveringSpace_Cover;
      CoveringSpace_InverseImageSets : CoveringSpace_Cover -> Ensemble (Ensemble X');
      CoveringSpace_InverseImageSets_DisjointUnion : forall U : CoveringSpace_Cover,
                                                       IsDisjointUnion (inverse_image p (proj1_sig U));
      CoveringSpaceHomeomorphism : forall U : CoveringSpace_Cover,
                                   forall DU : CoveringSpace_InverseImageSets_DisjointUnion U,
                                     let H := (fun (x : X') H0 => disjoint_union_in (CoveringSpace_InverseImageSets_DisjointUnion U) DU _ H0) in
                                     Homeomorphism (SubspaceTopology _ _) (SubspaceTopology _ _) (restrict p (proj1_sig DU) (proj1_sig U) H)
    }.

  Record CoveringSpace (X' : Type) (T' : Topology X') :=
    {
      CoveringSpaceMap :> X' -> X;
      CoveringSpace_IsCoveringSpace :> @IsCoveringSpace X' T' CoveringSpaceMap
    }.

  Local Notation "p ⁻¹" := (inverse_image p) (at level 10).

  Lemma covering_space_subset_open X' T' (C : @CoveringSpace X' T') (U : Ensemble X') (E : C) (p := CoveringSpaceMap C)
        (E' : DisjointUnionSets (CoveringSpace_InverseImageSets_DisjointUnion C E))
  : Included _ U (proj1_sig E') -> Open U -> Open (image p U).
  Proof.
    intros.
    destruct C as [ CoveringSpaceMap0 [] ]; simpl in *.
    specialize_all_ways;
      repeat match goal with
               | [ H : _ |- _ ] => progress change CoveringSpaceMap0 with p in H |- *
             end;
      change (fun a b => ?f a b) with f in *.
    match goal with
      | [ _ : context[restrict p ?A ?B ?C], H : Included _ ?U _ |- Open (image ?p ?U) ] =>
        pose (image (restrict p A B C) (include_subset H)) as pU;
          cut (Open pU); [ cut (image p U = subset_ensemble pU) | ]
    end.
    - let H0 := fresh in
      let H1 := fresh in simpl; intros H0 H1; destruct H1 as [ U0 H1 ];
                         rewrite H0; rewrite H1;
                         apply FiniteIntersectionOpen; simpl; eta_red;
                         unfold cover_open in *;
                         match goal with
                           | [ |- Open (proj1_sig ?U) ] => destruct U; simpl in *; intuition
                         end.
    - subst_body; simpl in *.
      apply Extensionality_Ensembles; split; intros ? ?; simpl in *.
      split; simpl; eta_red;
      specialize_all_ways.
      repeat match goal with
               | [ H : appcontext[Homeomorphism] |- _ ] => clear H
             end.
      pose (proj1_sig E).
      simpl in *.
      (*match goal with
        | [ H : Included _ ?U _ |- In _ ?V _ ] => cut (Included _ U V)
      end.

      match goal with
        | [ H : In _ (image ?f ?U) ?x |- In _ ?V ?x ] =>
          cut (exists x', In _ U x' /\ f x' = x);
            [ let H := fresh in intro H; destruct H as [ H [] ]; subst; simpl in * | ]
      end.
      destruct_head IsDisjointUnion.
      specialize_all_ways.
      unfold Included in *.
      pose (DisjointUnionIsUnion E').
      Print IsDisjointUnion.
      hnf in *;
        intuition.
      compute.
      trivial.
      hnf in U0.
      Print Topology.
      subst_body; simpl in *;
      unfold include_subset, subset_ensemble in *; simpl in *.
      unfold SubspaceTopol
             subst_body; simpl.
      match goal with
        | [ |- Open ?X -> Open ?Y ] => pose X; pose Y
      end.
      Print SubspaceTopology.
      unfold Open at 1.
      Set Printing All.
      Arguments Open X T _ : rename.
      Set Pri
          Print Open.
      Implicit Arguments Open [].
      Set Printing Coercions.
      intro.
      unfold include_subset, image, restrict; simpl.
      match goal with
        | [ H : Included _ U _ |- _ ] => pose (include_subset H)
      end.
      unfold restrict in *; simpl in *.
      hnf in e. *)
  Admitted.


  Lemma covering_space_open_to_open X' T' (C : @CoveringSpace X' T') (U : Ensemble X') (p := CoveringSpaceMap C)
  : Open U -> Open (image p U).
  Proof.
    intros.

  Admitted.


  Lemma covering_space_inverse_image_open X' T' (C : @CoveringSpace X' T') (U : Ensemble X) (p := CoveringSpaceMap C)
  : Open U -> Open (p ⁻¹ U).
  Proof.
    intro.
    pose (CoveringSpaceHomeomorphism C).
  Admitted.
End covering_space.

Section intersection_cover.
  Variable X : Type.
  Variable T : Topology X.
  Variables C C' : Cover X.

  Definition IntersectionCover : Cover X.
    exists (PairwiseIntersection C C').
    abstract (
        rewrite intersection_arbitrary_union_commute;
        repeat rewrite Covers;
        rewrite IntersectionAAA;
        reflexivity
      ).
  Defined.

  Lemma IntersectionCover_open : cover_open _ C -> cover_open _ C' -> cover_open _ IntersectionCover.
  Proof.
    intros; hnf in *; intros; hnf in * |- .
    destruct_head_hnf PairwiseIntersection.
    apply FiniteIntersectionOpen;
      match goal with
        | [ H : _ |- _ ] => apply H; assumption
      end.
  Qed.
End intersection_cover.
(*
Section p16.
  Variables X Y Z : Type.
  Variable Tx : Topology X.
  Variable Ty : Topology Y.
  Variable Tz : Topology Z.

  Variable f : X -> Y.
  Variable g : Y -> Z.
  Let gf := (fun x => g (f x)).

  Hypothesis YZ_is_covering_space : IsCoveringSpace _ _ g.
  Hypothesis XZ_is_covering_space : IsCoveringSpace _ _ gf.

  Local Notation "p ⁻¹" := (inverse_map p) (at level 1).

  Lemma XY_is_covering_space : IsCoveringSpace _ _ f.
  Proof.
    refine {|
        CoveringSpaceMap_continuous := (_ : continuous _ _ f);
        CoveringSpace_Cover := (_ : Cover Y);
        CoveringSpace_CoverOpen := _ (* cover_open T CoveringSpace_Cover;*);
        CoveringSpace_InverseImageSets := _ (* CoveringSpace_Cover ->
                                     Ensemble (Ensemble X');*);
        CoveringSpace_InverseImageSets_DisjointUnion := _ (*
    forall U : CoveringSpace_Cover,
    IsDisjointUnion (inverse_image p (proj1_sig U));*);
        CoveringSpaceHomeomorphism := _(* forall (U : CoveringSpace_Cover)
                                   (DU : CoveringSpace_InverseImageSets_DisjointUnion
                                           U),
                                 let H :=
                                   fun (x : X') (H0 : In X' (proj1_sig DU) x) =>
                                   disjoint_union_in
                                     (CoveringSpace_InverseImageSets_DisjointUnion
                                        U) DU x H0 in
                                 Homeomorphism
                                   (SubspaceTopology T'
                                      (fun x : X' => proj1_sig DU x))
                                   (SubspaceTopology T
                                      (fun y : X => proj1_sig U y))
                                   (restrict p (proj1_sig DU) (proj1_sig U) H)*)
      |}.
    intros Uy Uy_open; pose (image g Uy) as Uz.
    repeat match goal with
             | [ C : _ |- _ ] => unique_pose (CoveringSpaceMap_continuous C Uz)
           end.

    subst_body; unfold inverse_image, image in *; simpl in *.
    hnf in *.
    repeat match goal
                   destruct YZ_is_covering_space, XZ_is_covering_space.
End p16.

Section p3.
  Variables X X' : Type.
  Variable T : Topology X.
  Variable T' : Topology X'.

  Variable p : CoveringSpace T T'.

  Let p_continuous :=  CoveringSpaceMap_continuous p.

  Local Notation "p⁻¹" := (inverse_map p) (at level 0).

  Hypothesis all_finite : forall x, Finite _ ((inverse_map p) x).

  Hypothesis all_nonempty : forall x, Inhabited _ (p⁻¹ x).

  Hypothesis eq_dec_X : forall x y : X, {x = y} + {x <> y}.
  Hypothesis eq_dec_X' : forall x y : X', {x = y} + {x <> y}.

  Lemma p3h_only_if : compact T /\ hausdorff T -> hausdorff T'.
  Proof.
    intro H; destruct H as [ T_compact T_hausdorff ].
    move T_compact at top.
    hnf in *.
    intros x y x_ne_y.
    specialize (T_hausdorff (p x) (p y)).
    destruct (eq_dec_X (p x) (p y)) as [ px_py_eq | px_py_neq ].
    - clear T_hausdorff.
      pose (CoveringSpace_InverseImageSets_DisjointUnion p) as DU.
      pose (Covers (CoveringSpace_Cover p)) as C.
      fg_equal_in C.
      specialize (C (p x)).
      assert (U_contains_px : ArbitraryUnion p (p x)) by (rewrite C; constructor).
      assert (In _ (inverse_map p (p x)) x) by reflexivity.
      assert (In _ (inverse_map p (p x)) y) by (rewrite px_py_eq; reflexivity).
      destruct U_contains_px as [ U px U_in_cover U_contains_px ].
      specialize (DU (exist _ U U_in_cover)).
      admit.
    - specialize (T_hausdorff px_py_neq).
      destruct T_hausdorff as [ Upx [ Upy H ] ].
      destruct_hypotheses.
      exists (inverse_image p Upx); exists (inverse_image p Upy);
      repeat split;
      try match goal with
            | [ H : _ |- _ ] => solve [ apply H; trivial ]
          end;
      destruct_head Disjoint.
      intro x0; intro; destruct_head_hnf Intersection;
      repeat match goal with
               | [ H : _ |- _ ] => specialize (H (p x0));
                                  match type of H with
                                    | ~?X => cut X; [
                                              let H' := fresh in intro H'; specialize (H H'); assumption
                                            | ]
                                  end
             end.
      hnf in *; constructor; hnf; assumption.
  Qed.

  intro x0.

  pose (p x0) as px0; cut (In _ (Intersection _ Upx Upy) px0);
  [ let H := fresh in intro H; destruct_head Disjoint; specialize_all_ways; exfalso; assumption | subst_body ].
  constructor.
  split; try match goal with
               | [ H : _ |- _ ] => solve [ apply H; trivial ]
             end.
  Print ArbitraryUnion.
  destruct U_contains_px as [ U px U_in_cover U_contains_px ].
  Print Full_set.
  apply (fg_equal (p x)) in C.
  unfold Full_set in *.
  Print Cover.
  Print CoveringSpace.
  pose (inverse_map p x) as x'_0; pose (inverse_map p y) as y'_0.

(*
  Lemma p3_if : compact T /\ hausdorff T -> compact T' /\ hausdorff T'.
  Proof.
    intro H; destruct H as [ T_compact T_hausdorff ]; split.
    - hnf in *.
      intro X'_cover.
      intro X'_cover_open.
      clear T_hausdorff.
      hnf in X'_cover_open.
      pose ((fun U => CoverSets X'_cover (inverse_image p U)) : Ensemble _) as X_cover_sets.
      let T0 := fresh in evar (T0 : Type); evar (X_cover_is_cover : T0); subst T0;
                         pose {| CoverSets := X_cover_sets; Covers := X_cover_is_cover |} as X_cover_0.
      pose (IntersectionCover (CoveringSpace_Cover p) X_cover_0) as X_cover.
      assert (X_cover_is_open : cover_open _ X_cover); [ apply IntersectionCover_open | ];
      [ destruct p; simpl; assumption | | ].
      + hnf; intros U U_in_cover.
        subst_body; unfold Ensembles.In in *; simpl in *.
        specialize (X'_cover_open _ U_in_cover).
        pose proof (covering_space_open_to_open p (inverse_image p U)); simpl in *.

        Print CoveringSpace.
        pose proof (homemorphism_open_to_open p).
        Print Cover.
        eta_red.
        hnf in U_in_cover.
        pose (
        eapply X'_cover_open.
        pose (



      pose proof (T_compact X_cover) as X_finite_cover.
                         let t := type of X_cover_is_cover in assert t.
                         match type of
                         pose (
      refine (ex_intro _ ({| CoverSets := X_cover_
      Print Cover.
    clear T_hausdorff.
    intro X'_cover.
  Admitted.

  Lemma p3_only_if : compact T' /\ hausdorff T' -> compact T /\ hausdorff T.
  Proof.
    intro H; destruct H as [ T'_compact T'_hausdorff ]; split.
  Admitted. *)
End p3.

Section p8.

End p8.

*)
