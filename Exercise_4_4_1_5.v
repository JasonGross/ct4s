(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing ≄ %\ensuremath{\not\simeq}% #&#8772;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import FunctionalExtensionality JMeq EqdepFacts Relation_Definitions.
Require Import Schema SchemaMorphism Path.
Require Import Common Notations FEqualDep.

Set Implicit Arguments.

Generalizable All Variables.

(** ------------------------------------------------------------------------ *)

(** * Exercise 4.4.1.5 *)
Module Exercise_4_4_1_5.
  (** ** Problem *)
  (**
<<
              g
           a ---> b
     C :=   \     |
            i \   | h
                ↘ ↓
                  c

>>

      Consider the schema [[2]] and the schema [C] pictured above,
      except where this time we do not impose any path equivalence
      declarations on [C], so [[g, h] ≄ [i]] in our current version of
      [C].

      (a) How many schema morphisms are there [[2] -> C] that send
          [0] to [a]?

      (b) How many schema morphisms are there [C -> [2]] that send [a]
          to [0]? *)

  Inductive C_Vertex := a | b | c.
  Inductive C_Edge : C_Vertex -> C_Vertex -> Set :=
  | g : C_Edge a b
  | h : C_Edge b c
  | i : C_Edge a c.
  Definition C : Schema.
    refine (@Build_Schema C_Vertex
                          C_Edge
                          (fun _ _ => @eq _)
                          _
                          _
                          _);
    abstract (repeat (intro || split); subst; reflexivity).
  Defined.
  Inductive LinearOrder2Schema_Vertex := Zero | One | Two.
  Inductive LinearOrder2Schema_Edge
  : LinearOrder2Schema_Vertex -> LinearOrder2Schema_Vertex -> Set :=
  | Zero_One : LinearOrder2Schema_Edge Zero One
  | One_Two : LinearOrder2Schema_Edge One Two.
  Definition LinearOrder2Schema : Schema.
    refine (@Build_Schema LinearOrder2Schema_Vertex
                          LinearOrder2Schema_Edge
                          (fun _ _ => @eq _)
                          _
                          _
                          _);
    abstract (repeat (intro || split); subst; reflexivity).
  Defined.
  Definition SchemaMorphism_template
             (VO : LinearOrder2Schema -> C)
             (PO : forall s d,
                     SEdge LinearOrder2Schema s d
                     -> path (SEdge C) (VO s) (VO d))
  : SchemaMorphism LinearOrder2Schema C.
    refine (@Build_SchemaMorphism LinearOrder2Schema C
                                  VO
                                  PO
                                  _).
    abstract (intros; hnf in *; subst; reflexivity).
  Defined.

  Definition SchemaMorphism_template'
             (VO : C -> LinearOrder2Schema)
             (PO : forall s d,
                     SEdge C s d
                     -> path (SEdge LinearOrder2Schema) (VO s) (VO d))
  : SchemaMorphism C LinearOrder2Schema.
    refine (@Build_SchemaMorphism C LinearOrder2Schema
                                  VO
                                  PO
                                  _).
    abstract (intros; hnf in *; subst; reflexivity).
  Defined.
  Local Ltac paths_unique_t :=
    intros; compute;
    try apply JMeq_eq;
    repeat match goal with
             | [ |- ?a = ?b \/ ?c = ?d ] =>
               cut (a == b \/ c == d);
                 [
                   intros [? | ?]; solve [ left; apply JMeq_eq; assumption
                                         | right; apply JMeq_eq; assumption ]
                 | ]
             | [ |- AddEdge _ _ == NoEdges ] => exfalso
             | [ H : _ |- _ ] => inversion H; subst;
                                 match goal with
                                   | [ H : _ |- _ ] => solve [ inversion H ]
                                 end
             | [ H : C_Edge _ _ |- _ ] => destruct H
             | [ H : LinearOrder2Schema_Edge _ _ |- _ ] => destruct H
             | _ => subst; apply eq_JMeq; apply f_equal2; try reflexivity; []; apply JMeq_eq
             | _ => subst; right; apply eq_JMeq; apply f_equal2; try reflexivity; []; apply JMeq_eq
             | _ => subst; left; apply eq_JMeq; apply f_equal2; try reflexivity; []; apply JMeq_eq
             | [ p : path ?E ?x ?y |- _ ]
               => let x' := fresh in
                  let y' := fresh in
                  pose x as x';
                    pose y as y';
                    assert (x = x') by reflexivity;
                    assert (y = y') by reflexivity;
                    change (path E x y) with (path E x' y') in p;
                    repeat match goal with
                             | [ |- context[@JMeq (path E x y) p ?T ?p'] ] =>
                               progress (change (@JMeq (path E x y) p T p')
                                         with (@JMeq (path E x' y') p T p'))
                           end;
                    clearbody x' y';
                    destruct p;
                    try (subst; reflexivity)
           end.

  Local Ltac mk_f_x f x fx :=
    let H := fresh in
    pose (f x) as fx; assert (f x = fx) by reflexivity; clearbody fx.
  Local Ltac t_unique_solve :=
    solve [
        apply SchemaMorphism_Eq; simpl;
        intros;
        destruct_head_hnf LinearOrder2Schema_Edge;
        destruct_head_hnf C_Edge;
        try assumption;
        match goal with
          | [ H : _ |- _ ] => rewrite H; reflexivity
        end
      ].
  Local Ltac t_unique_solve_recr :=
    t_unique_solve || (left; t_unique_solve_recr) || (right; t_unique_solve_recr).

  Section part_a.
    Definition a_OnVertices0 : LinearOrder2Schema -> C :=
      fun v => match v with Zero => a | One => a | Two => a end.
    Definition a_OnVertices1 : LinearOrder2Schema -> C :=
      fun v => match v with Zero => a | One => a | Two => b end.
    Definition a_OnVertices2 : LinearOrder2Schema -> C :=
      fun v => match v with Zero => a | One => a | Two => c end.
    Definition a_OnVertices3 : LinearOrder2Schema -> C :=
      fun v => match v with Zero => a | One => b | Two => a end.
    Definition a_OnVertices4 : LinearOrder2Schema -> C :=
      fun v => match v with Zero => a | One => b | Two => b end.
    Definition a_OnVertices5 : LinearOrder2Schema -> C :=
      fun v => match v with Zero => a | One => b | Two => c end.
    Definition a_OnVertices6 : LinearOrder2Schema -> C :=
      fun v => match v with Zero => a | One => c | Two => a end.
    Definition a_OnVertices7 : LinearOrder2Schema -> C :=
      fun v => match v with Zero => a | One => c | Two => b end.
    Definition a_OnVertices8 : LinearOrder2Schema -> C :=
      fun v => match v with Zero => a | One => c | Two => c end.
    Definition a_path_a_a_0 : path C_Edge a a := NoEdges.
    Definition a_path_b_b_0 : path C_Edge b b := NoEdges.
    Definition a_path_c_c_0 : path C_Edge c c := NoEdges.
    Definition a_path_a_b_0 : path C_Edge a b := AddEdge NoEdges g.
    Definition a_path_b_c_0 : path C_Edge b c := AddEdge NoEdges h.
    Definition a_path_a_c_0 : path C_Edge a c := AddEdge NoEdges i.
    Definition a_path_a_c_1 : path C_Edge a c := AddEdge (AddEdge NoEdges g) h.
    Definition Exercise_4_4_1_5_a_SchemaMorphism0 : SchemaMorphism LinearOrder2Schema C
      := SchemaMorphism_template a_OnVertices0 (fun _ _ e => match e with Zero_One => a_path_a_a_0 | One_Two => a_path_a_a_0 end).
    Definition Exercise_4_4_1_5_a_SchemaMorphism1 : SchemaMorphism LinearOrder2Schema C
      := SchemaMorphism_template a_OnVertices1 (fun _ _ e => match e with Zero_One => a_path_a_a_0 | One_Two => a_path_a_b_0 end).
    Definition Exercise_4_4_1_5_a_SchemaMorphism2 : SchemaMorphism LinearOrder2Schema C
      := SchemaMorphism_template a_OnVertices2 (fun _ _ e => match e with Zero_One => a_path_a_a_0 | One_Two => a_path_a_c_0 end).
    Definition Exercise_4_4_1_5_a_SchemaMorphism3 : SchemaMorphism LinearOrder2Schema C
      := SchemaMorphism_template a_OnVertices2 (fun _ _ e => match e with Zero_One => a_path_a_a_0 | One_Two => a_path_a_c_1 end).
    Definition Exercise_4_4_1_5_a_SchemaMorphism4 : SchemaMorphism LinearOrder2Schema C
      := SchemaMorphism_template a_OnVertices4 (fun _ _ e => match e with Zero_One => a_path_a_b_0 | One_Two => a_path_b_b_0 end).
    Definition Exercise_4_4_1_5_a_SchemaMorphism5 : SchemaMorphism LinearOrder2Schema C
      := SchemaMorphism_template a_OnVertices5 (fun _ _ e => match e with Zero_One => a_path_a_b_0 | One_Two => a_path_b_c_0 end).
    Definition Exercise_4_4_1_5_a_SchemaMorphism6 : SchemaMorphism LinearOrder2Schema C
      := SchemaMorphism_template a_OnVertices8 (fun _ _ e => match e with Zero_One => a_path_a_c_0 | One_Two => a_path_c_c_0 end).
    Definition Exercise_4_4_1_5_a_SchemaMorphism7 : SchemaMorphism LinearOrder2Schema C
      := SchemaMorphism_template a_OnVertices8 (fun _ _ e => match e with Zero_One => a_path_a_c_1 | One_Two => a_path_c_c_0 end).

    Lemma a_path_a_a_only : forall x : path _ a a, x = a_path_a_a_0. paths_unique_t. Qed.
    Lemma a_path_b_b_only : forall x : path _ b b, x = a_path_b_b_0. paths_unique_t. Qed.
    Lemma a_path_c_c_only : forall x : path _ c c, x = a_path_c_c_0. paths_unique_t. Qed.
    Lemma a_path_a_b_only : forall x : path _ a b, x = a_path_a_b_0. paths_unique_t. Qed.
    Lemma a_path_b_c_only : forall x : path _ b c, x = a_path_b_c_0. paths_unique_t. Qed.
    Lemma a_path_a_c_only : forall x : path _ a c, x = a_path_a_c_0 \/ x = a_path_a_c_1. paths_unique_t. Qed.
    Lemma a_path_b_a_only : path C_Edge b a -> False. paths_unique_t. Qed.
    Lemma a_path_c_b_only : path C_Edge c b -> False. paths_unique_t. Qed.
    Lemma a_path_c_a_only : path C_Edge c a -> False. paths_unique_t. Qed.

    Lemma a_OnVertices_only : forall f : LinearOrder2Schema -> C,
                                f Zero = a
                                -> f = a_OnVertices0
                                   \/ f = a_OnVertices1
                                   \/ f = a_OnVertices2
                                   \/ f = a_OnVertices3
                                   \/ f = a_OnVertices4
                                   \/ f = a_OnVertices5
                                   \/ f = a_OnVertices6
                                   \/ f = a_OnVertices7
                                   \/ f = a_OnVertices8.
      intros f H.
      mk_f_x f Zero fZero.
      mk_f_x f One fOne.
      mk_f_x f Two fTwo.
      let H := fresh in
      assert (H : f = fun v => match v with Zero => fZero | One => fOne | Two => fTwo end)
        by (apply functional_extensionality_dep; intros []; intuition);
        repeat rewrite H; clear H;
        subst fZero;
        match goal with
          | [ H : f Zero = _ |- _ ] => rewrite H
        end;
        clear;
        compute;
        destruct fOne, fTwo;
        intuition.
    Qed.
    Lemma a_schema_morphism_all_template
    : forall F : SchemaMorphism LinearOrder2Schema C,
        F = SchemaMorphism_template (VertexOf F) (PathOf F).
      intros.
      apply SchemaMorphism_Eq; simpl;
      reflexivity.
    Qed.

    Lemma a_schema_morphsim_on_paths
          VO
          (PO : forall s d : LinearOrder2Schema,
                  SEdge LinearOrder2Schema s d → path (SEdge C) (VO s) (VO d))
    : PO = (fun _ _ e => match e with Zero_One => PO _ _ Zero_One | One_Two => PO _ _ One_Two end).
      repeat (apply functional_extensionality_dep; intro).
      match goal with | [ |- context[match ?E with _ => _ end] ] => destruct E end;
        reflexivity.
    Qed.
    Local Ltac pose_path_uniqueness_proof p :=
      ((pose proof (a_path_a_a_only p))
         || (pose proof (a_path_a_b_only p))
         || (pose proof (a_path_a_c_only p))
         || (pose proof (a_path_b_a_only p))
         || (pose proof (a_path_b_b_only p))
         || (pose proof (a_path_b_c_only p))
         || (pose proof (a_path_c_a_only p))
         || (pose proof (a_path_c_b_only p))
         || (pose proof (a_path_c_c_only p))).
    Theorem a_schema_morphism_all
    : forall F : SchemaMorphism LinearOrder2Schema C,
        F Zero = a
        -> F = Exercise_4_4_1_5_a_SchemaMorphism0
           \/ F = Exercise_4_4_1_5_a_SchemaMorphism1
           \/ F = Exercise_4_4_1_5_a_SchemaMorphism2
           \/ F = Exercise_4_4_1_5_a_SchemaMorphism3
           \/ F = Exercise_4_4_1_5_a_SchemaMorphism4
           \/ F = Exercise_4_4_1_5_a_SchemaMorphism5
           \/ F = Exercise_4_4_1_5_a_SchemaMorphism6
           \/ F = Exercise_4_4_1_5_a_SchemaMorphism7.
      intros F H.
      rewrite (a_schema_morphism_all_template F).
      rewrite (@a_schema_morphsim_on_paths _ (PathOf F)).
      destruct (a_OnVertices_only F H); clear H;
      destruct_head_hnf @or;
      match goal with
        | [ H : VertexOf ?F = ?G |- _ ]
          => let p01 := fresh in
             let H01 := fresh in
             let p12 := fresh in
             let H12 := fresh in
             let f0 := fresh in
             let f1 := fresh in
             let f2 := fresh in
             let fH0 := fresh in
             let fH1 := fresh in
             let fH2 := fresh in
             pose (VertexOf F Zero) as f0;
               pose (VertexOf F One) as f1;
               pose (VertexOf F Two) as f2;
               assert (fH0 : VertexOf F Zero = f0) by reflexivity;
               assert (fH1 : VertexOf F One = f1) by reflexivity;
               assert (fH2 : VertexOf F Two = f2) by reflexivity;
               pose (PathOf F _ _ Zero_One : path _ f0 f1) as p01;
               pose (PathOf F _ _ One_Two : path _ f1 f2) as p12;
               assert (H01 : PathOf F _ _ Zero_One == p01) by reflexivity;
               assert (H12 : PathOf F _ _ One_Two == p12) by reflexivity;
               clearbody p01 p12 f0 f1 f2;
               rewrite H in fH0, fH1, fH2;
               subst; simpl in *;
               pose_path_uniqueness_proof p01;
               pose_path_uniqueness_proof p12
      end;
      destruct_head_hnf False;
      destruct_head_hnf @or;
      subst;
      t_unique_solve_recr.
    Qed.
  End part_a.

  Section part_b.
    Definition b_OnVertices0 : C -> LinearOrder2Schema :=
      fun v => match v with a => Zero | b => Zero | c => Zero end.
    Definition b_OnVertices1 : C -> LinearOrder2Schema :=
      fun v => match v with a => Zero | b => Zero | c => One  end.
    Definition b_OnVertices2 : C -> LinearOrder2Schema :=
      fun v => match v with a => Zero | b => Zero | c => Two  end.
    Definition b_OnVertices3 : C -> LinearOrder2Schema :=
      fun v => match v with a => Zero | b => One  | c => Zero end.
    Definition b_OnVertices4 : C -> LinearOrder2Schema :=
      fun v => match v with a => Zero | b => One  | c => One  end.
    Definition b_OnVertices5 : C -> LinearOrder2Schema :=
      fun v => match v with a => Zero | b => One  | c => Two  end.
    Definition b_OnVertices6 : C -> LinearOrder2Schema :=
      fun v => match v with a => Zero | b => Two  | c => Zero end.
    Definition b_OnVertices7 : C -> LinearOrder2Schema :=
      fun v => match v with a => Zero | b => Two  | c => One  end.
    Definition b_OnVertices8 : C -> LinearOrder2Schema :=
      fun v => match v with a => Zero | b => Two  | c => Two  end.
    Definition b_path_0_0 : path LinearOrder2Schema_Edge Zero Zero := NoEdges.
    Definition b_path_1_1 : path LinearOrder2Schema_Edge One One := NoEdges.
    Definition b_path_2_2 : path LinearOrder2Schema_Edge Two Two := NoEdges.
    Definition b_path_0_1 : path LinearOrder2Schema_Edge Zero One := AddEdge NoEdges Zero_One.
    Definition b_path_1_2 : path LinearOrder2Schema_Edge One Two := AddEdge NoEdges One_Two.
    Definition b_path_0_2 : path LinearOrder2Schema_Edge Zero Two := AddEdge (AddEdge NoEdges Zero_One) One_Two.
    Definition Exercise_4_4_1_5_b_SchemaMorphism0 : SchemaMorphism C LinearOrder2Schema
      := SchemaMorphism_template' b_OnVertices0 (fun _ _ e => match e with g => b_path_0_0 | h => b_path_0_0 | i => b_path_0_0 end).
    Definition Exercise_4_4_1_5_b_SchemaMorphism1 : SchemaMorphism C LinearOrder2Schema
      := SchemaMorphism_template' b_OnVertices1 (fun _ _ e => match e with g => b_path_0_0 | h => b_path_0_1 | i => b_path_0_1 end).
    Definition Exercise_4_4_1_5_b_SchemaMorphism2 : SchemaMorphism C LinearOrder2Schema
      := SchemaMorphism_template' b_OnVertices2 (fun _ _ e => match e with g => b_path_0_0 | h => b_path_0_2 | i => b_path_0_2 end).
    Definition Exercise_4_4_1_5_b_SchemaMorphism3 : SchemaMorphism C LinearOrder2Schema
      := SchemaMorphism_template' b_OnVertices4 (fun _ _ e => match e with g => b_path_0_1 | h => b_path_1_1 | i => b_path_0_1 end).
    Definition Exercise_4_4_1_5_b_SchemaMorphism4 : SchemaMorphism C LinearOrder2Schema
      := SchemaMorphism_template' b_OnVertices5 (fun _ _ e => match e with g => b_path_0_1 | h => b_path_1_2 | i => b_path_0_2 end).
    Definition Exercise_4_4_1_5_b_SchemaMorphism5 : SchemaMorphism C LinearOrder2Schema
      := SchemaMorphism_template' b_OnVertices8 (fun _ _ e => match e with g => b_path_0_2 | h => b_path_2_2 | i => b_path_0_2 end).


    Lemma b_path_0_0_only : forall x : path _ Zero Zero, x = b_path_0_0. paths_unique_t. Qed.
    Lemma b_path_1_1_only : forall x : path _ One One, x = b_path_1_1. paths_unique_t. Qed.
    Lemma b_path_2_2_only : forall x : path _ Two Two, x = b_path_2_2. paths_unique_t. Qed.
    Lemma b_path_0_1_only : forall x : path _ Zero One, x = b_path_0_1. paths_unique_t. Qed.
    Lemma b_path_1_2_only : forall x : path _ One Two, x = b_path_1_2. paths_unique_t. Qed.
    Lemma b_path_0_2_only : forall x : path _ Zero Two, x = b_path_0_2. paths_unique_t. Qed.
    Lemma b_path_1_0_only : path LinearOrder2Schema_Edge One Zero -> False. paths_unique_t. Qed.
    Lemma b_path_2_1_only : path LinearOrder2Schema_Edge Two One -> False. paths_unique_t. Qed.
    Lemma b_path_2_0_only : path LinearOrder2Schema_Edge Two Zero -> False. paths_unique_t. Qed.

    Lemma b_OnVertices_only : forall f : C -> LinearOrder2Schema,
                                f a = Zero
                                -> f = b_OnVertices0
                                   \/ f = b_OnVertices1
                                   \/ f = b_OnVertices2
                                   \/ f = b_OnVertices3
                                   \/ f = b_OnVertices4
                                   \/ f = b_OnVertices5
                                   \/ f = b_OnVertices6
                                   \/ f = b_OnVertices7
                                   \/ f = b_OnVertices8.
      intros f H.
      mk_f_x f a fa.
      mk_f_x f b fb.
      mk_f_x f c fc.
      let H := fresh in
      assert (H : f = fun v => match v with a => fa | b => fb | c => fc end)
        by (apply functional_extensionality_dep; intros []; intuition);
        repeat rewrite H; clear H;
        subst fa;
        match goal with
          | [ H : f a = _ |- _ ] => rewrite H
        end;
        clear;
        compute;
        destruct fb, fc;
        intuition.
    Qed.
    Lemma b_schema_morphism_all_template'
    : forall F : SchemaMorphism C LinearOrder2Schema,
        F = SchemaMorphism_template' (VertexOf F) (PathOf F).
      intros.
      apply SchemaMorphism_Eq; simpl;
      reflexivity.
    Qed.

    Lemma b_schema_morphsim_on_paths
          VO
          (PO : forall s d : C,
                  SEdge C s d → path (SEdge LinearOrder2Schema) (VO s) (VO d))
    : PO = (fun _ _ e => match e with g => PO _ _ g | h => PO _ _ h | i => PO _ _ i end).
      repeat (apply functional_extensionality_dep; intro).
      match goal with | [ |- context[match ?E with _ => _ end] ] => destruct E end;
        reflexivity.
    Qed.
    Local Ltac pose_path_uniqueness_proof p :=
      ((pose proof (b_path_0_0_only p))
         || (pose proof (b_path_0_1_only p))
         || (pose proof (b_path_0_2_only p))
         || (pose proof (b_path_1_0_only p))
         || (pose proof (b_path_1_1_only p))
         || (pose proof (b_path_1_2_only p))
         || (pose proof (b_path_2_0_only p))
         || (pose proof (b_path_2_1_only p))
         || (pose proof (b_path_2_2_only p))).
    Theorem b_schema_morphism_all
    : forall F : SchemaMorphism C LinearOrder2Schema,
        F a = Zero
        -> F = Exercise_4_4_1_5_b_SchemaMorphism0
           \/ F = Exercise_4_4_1_5_b_SchemaMorphism1
           \/ F = Exercise_4_4_1_5_b_SchemaMorphism2
           \/ F = Exercise_4_4_1_5_b_SchemaMorphism3
           \/ F = Exercise_4_4_1_5_b_SchemaMorphism4
           \/ F = Exercise_4_4_1_5_b_SchemaMorphism5.
      intros F H.
      rewrite (b_schema_morphism_all_template' F).
      rewrite (@b_schema_morphsim_on_paths _ (PathOf F)).
      destruct (b_OnVertices_only F H); clear H;
      destruct_head_hnf @or;
      match goal with
        | [ H : VertexOf ?F = ?G |- _ ]
          => let pab := fresh in
             let Hab := fresh in
             let pbc := fresh in
             let Hbc := fresh in
             let pac := fresh in
             let Hac := fresh in
             let fa := fresh in
             let fb := fresh in
             let fc := fresh in
             let fHa := fresh in
             let fHb := fresh in
             let fHc := fresh in
             pose (VertexOf F a) as fa;
               pose (VertexOf F b) as fb;
               pose (VertexOf F c) as fc;
               assert (fHa : VertexOf F a = fa) by reflexivity;
               assert (fHb : VertexOf F b = fb) by reflexivity;
               assert (fHc : VertexOf F c = fc) by reflexivity;
               pose (PathOf F _ _ g : path _ fa fb) as pab;
               pose (PathOf F _ _ h : path _ fb fc) as pbc;
               pose (PathOf F _ _ i : path _ fa fc) as pac;
               assert (Hab : PathOf F _ _ g == pab) by reflexivity;
               assert (Hbc : PathOf F _ _ h == pbc) by reflexivity;
               assert (Hac : PathOf F _ _ i == pac) by reflexivity;
               clearbody pab pbc pac fa fb fc;
               rewrite H in fHa, fHb, fHc;
               subst; simpl in *;
               pose_path_uniqueness_proof pab;
               pose_path_uniqueness_proof pbc;
               pose_path_uniqueness_proof pac
      end;
      destruct_head_hnf False;
      destruct_head_hnf @or;
      subst;
      t_unique_solve_recr.
    Qed.
  End part_b.
End Exercise_4_4_1_5.

(** ------------------------------------------------------------------------ *)
