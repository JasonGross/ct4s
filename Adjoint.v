(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing ≄ %\ensuremath{\not\simeq}% #&#8772;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
(** printing ℙ %\ensuremath{\mathbb{P}}% #&#x2119;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ↦ %\ensuremath{\mapsto}% #&#21A6# *)
(** printing ↪ %\ensuremath{\hookrightarrow}% #&rarrhk;# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ▻ %\ensuremath{\triangleright}% #&#x25BB;# *)
(** printing ◅ %\ensuremath{\triangleleft}% #&#x25C5;# *)
(** printing ⊣ %\ensuremath{\dashv}% #&#x22a3;# *)
(** printing -| %\ensuremath{\dashv}% #&#x22a3;# *)
(** printing ⊥ %\ensuremath{\bot}% #&#x22a5;# *)
(** printing ⊢ %\ensuremath{\vdash}% #&#x22a2;# *)
(** printing |- %\ensuremath{\vdash}% #&#x22a2;# *)
(** printing ⊤ %\ensuremath{\top}% #&#x22a4;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ≰ %\ensuremath{\not\le}% #&#x2270;# *)
(** printing ≱ %\ensuremath{\not\ge}% #&#x2271;# *)
(** printing ≼ %\ensuremath{\preceq}% #&#x227c;# *)
(** printing ≽ %\ensuremath{\succeq}% #&#x227d;# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import FunctionalExtensionality.
Require Export Category Functor NaturalTransformation NaturalEquivalence AdjointUnit.
Require Import Common Notations Hom ProductCategory ProductCategory Duals.

Set Implicit Arguments.

Generalizable All Variables.

Section Adjunction.
  Local Open Scope morphism_scope.

  Context `{C : @Category objC}.
  Context `{D : @Category objD}.
  Variable F : Functor C D.
  Variable G : Functor D C.

  Let COp := OppositeCategory C.
  Let DOp := OppositeCategory D.
  Let FOp := OppositeFunctor F.

  Let HomCPreFunctor : Functor (COp * D) (COp * C) := ((IdentityFunctor _ o fst_Functor) * (G o snd_Functor))%functor.
  Let HomDPreFunctor : Functor (COp * D) (DOp * D) := ((FOp o fst_Functor) * (IdentityFunctor _ o snd_Functor))%functor.

  Record Adjunction :=
    {
      AMateOf :> NaturalIsomorphism
              (ComposeFunctors (HomFunctor D) HomDPreFunctor)
              (ComposeFunctors (HomFunctor C) HomCPreFunctor)
    }.

  (**
     Quoting the 18.705 Lecture Notes:

     Let [C] and [D] be categories, [F : C -> D] and [G : D -> C]
     functors. We call [(F, G)] an adjoint pair, [F] the left adjoint
     of [G], and [G] the right adjoint of [F] if, for each object [A :
     C] and object [A' : D], there is a natural bijection

     [Hom_D (F A) A' ≅ Hom_C A (G A')]

     Here natural means that maps [B -> A] and [A' -> B'] induce a
     commutative diagram:

<<
       Hom_D (F A) A' ~= Hom_C A (G A')
             |                  |
             |                  |
             |                  |
             |                  |
             V                  V
       Hom_D (F B) B' ~= Hom_C B (G B')
>>

   *)
  Record HomAdjunction :=
    {
      AComponentsOf :> forall A A', CategoryOfTypes.(Morphism) (HomFunctor D (F A, A')) (HomFunctor C (A, G A'));
      AIsomorphism : forall A A', IsomorphismOf_sig _ (@AComponentsOf A A');
      ACommutes : forall (A : C) (A' : D) (B : C) (B' : D) (m : C.(Morphism) B A) (m' : D.(Morphism) A' B'),
                    (@AComponentsOf B B') o (MorphismOf (HomFunctor D) (s := (F A, A')) (d := (F B, B')) (F.(MorphismOf) m, m')) =
                    (MorphismOf (HomFunctor C) (s := (A, G A')) (d := (B, G B')) (m, G.(MorphismOf) m')) o (@AComponentsOf A A')
    }.

  Lemma ACommutes_Inverse (T : HomAdjunction) :
    forall A A' B B' (m : C.(Morphism) B A) (m' : D.(Morphism) A' B'),
      (MorphismOf (HomFunctor D) (s := (F A, A')) (d := (F B, B')) (F.(MorphismOf) m, m')) o (proj1_sig (T.(AIsomorphism) A A')) =
      (proj1_sig (T.(AIsomorphism) B B')) o (MorphismOf (HomFunctor C) (s := (A, G A')) (d := (B, G B')) (m, G.(MorphismOf) m')).
    Local Opaque CategoryOfTypes HomFunctor.
    intros.
    Local Ltac intro_T T A A' :=
      let t := constr:(T.(AIsomorphism) A A') in
      let H := fresh in assert (H := t);
                       let H0 := fresh in let H1 := fresh in
                                          assert (H0 := proj2_sig t);
                                            assert (H1 := proj3_sig t).
    intro_T T B B'.
    intro_T T A A'.
    (* XXX Figure out how to remove this *)
    Local Opaque AIsomorphism.
    simpl in *.
    match goal with
      | [ H : Compose ?x (?T ?A ?A') = Identity _ |- Compose _ ?x = _ ]
        => eapply (@iso_is_epi _ _ _ _ (T A A')); [
            exists x; hnf; eauto
                 |
                 repeat rewrite Associativity; find_composition_to_identity (* slow, but I don't have a better way to do it *); rewrite RightIdentity
          ]
    end.
    match goal with
      | [ H : Compose (?T ?A ?A') ?x = Identity _ |- _ = Compose ?x _ ]
        => eapply (@iso_is_mono _ _ _ _ (T A A')); [
            exists x; hnf; eauto
                 |
                 repeat rewrite <- Associativity; find_composition_to_identity; rewrite LeftIdentity
          ]
    end.
    (*    pre_compose_to_identity; post_compose_to_identity; *) (* too slow *)
    apply ACommutes.
  Defined.
End Adjunction.

Arguments AComponentsOf {objC C objD D} [F G] T A A' _ : rename, simpl nomatch.
Arguments AIsomorphism {objC C objD D} [F G] T A A' : rename, simpl nomatch.

Section AdjunctionEquivalences.
  Context `(C : @Category objC).
  Context `(D : @Category objD).
  Variable F : Functor C D.
  Variable G : Functor D C.

  Definition HomAdjunction2Adjunction_AMateOf (A : HomAdjunction F G) :
    NaturalTransformation
      (ComposeFunctors (HomFunctor D)
                       ((OppositeFunctor F o fst_Functor) * (IdentityFunctor D o snd_Functor)))
      (ComposeFunctors (HomFunctor C)
                       ((IdentityFunctor (OppositeCategory C) o fst_Functor) * (G o snd_Functor))).
    match goal with
      | [ |- NaturalTransformation ?F ?G ] =>
        refine (Build_NaturalTransformation F G
                                            (fun cd : objC * objD => A.(AComponentsOf) (fst cd) (snd cd))
                                            _
               )
    end.
    abstract (
        simpl in *; intros;
        destruct A;
        simpl in *;
          destruct_hypotheses;
        unfold Morphism, Object in *;
          simpl in *;
          trivial
      ).
  Defined.

  Definition HomAdjunction2Adjunction (A : HomAdjunction F G) : Adjunction F G.
    constructor.
    exists (HomAdjunction2Adjunction_AMateOf A).
    intro x; hnf; simpl.
    exact (AIsomorphism A (fst x) (snd x)).
  Defined.

  Definition Adjunction2HomAdjunction (A : Adjunction F G) : HomAdjunction F G.
    hnf; simpl.
    exists (fun c d => ComponentsOf A (c, d));
      simpl;
      [ exact (fun A0 A' => A.(NaturalIsomorphism_Isomorphism) (A0, A')) |
        exact (fun A0 A' B B' m m' => A.(Commutes) (A0, A') (B, B') (m, m')) ].
  Defined.

  Lemma adjunction_naturality_pre (A : HomAdjunction F G) c d d' (f : D.(Morphism) (F c) d) (g : D.(Morphism) d d') :
    Compose (C := C) (G.(MorphismOf) g) (A.(AComponentsOf) _ _ f) =
    A.(AComponentsOf) _ _ (Compose g f).
    assert (H := fg_equal (A.(ACommutes) _ _ _ _ (Identity c) g) f).
    simpl in *; autorewrite with category in *.
    auto with category.
  Qed.

  Lemma adjunction_naturality'_pre (A : HomAdjunction F G) c' c d (f : C.(Morphism) c (G d)) (h : C.(Morphism) c' c) :
    Compose (C := D) (proj1_sig (A.(AIsomorphism) _ _) f) (F.(MorphismOf) h) =
    proj1_sig (A.(AIsomorphism) _ _) (Compose f h).
    assert (H := fg_equal (ACommutes_Inverse A _ _ _ _ h (Identity d)) f).
    simpl in *; autorewrite with category in *.
    auto with category.
  Qed.

  Section typeof.
    Let typeof (A : Type) (a : A) := A.
    Let adjunction_naturalityT := Eval simpl in typeof adjunction_naturality_pre.
    Let adjunction_naturality'T := Eval simpl in typeof adjunction_naturality'_pre.
    Let adjunction_naturalityT' := Eval cbv beta iota delta [typeof adjunction_naturalityT] zeta in adjunction_naturalityT.
    Let adjunction_naturality'T' := Eval cbv beta iota delta [typeof adjunction_naturality'T] zeta in adjunction_naturality'T.
    Definition adjunction_naturality : adjunction_naturalityT' := adjunction_naturality_pre.
    Definition adjunction_naturality' : adjunction_naturality'T' := adjunction_naturality'_pre.
  End typeof.

  (**
     Quoting from Awody's "Category Theory":

     Proposition 9.4. Given categories and functors,

     [F : C <-> D : G]

     the following conditions are equivalent:

     1. [F] is left adjoint to [G]; that is, there is a natural transformation

        [η : 1_C -> G ○ F]

        that has the UMP of the unit:

        For any [c : C], [d : D] and [f : c -> G d] there exists a
        unique [g : F c -> d] such that [f = G g ○ η c].

     2. For any [c : C] and [d : D] there is an isomorphism, [ϕ :
        Hom_D (F c, d) ~= Hom_C (c, G d)] that is natural in both [c]
        and [d].

     Moreover, the two conditions are related by the formulas

     [ϕ g = G g ○ η c]

     [η c = ϕ(1_{F c})]
   *)

  Definition UnitOf (A : HomAdjunction F G) : AdjunctionUnit F G.
    eexists (Build_NaturalTransformation (IdentityFunctor C) (ComposeFunctors G F)
                                         (fun c => A.(AComponentsOf) c (F c) (Identity _))
                                         _
            ).
    simpl.
    intros c d f.
    exists (proj1_sig (A.(AIsomorphism) c d) f).
    abstract (
        pose proof (proj2_sig (A.(AIsomorphism) c d));
        pose proof (proj3_sig (A.(AIsomorphism) c d));
        simpl in *; fg_equal;
        repeat split; intros; [ | t_with t' ];
        subst;
        repeat rewrite adjunction_naturality, RightIdentity;
        destruct A; simpl in *;
                    trivial
      ).
    Grab Existential Variables.
    abstract (
        intros s d m; simpl in *;
                      repeat rewrite adjunction_naturality, RightIdentity;
        let H := fresh in assert (H := fg_equal (A.(ACommutes) d (F d) s (F d) m (Identity _)) (Identity _));
        simpl in *;
          autorewrite with category in *;
          auto with category
      ).
  Defined.


  Definition CounitOf (A : HomAdjunction F G) : AdjunctionCounit F G.
    eexists (Build_NaturalTransformation (ComposeFunctors F G) (IdentityFunctor D)
                                         (fun d => proj1_sig (A.(AIsomorphism) (G d) d) (Identity _))
                                         _
            ).
    simpl.
    intros c d f.
    exists (A.(AComponentsOf) c d f).
    abstract (
        split; intros; [ | t_with t' ];
        subst;
        repeat rewrite (adjunction_naturality' A), LeftIdentity;
        simpl in *;
          intro_proj2_sig_from_goal;
        destruct_hypotheses; fg_equal; auto with category
      ).
    Grab Existential Variables.
    abstract (
        intros s d m; simpl in *;
                      rewrite (adjunction_naturality' A);
        let H := fresh in assert (H := fg_equal (ACommutes_Inverse A (G s) s (G s) d (Identity (G s)) m) (Identity _));
        simpl in *;
          autorewrite with category in *;
          auto with category
      ).
  Defined.

  (** Quoting Wikipedia on Adjoint Functors:

      The naturality of [Φ] implies the naturality of [ε] and [η], and
      the two formulas

      [Φ_{Y,X}(f) = G(f) o η_Y]

      [Φ_{Y,X}⁻¹(g) = ε_X o F(g)]

      for each [f: F Y → X] and [g : Y → G X] (which completely
      determine [Φ]). *)

  Lemma UnitCounitOf_Helper1 (Φ : HomAdjunction F G) (ε := projT1 (CounitOf Φ)) (η := projT1 (UnitOf Φ))
  : forall X Y (f : Morphism _ (F Y) X), Φ Y X f = Compose (G.(MorphismOf) f) (η Y).
    intros.
    destruct Φ as [ ? ? ACommutes'0 ]; simpl in *.
    subst_body.
    pose proof (fg_equal (ACommutes'0 _ _ _ _ (Identity _) f) (Identity _)) as H.
    simpl in *.
    autorewrite with functor morphism in H.
    assumption.
  Qed.

  Lemma UnitCounitOf_Helper2
        (Φ : HomAdjunction F G)
        (ε := projT1 (CounitOf Φ))
        (η := projT1 (UnitOf Φ))
        (Φ_Inverse := fun Y X g => proj1_sig ((AIsomorphism Φ) Y X) g)
  : forall X Y (g : Morphism _ Y (G X)), Φ_Inverse Y X g = Compose (ε X) (F.(MorphismOf) g).
    pose proof (ACommutes_Inverse Φ) as ACommutes_Inverse'.
    destruct Φ as [ ? ? ACommutes'0 ]; simpl in *.
    subst_body.
    simpl in *.
    intros X Y g.
    pose proof (fg_equal (ACommutes_Inverse' _ _ _ _ g (Identity _)) (Identity _)) as H.
    simpl in *.
    autorewrite with functor morphism in H.
    symmetry.
    assumption.
  Qed.

  Local Ltac UnitCounitOf_helper make_H :=
    let H := fresh in
    intro X;
      let HT := constr:(make_H X) in
      pose proof HT as H;
        subst_body;
        symmetry; etransitivity; [ | apply H ];
        destruct_head @HomAdjunction; simpl in *;
        intro_proj2_sig_from_goal;
        fg_equal;
        intuition.

  Definition UnitCounitOf (A : HomAdjunction F G) : AdjunctionUnitCounit F G.
    exists (projT1 (UnitOf A))
           (projT1 (CounitOf A));
    [ abstract UnitCounitOf_helper (fun Y => UnitCounitOf_Helper2 A (F Y) Y (projT1 (UnitOf A)(*η*) Y))
    | abstract UnitCounitOf_helper (fun X => UnitCounitOf_Helper1 A X (G X) (projT1 (CounitOf A)(*ε*) X)) ].
  Defined.
End AdjunctionEquivalences.

Section AdjunctionEquivalences'.
  Context `(C : @Category objC).
  Context `(D : @Category objD).
  Variable F : Functor C D.
  Variable G : Functor D C.

  Definition HomAdjunctionOfUnit (T : AdjunctionUnit F G) : HomAdjunction F G.
    refine {| AComponentsOf := (fun c d (g : Morphism _ (F c) d) => Compose (G.(MorphismOf) g) (projT1 T c)) |};
    try (intros; exists (fun f => proj1_sig (projT2 T _ _ f)));
    abstract (
        intros; destruct T as [ T s ]; repeat split; simpl in *;
                                                     apply functional_extensionality_dep; intros;
        solve [
            intro_proj2_sig_from_goal;
            destruct_hypotheses;
            auto with morphism
          |
          repeat rewrite FCompositionOf; repeat rewrite Associativity; repeat apply f_equal;
          simpl_do do_rewrite_rev (Commutes T); reflexivity
          ]
      ).
  Defined.

  Definition HomAdjunctionOfCounit (T : AdjunctionCounit F G) : HomAdjunction F G.
    refine {| AComponentsOf := (fun c d (g : Morphism _ (F c) d) =>
                                  let inverseOf := (fun s d f => proj1_sig (projT2 T s d f)) in
                                  let f := inverseOf _ _ g in
                                  let AComponentsOf_Inverse := Compose (projT1 T d) (F.(MorphismOf) f) in
                                  inverseOf _ _ AComponentsOf_Inverse
                               )
           |};
    simpl;
    try (intros; exists (fun f => Compose (projT1 T _) (F.(MorphismOf) f)));
    abstract (
        elim T; clear T; intros T s; repeat split; intros; simpl in *;
                                                           apply functional_extensionality_dep; intros; simpl;
        intro_proj2_sig_from_goal;
        unfold unique in *;
          split_and';
        repeat match goal with
                 | [ H : _ |- _ ] => rewrite (H _ (eq_refl _))
               end;
        auto with morphism;
        repeat match goal with
                 | [ H : _ |- _ ] => apply H
               end;
        intro_proj2_sig_from_goal;
        destruct_hypotheses;
        repeat rewrite FCompositionOf;
        let H := fresh in assert (H := Commutes T); simpl in H; try_associativity ltac:(rewrite H);
        repeat try_associativity ltac:(apply f_equal2; trivial)
      ).
  Defined.

  Definition HomAdjunctionOfUnitCounit  (T : AdjunctionUnitCounit F G) : HomAdjunction F G.
    refine {| AComponentsOf := (fun c d (g : Morphism _ (F c) d) => Compose (G.(MorphismOf) g) (Adjunction_Unit T c)) |};
    [ intros; exists (fun f => Compose (Adjunction_Counit T A') (F.(MorphismOf) f)) | ];
    abstract (
        repeat intro; repeat split; simpl in *; repeat (apply functional_extensionality_dep; intro);
        destruct T as [Adjunction_Unit Adjunction_Counit];
        repeat rewrite FCompositionOf;
        repeat try_associativity ltac:(apply f_equal2; try reflexivity; []);
        destruct Adjunction_Counit, Adjunction_Unit;
        simpl in *;
          repeat try_associativity ltac:(idtac;
                                         match goal with
                                           | [ H : _ |- _ ] => (rewrite H; clear H; autorewrite with morphism; try reflexivity)
                                           | [ H : _ |- _ ] => (rewrite <- H; clear H; autorewrite with morphism; try reflexivity)
                                         end)
      ).
  Defined.
End AdjunctionEquivalences'.

Coercion HomAdjunction2Adjunction : HomAdjunction >-> Adjunction.
Coercion Adjunction2HomAdjunction : Adjunction >-> HomAdjunction.

Coercion UnitOf : HomAdjunction >-> AdjunctionUnit.
Coercion CounitOf : HomAdjunction >-> AdjunctionCounit.
Coercion UnitCounitOf : HomAdjunction >-> AdjunctionUnitCounit.

Coercion HomAdjunctionOfUnit : AdjunctionUnit >-> HomAdjunction.
Coercion HomAdjunctionOfCounit : AdjunctionCounit >-> HomAdjunction.
Coercion HomAdjunctionOfUnitCounit : AdjunctionUnitCounit >-> HomAdjunction.

Reserved Infix "⊣" (at level 90, no associativity).
Reserved Infix "-|" (at level 90, no associativity).

Infix "⊣" := Adjunction.
Infix "-|" := Adjunction.
