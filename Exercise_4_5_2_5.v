(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing ≄ %\ensuremath{\not\simeq}% #&#8772;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
(** printing ℙ %\ensuremath{\mathbb{P}}% #&#x2119;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import ChainCategory Functor.
Require Import Common Notations.

Set Implicit Arguments.

Generalizable All Variables.

(** ------------------------------------------------------------------------ *)

(** * Exercise 4.5.2.5 *)
Module Exercise_4_5_2_5.
  Local Open Scope category_scope.
  Local Open Scope morphism_scope.
  (** ** Problem *)
  (** Let [C] be a category, [A : Ob C] an object, and [f : A -> A] a
      morphism in [C]. Consider the two diagrams in [C] drawn below:

<<
        f    f    f
      A -> A -> A -> ...

          _
         / \
      f |   A
         \_↗
>>

      (a) Should these two diagrams have the same indexing category?

      (b) If they should have the same indexing category, what is
          causing or allowing the pictures to appear different?

      (c) If they should not have the same indexing category, what
          coincidence makes the two pictures have so much in common? *)
  (** ** Solution *)
  (** (a) No.

      (b) N/A

      (c) The left/first diagram factors through the right/second one.
      *)

  Parameter objC : Type.
  Parameter C : @Category objC.
  Parameter A : C.
  Parameter f : Morphism C A A.

  (** There is a category loop with one object and a morphism for
      every natural number from that object to itself.  We use [+] for
      composition, and [0] for the identity, and let the [omega]
      tactic take care of goals about natural numbers. *)
  Definition NatGroup : @Category unit.
    refine (@Build_Category unit
                            (fun _ _ => ℕ)
                            (fun _ => 0)
                            (fun _ _ _ => plus)
                            _
                            _
                            _);
    abstract (intros; omega).
  Defined.

  (** The indexing category of the left/first diagram is [ω], the
      category [0 -> 1 -> 2 -> 3 -> ...], which has one object for
      each natural number and a morphism [n -> m] if [n <= m]. *)

  Definition FirstIndex : Category := [ω].

  (** The indexing category of the right/second diagram is a category
      with one object, and one morphism from that object to itself for
      each natural number. *)

  Definition SecondIndex : Category := NatGroup.

  Fixpoint SecondDiagram_MorphismOf (n : ℕ) : Morphism C A A
    := match n with
         | O => Identity A
         | S n' => Compose (SecondDiagram_MorphismOf n') f
       end.

  (** We prove that the [MorphismOf] that we defined above commutes
      with composition with [f], by induction. *)

  Lemma SecondDiagram_MorphismOf_commut n : f o SecondDiagram_MorphismOf n = SecondDiagram_MorphismOf n o f.
    induction n; simpl;
    autorewrite with category;
    repeat rewrite <- Associativity;
    try apply f_equal2;
    intuition.
  Qed.

  (** The second diagram (with a single object) sends the morphism [n]
      to [f^n].  This is a functor because [f^n o f^m = f^{n+m}],
      which we prove by induction and using the above commutativity
      law. *)

  Definition SecondDiagram : Functor SecondIndex C.
    refine (Build_Functor SecondIndex C
                          (fun _ => A)
                          (fun _ _ => SecondDiagram_MorphismOf)
                          _
                          _);
    abstract (repeat match goal with
                       | _ => reflexivity
                       | [ |- ?T -> _ ] => match eval hnf in T with
                                             | unit => intros []
                                             | ℕ => let H := fresh in intro H; induction H
                                           end
                       | [ H : _ |- _ ] => simpl in H |- *; rewrite H
                       | _ => progress (simpl in *; autorewrite with category; reflexivity)
                       | _ => progress repeat rewrite <- Associativity
                       | [ |- _ = ?a o ?b o ?c o ?d ] => transitivity (a o (b o c) o d);
                       try (repeat rewrite Associativity; reflexivity);
                       rewrite SecondDiagram_MorphismOf_commut
                     end).
  Defined.

  (** The first diagram factors through the first, by way of a
      morphism which sends the arrow [m -> n] to [n - m]. *)

  Definition FirstDiagram_helper : Functor FirstIndex SecondIndex.
    refine (Build_Functor FirstIndex SecondIndex
                          (fun _ => tt)
                          (fun m n _ => n - m)
                          _
                          _);
    abstract (intros; simpl in *; omega).
  Defined.

  Definition FirstDiagram : Functor FirstIndex C
    := (SecondDiagram o FirstDiagram_helper)%functor.
End Exercise_4_5_2_5.

(** ------------------------------------------------------------------------ *)
