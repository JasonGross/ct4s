(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing ⋂ %\ensuremath{\bigcap}% #&#8898;# *)
(** printing ⋃ %\ensuremath{\bigcup}% #&#8899;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8 Setoid.
Require Import ProofIrrelevance.
Require Import Classical.
Require Export Ensembles.
Require Import Notations Common Morphism.

Set Implicit Arguments.

Generalizable All Variables.

(** * Topology *)

Create HintDb topology discriminated.

Delimit Scope topology_scope with topology.

Local Open Scope topology_scope.

Section inclusion.
  Variable T : Type.

  Global Instance Included_refl : RelationClasses.Reflexive (@Included T).
  Proof.
    firstorder.
  Qed.

  Global Instance Included_trans : RelationClasses.Transitive (@Included T).
  Proof.
    firstorder.
  Qed.
End inclusion.

Add Parametric Relation T : _ (@Included T)
    reflexivity proved by (@Included_refl _)
    transitivity proved by (@Included_trans _)
      as Included_rel.

Local Ltac inter_t :=
  repeat intro;
  destruct_head_hnf @Intersection;
  constructor; firstorder.

Add Parametric Morphism T A : (@Intersection T A)
with signature (@Included T) ==> (@Included T)
  as Intersection_Included_morl.
  inter_t.
Qed.

Add Parametric Morphism T A : (fun B => @Intersection T B A)
with signature (@Included T) ==> (@Included T)
  as Intersection_Included_morr.
  inter_t.
Qed.

Add Parametric Morphism T : (@Intersection T)
with signature (@Included T) ==> (@Included T) ==> (@Included T)
  as Intersection_Included_mor_both.
  inter_t.
Qed.

Section topology.
  Variable X : Type.

  Inductive ArbitraryUnion (XjP : Ensemble (Ensemble X)) : Ensemble X :=
  | ArbitraryUnion_inJ (Xj : Ensemble X)
    : forall x, Xj ∈ XjP -> x ∈ Xj -> x ∈ (ArbitraryUnion XjP).

  Definition ArbitraryIntersection (XjP : Ensemble (Ensemble X)) : Ensemble X :=
    Complement _ (ArbitraryUnion (fun U => (Complement _ U) ∈ XjP)).

  Class Topology :=
    {
      Open : Ensemble (Ensemble X);
      OpenSet :> _ := { U | Open U };
      ContainsSpace : Open (Full_set _);
      ContainsEmpty : Open (Empty_set _);
      ArbitraryUnionOpen : forall (XjP : Ensemble (Ensemble X)),
                             (forall Xj, Xj ∈ XjP -> Open Xj) -> Open (ArbitraryUnion XjP);
      FiniteIntersectionOpen : forall A B,
                                 Open A -> Open B -> Open (A ∩ B)
    }.

  Definition Closed {T : Topology} (U : Ensemble X) := @Open T (Complement _ U).
End topology.

Notation "⋃ S" := (ArbitraryUnion S) (at level 50, no associativity) : topology_scope.
Notation "⋂ S" := (ArbitraryIntersection S) (at level 50, no associativity) : topology_scope.
(*Notation "⋂ S" := PairwiseIntersection *)

Section intersection.
  Variable X : Type.
  Variables C C' : Ensemble (Ensemble X).

  Inductive PairwiseIntersection : Ensemble (Ensemble X) :=
    PairwiseIntersection_intro
    : forall U U',
        U ∈ C -> U' ∈ C' -> (U ∩ U') ∈ PairwiseIntersection.
End intersection.

Ltac destruct_sets := repeat (
                          (destruct_head_hnf ArbitraryUnion)
                            || (destruct_head_hnf PairwiseIntersection)
                            || (destruct_head_hnf Intersection)
                            || match goal with
                                 | [ |- ?G ] => match type of G with
                                                  | Prop => destruct_head_hnf @ex;
                                                  destruct_head_hnf @ex2
                                                end
                               end
                        ).

Hint Extern 0 => econstructor; hnf in *; eassumption.
Hint Extern 1 => econstructor; solve [ trivial ].

Section intersection_union_commute.
  Variable X : Type.
  Variables C C' : Ensemble (Ensemble X).

  Lemma intersection_arbitrary_union_commute
  : ⋃ (PairwiseIntersection C C')
    = (⋃ C) ∩ (⋃ C').
  Proof.
    apply Extensionality_Ensembles;
    split; hnf; intros;
    destruct_sets; eauto.
  Qed.
End intersection_union_commute.

Hint Immediate ContainsSpace ContainsEmpty ArbitraryUnionOpen FiniteIntersectionOpen : topology.

Coercion OpenSet : Topology >-> Sortclass.

Definition ensemble2sig {X} (E : Ensemble X) := { x | x ∈ E }.

Coercion ensemble2sig : Ensemble >-> Sortclass.

Definition subset_ensemble {U} {V : Ensemble U} (W : Ensemble (sig V)) : Ensemble U
  := fun x => x ∈ V /\ (forall H, (exist _ x H) ∈ W).

Lemma subset_ensemble_included U V W : (@subset_ensemble U V W) ⊆ V.
Proof.
  hnf; intros;
  hnf in *;
  destruct_hypotheses; trivial.
Qed.

Lemma subset_ensemble_iff1 U V W
: forall x H, x ∈ (@subset_ensemble U V W) -> (exist _ x H) ∈ W.
Proof.
  intros; hnf in *.
  destruct_hypotheses; unfold Ensembles.In in *; intuition.
Qed.

Lemma subset_ensemble_iff2 U V W
: forall x, x ∈ W -> (proj1_sig x) ∈ (@subset_ensemble U V W).
Proof.
  intros; hnf in *; destruct_sig; intuition.
  hnf;
    match goal with
      | [ H : ?f (exist ?V ?x ?H0) |- ?f (exist ?V ?x ?H1) ] =>
        cut (f (exist V x H0) = f (exist V x H1));
          [ let H := fresh in intro; rewrite <- H; assumption | repeat f_equal ]
    end;
    apply ProofIrrelevance.proof_irrelevance.
Qed.

Ltac do_proof_irrelevance :=
  repeat match goal with
           | [ H : ?P, H' : ?P |- _ ] => match type of P with
                                           | Prop => let H'' := fresh in assert (H'' : H = H') by (apply ProofIrrelevance.proof_irrelevance);
                                                                        rewrite H'' in *; clear H''; clear H
                                         end
         end.

Local Ltac generalize_sig_then_destruct_sets :=
  repeat match goal with
           | [ H : context[exist ?P ?x ?H] |- ?f ?x ] =>
             match goal with
               | [ _ := exist P x H |- _ ] => fail 1
               | _ => let x' := fresh "x'" in pose (exist P x H) as x';
                                             assert (proj1_sig x' = x) by reflexivity
             end
         end;
  destruct_sets; subst_body; repeat subst.

Section subset_ensemble_union_intersection.
  Variable X : Type.
  Variable U : Ensemble X.

  Local Ltac pre_union_intersection :=
    repeat (repeat subst; hnf in *; intros; generalize_sig_then_destruct_sets;
            do_proof_irrelevance;
            (split ||
                   constructor ||
                   split_and ||
                   intuition)).

  Local Ltac union_intersection :=
    repeat (pre_union_intersection; specialize_all_ways; intuition; hnf in *; destruct_sig; simpl in *; hnf).

  Lemma subset_ensemble_intersection (A B : Ensemble (sig U))
  : (subset_ensemble A) ∩ (subset_ensemble B) = subset_ensemble (A ∩ B).
  Proof.
    apply Extensionality_Ensembles; union_intersection.
  Qed.

  Lemma subset_ensemble_union (A : Ensemble (Ensemble (sig U)))
  : ArbitraryUnion (fun S => S ⊆ U /\ A (fun x => (proj1_sig x) ∈ S)) = subset_ensemble (⋃ A).
  Proof.
    apply Extensionality_Ensembles; pre_union_intersection;
    specialize_all_ways; intuition; hnf in *.
    generalize_sig_then_destruct_sets.
    unfold Ensembles.In in *.
    destruct_sig; simpl in *; do_proof_irrelevance.
    exists (subset_ensemble Xj); pre_union_intersection;
    match goal with
      | [ |- A ?f ] => cut (f = Xj); [ let H := fresh in intro H; rewrite H; assumption | ]
    end;
    apply Extensionality_Ensembles; union_intersection.
  Qed.
End subset_ensemble_union_intersection.

Section inclusion2.
  Variable X : Type.
  Variable E : Ensemble X.

  Definition inclusion : E -> X := @proj1_sig _ _.
End inclusion2.

Section inclusion3.
  Variable X : Type.

  Definition include_subset (U V : Ensemble X) : U ⊆ V -> Ensemble { x : X | x ∈ V }
    := (fun _ xH => (proj1_sig xH) ∈ U).
End inclusion3.

Section inverse.
  Variables X Y : Type.

  Definition inverse_map (f : X -> Y) : Y -> Ensemble X :=
    fun y => (fun x => y = f x).

  Definition image (f : X -> Y) : Ensemble X -> Ensemble Y :=
    fun Px y => exists x, x ∈ Px /\ f x = y.

  Definition inverse_image (f : X -> Y) : Ensemble Y -> Ensemble X :=
    fun Uy x => (f x) ∈ Uy.

  Definition restrict_domain (f : X -> Y) (P : Ensemble X) : { x | P x } -> Y
    := fun x => f (proj1_sig x).

  Definition restrict (f : X -> Y) (P : Ensemble X) (Q : Ensemble Y) (H : forall x, x ∈ P -> (f x) ∈ Q)
  : { x | P x } -> { y | Q y }
    := fun x => exist _ (f (proj1_sig x)) (H (proj1_sig x) (proj2_sig x)).

  Definition restrict_range (f : X -> Y) (P : Ensemble Y) : sig (inverse_image f P) -> sig P
    := fun x => exist _ (f (proj1_sig x)) (proj2_sig x).
End inverse.

Notation "p ⁻¹" := (inverse_image p) (at level 10) : topology_scope.

Section inverse_compose.
  Variables X Y Z : Type.
  Variable f : X -> Y.
  Variable g : Y -> Z.

  Definition inverse_compose_commutes : f ⁻¹ o g ⁻¹ = (g o f) ⁻¹.
    reflexivity.
  Defined.
End inverse_compose.

Add Parametric Morphism T : (@Ensembles.In T)
    with signature (@Included T) ==> (@eq T) ==> Basics.impl
      as Included_In_mor.
  repeat intro.
  firstorder.
Qed.

Add Parametric Morphism T : (@Ensembles.In T)
    with signature (Basics.flip (@Included T)) ==> (@eq T) ==> (Basics.flip Basics.impl)
      as Included_In_mor'.
  repeat intro.
  firstorder.
Qed.

Section complement_idempotent.
  Context `(T : Topology X).

  Lemma complement_idempotent S : Complement X (Complement X S) = S.
    clear T.
    apply Extensionality_Ensembles.
    repeat (intro || split);
    try match goal with
          | [ H : _ |- _ ] => apply NNPP in H
        end;
    firstorder.
  Qed.

  Local Ltac t :=
    repeat match goal with
             | _ => apply Extensionality_Ensembles
             | _ => progress (repeat (intro || split))
             | _ => progress destruct_head_hnf ArbitraryUnion
             | _ => progress (repeat unfold Complement, Ensembles.In in *; trivial)
             | _ => eassumption
             | _ => eexists; try eassumption; []
             | [ H : _ |- _ ] => apply H
             | [ H : _ |- _ ] => apply NNPP in H
             | [ H : ?XjP ?Xj |- ?XjP ?Xj' ] => cut (Xj = Xj');
                                               [ let H := fresh in intro H; rewrite <- H; assumption
                                               | apply Extensionality_Ensembles ]
             | _ => progress intuition
             | _ => progress firstorder
           end.

  Lemma complement_union XjP : Complement T (⋃ XjP)
                               = ⋂ (fun U => (Complement T U) ∈ XjP).
    t.
  Qed.

  Lemma complement_intersection XjP : Complement T (⋂ XjP)
                               =  ⋃ (fun U => (Complement T U) ∈ XjP).
    t.
  Qed.
End complement_idempotent.

Section disjoint_union.
  Variable X : Type.

  Record IsDisjointUnion (U : Ensemble X) := {
                                              DisjointUnionSets :> Ensemble (Ensemble X);
                                              DisjointUnionSetsDisjoint : forall A B,
                                                                            A <> B
                                                                            -> A ∈ DisjointUnionSets
                                                                            -> B ∈ DisjointUnionSets
                                                                            -> Disjoint _ A B;
                                              DisjointUnionIsUnion : ⋃ DisjointUnionSets = U
                                            }.

  Lemma disjoint_union_in (U : Ensemble X) (DU : IsDisjointUnion U) : forall (Ux : DU), (proj1_sig Ux) ⊆ U.
  Proof.
    intros Ux x H;
    destruct_sig;
    simpl in *.
    let H := fresh in pose proof (DisjointUnionIsUnion DU) as H;
                     rewrite <- H.
    hnf.
    econstructor; unfold Ensembles.In in *; simpl in *; eassumption.
  Qed.
End disjoint_union.

Section intersection_lemmas.
  Variable X : Type.

  Lemma IntersectionAAA (A : Ensemble X) : A ∩ A = A.
  Proof.
    apply Extensionality_Ensembles; split; intros x H; destruct_head_hnf Intersection; try constructor; trivial.
  Qed.
End intersection_lemmas.
