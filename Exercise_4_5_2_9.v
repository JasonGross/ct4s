(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing ≄ %\ensuremath{\not\simeq}% #&#8772;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
(** printing ℙ %\ensuremath{\mathbb{P}}% #&#x2119;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ▻ %\ensuremath{\triangleright}% #&#x25BB;# *)
(** printing ◅ %\ensuremath{\triangleleft}% #&#x25C5;# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import ChainCategory Functor Cone CategoryIsomorphisms ComputableCategory InitialTerminalCategory.
Require Import Common Notations NatFacts FEqualDep.

Set Implicit Arguments.

Generalizable All Variables.

(** ------------------------------------------------------------------------ *)

(** * Exercise 4.5.2.9 *)
Module Exercise_4_5_2_9.
  Local Open Scope category_scope.
  Local Open Scope morphism_scope.
  (** ** Problem *)
  (** Let [C_0 := _0_] denote the empty category and for any natural number
      [n : ℕ], let [C_{n+1} := (C_n)◅].  Draw [C_4]. *)
  (** ** Solution *)
  (** I prove that [C_{n+1} ≅ [n]], the chain category on [n + 1]
      nodes.  Thus, after some relabeling, [C_4] is [0 -> 1 -> 2 -> 3]
      (where the compositions are left implicit. *)

  Fixpoint C_obj (n : ℕ) : Set :=
    match n with
      | O => ∅
      | S n' => unit ⊔ C_obj n'
    end.

  Fixpoint C (n : ℕ) : @Category (C_obj n) :=
    match n as n0 return @Category (C_obj n0) with
      | O => InitialCategory
      | S n' => (C n')◅
    end.

  (** We prove that morphisms in [C_n] are unique, by induction on
      [n]. *)

  Lemma C_morphism_unicity n s d (m1 m2 : Morphism (C n) s d) : m1 = m2.
    induction n; hnf in *;
    destruct_head_hnf @sum;
    destruct_head_hnf unit;
    easy.
  Qed.

  (** We turn elements of [C_{n + 1}] into elements of [[n]] by
      recursion on [n]. For [0], we construct the unique element of
      [[0]].  For [n + 1], if the object we're given is initial, then
      we send it to the initial object of [[n]].  Otherwise, it's an
      object of [C_n], so we find where it is in [[n - 1]], and bump
      it up by one. *)

  Fixpoint C_to_chain (n : ℕ) : C (S n) -> [n].
  Proof.
    refine (match n as n0 return C (S n0) -> [n0] with
              | O => fun x => exist _ 0 (le_n 0)
              | S n' => fun x => match x with
                                   | inl tt => exist _ 0 _
                                   | inr x' => let H := C_to_chain n' x' in
                                               exist _ (S (proj1_sig H)) (_ (proj2_sig H))
                                 end
            end);
    repeat match goal with
             | [ H : _ |- _ ] => clear H || clearbody H
           end;
    abstract (intros; omega).
  Defined.

  Fixpoint chain_to_C (n : ℕ) : [n] -> C (S n).
  Proof.
    refine (match n as n return [n] -> C (S n) with
              | O => fun _ => inl tt
              | S n' => fun x : [S n'] => match x with
                                            | exist 0 _ => inl tt
                                            | exist (S m) pf => let pf' := pf : S m <= S n' in
                                                                let x' := chain_to_C n' (exist _ m _) in
                                                                inr x'
                                          end
            end).
    clearbody pf'; revert pf'; clear.
    abstract (intros; omega).
  Defined.

  (** Now we define the functor on morphisms.  This is easier, because
      the morphisms are unique. *)

  Lemma C_to_chain_MorphismOf (n : ℕ)
  : forall s d (m : Morphism (C (S n)) s d),
      Morphism [n] (C_to_chain s) (C_to_chain d).
  Proof.
    induction n; simpl;
    [ clear; abstract (repeat intros []; omega)
    | ];
    repeat (intros [] || intro); simpl;
    try (clear; abstract omega);
    apply Le.le_n_S;
    apply IHn;
    hnf; trivial.
  Qed.

  (** We prove this primarily by induction and [omega]. *)

  Lemma chain_to_C_MorphismOf (n : ℕ)
  : forall s d (m : Morphism [n] s d),
      Morphism (C (S n)) (chain_to_C s) (chain_to_C d).
  Proof.
    induction n; [ easy | ].
    intros [s ?]; induction s;
    intros [d ?]; induction d;
    simpl in *;
    try easy;
    try (intros; omega).
    intro.
    apply IHn.
    simpl.
    omega.
  Qed.

  (** Now we define the functors; the functoriality follows from
      decidable proof irrelevance. *)

  Definition C_to_chain_functor (n : ℕ) : Functor (C (S n)) [n].
    refine {| MorphismOf := @C_to_chain_MorphismOf n |};
    abstract (
        intros;
        simpl;
        apply nat_le_proofs_unicity
      ).
  Defined.

  Definition chain_to_C_functor (n : ℕ) : Functor [n] (C (S n)).
    refine {| MorphismOf := @chain_to_C_MorphismOf n |};
    abstract (
        intros;
        apply C_morphism_unicity
      ).
  Defined.

  (** Now, finally, we prove that [[n]] and [C_{n + 1}] are isomorphic
      in [Cat].

      To prove this goal, we exhaustively apply the tactics in [t'],
      then proceed by induction on [n] (after reverting the necessary
      hypotheses), and then again exhaustively apply the tactics in
      [t'] as well as the tactic in [t]. *)

  Local Ltac t' IHn :=
    repeat match goal with
             | _ => simpl; easy
             | _ => abstract omega
             | _ => progress simpl in *
             | _ => progress (destruct_head_hnf ∅)
             | _ => progress destruct_head_hnf @sig
             | _ => progress destruct_head_hnf @sum
             | _ => progress destruct_head_hnf @unit
             | _ => apply C_morphism_unicity
             | _ => apply nat_le_proofs_unicity
             | _ => solve [ symmetry; rewrite <- IHn at 1; reflexivity ]
             | _ => progress repeat f_equal
             | _ => progress simpl_eq
             | _ => progress rewrite <- IHn
             | [ H1 : ?a <= ?b, H2 : ?a <= ?b |- _ ] => assert (H1 = H2)
                                                       by apply nat_le_proofs_unicity;
                                                       subst H1
           end.

  Local Ltac t IHn:=
    repeat match goal with
             | _ => progress t' IHn
             | [ n : nat |- _ ] => destruct n; solve [ t' IHn ]
           end.

  Theorem Exercise_4_5_2_9 n : ((C (S n) : CategoryOfCategories)
                                  ≅ ([n] : CategoryOfCategories))%category.
    exists (@C_to_chain_functor n).
    exists (@chain_to_C_functor n);
      simpl;
      apply Functor_Eq;
      repeat (intros [[]|?] || intro);
      t' dummy_hyp;
      repeat match goal with
               | [ H : _ |- _ ] => (constr_eq H n; fail 1)
                                     || revert H
             end;
      induction n;
      t IHn.
  Qed.
End Exercise_4_5_2_9.

(** ------------------------------------------------------------------------ *)
