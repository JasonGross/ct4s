(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing ⋂ %\ensuremath{\bigcap}% #&#8898;# *)
(** printing ⋃ %\ensuremath{\bigcup}% #&#8899;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import ProofIrrelevance FunctionalExtensionality.
Require Import Finite_sets Classical IndefiniteDescription.
Require Export Ensembles.
Require Import Notations Common PreOrderCategory CategoryIsomorphisms Orders Morphism.

Set Implicit Arguments.

Generalizable All Variables.

(** * Topology *)

Create HintDb topology discriminated.

Delimit Scope topology_scope with topology.

Notation "x ∈ X" := (In _ X x) (at level 50, no associativity) : topology_scope.
Notation "A ∩ B" := (Intersection _ A B) (at level 50, no associativity) : topology_scope.
Notation "A ⊆ B" := (Included _ A B) (at level 50, no associativity) : topology_scope.

Local Open Scope topology_scope.

Section topology.
  Variable X : Type.

  Inductive ArbitraryUnion (XjP : Ensemble (Ensemble X)) : Ensemble X :=
  | ArbitraryUnion_inJ (Xj : Ensemble X)
    : forall x, Xj ∈ XjP -> x ∈ Xj -> x ∈ (ArbitraryUnion XjP).

  Class Topology :=
    {
      Open : Ensemble (Ensemble X);
      OpenSet :> _ := { U | Open U };
      ContainsSpace : Open (Full_set _);
      ContainsEmpty : Open (Empty_set _);
      ArbitraryUnionOpen : forall (XjP : Ensemble (Ensemble X)),
                             (forall Xj, Xj ∈ XjP -> Open Xj) -> Open (ArbitraryUnion XjP);
      FiniteIntersectionOpen : forall A B,
                                 Open A -> Open B -> Open (A ∩ B)
    }.

  Definition Closed (T : Topology) (U : Ensemble X) := @Open T (Complement _ U).
End topology.

Notation "⋃ S" := (ArbitraryUnion S) (at level 50, no associativity) : topology_scope.
(*Notation "⋂ S" := PairwiseIntersection *)

Section intersection.
  Variable X : Type.
  Variables C C' : Ensemble (Ensemble X).

  Inductive PairwiseIntersection : Ensemble (Ensemble X) :=
    PairwiseIntersection_intro
    : forall U U',
        U ∈ C -> U' ∈ C' -> (U ∩ U') ∈ PairwiseIntersection.
End intersection.

Ltac destruct_sets := repeat (
                          (destruct_head_hnf ArbitraryUnion)
                            || (destruct_head_hnf PairwiseIntersection)
                            || (destruct_head_hnf Intersection)
                            || match goal with
                                 | [ |- ?G ] => match type of G with
                                                  | Prop => destruct_head_hnf @ex;
                                                  destruct_head_hnf @ex2
                                                end
                               end
                        ).

Hint Extern 0 => econstructor; hnf in *; eassumption.
Hint Extern 1 => econstructor; solve [ trivial ].

Section intersection_union_commute.
  Variable X : Type.
  Variables C C' : Ensemble (Ensemble X).

  Lemma intersection_arbitrary_union_commute
  : ⋃ (PairwiseIntersection C C')
    = (⋃ C) ∩ (⋃ C').
  Proof.
    apply Extensionality_Ensembles;
    split; hnf; intros;
    destruct_sets; eauto.
  Qed.
End intersection_union_commute.

Hint Immediate ContainsSpace ContainsEmpty ArbitraryUnionOpen FiniteIntersectionOpen : topology.

Coercion OpenSet : Topology >-> Sortclass.

Definition ensemble2sig {X} (E : Ensemble X) := { x | x ∈ E }.

Coercion ensemble2sig : Ensemble >-> Sortclass.

Definition subset_ensemble {U} {V : Ensemble U} (W : Ensemble (sig V)) : Ensemble U
  := fun x => x ∈ V /\ (forall H, (exist _ x H) ∈ W).

Lemma subset_ensemble_included U V W : (@subset_ensemble U V W) ⊆ V.
Proof.
  hnf; intros;
  hnf in *;
  destruct_hypotheses; trivial.
Qed.

Lemma subset_ensemble_iff1 U V W
: forall x H, x ∈ (@subset_ensemble U V W) -> (exist _ x H) ∈ W.
Proof.
  intros; hnf in *.
  destruct_hypotheses; unfold In in *; intuition.
Qed.

Lemma subset_ensemble_iff2 U V W
: forall x, x ∈ W -> (proj1_sig x) ∈ (@subset_ensemble U V W).
Proof.
  intros; hnf in *; destruct_sig; intuition.
  hnf;
    match goal with
      | [ H : ?f (exist ?V ?x ?H0) |- ?f (exist ?V ?x ?H1) ] =>
        cut (f (exist V x H0) = f (exist V x H1));
          [ let H := fresh in intro; rewrite <- H; assumption | repeat f_equal ]
    end;
    apply proof_irrelevance.
Qed.

Ltac do_proof_irrelevance :=
  repeat match goal with
           | [ H : ?P, H' : ?P |- _ ] => match type of P with
                                           | Prop => let H'' := fresh in assert (H'' : H = H') by (apply proof_irrelevance);
                                                                        rewrite H'' in *; clear H''; clear H
                                         end
         end.

Local Ltac generalize_sig_then_destruct_sets :=
  repeat match goal with
           | [ H : context[exist ?P ?x ?H] |- ?f ?x ] =>
             match goal with
               | [ _ := exist P x H |- _ ] => fail 1
               | _ => let x' := fresh "x'" in pose (exist P x H) as x';
                                             assert (proj1_sig x' = x) by reflexivity
             end
         end;
  destruct_sets; subst_body; repeat subst.

Section subset_ensemble_union_intersection.
  Variable X : Type.
  Variable U : Ensemble X.

  Local Ltac pre_union_intersection :=
    repeat (repeat subst; hnf in *; intros; generalize_sig_then_destruct_sets;
            do_proof_irrelevance;
            (split ||
                   constructor ||
                   split_and ||
                   intuition)).

  Local Ltac union_intersection :=
    repeat (pre_union_intersection; specialize_all_ways; intuition; hnf in *; destruct_sig; simpl in *; hnf).

  Lemma subset_ensemble_intersection (A B : Ensemble (sig U))
  : (subset_ensemble A) ∩ (subset_ensemble B) = subset_ensemble (A ∩ B).
  Proof.
    apply Extensionality_Ensembles; union_intersection.
  Qed.

  Lemma subset_ensemble_union (A : Ensemble (Ensemble (sig U)))
  : ArbitraryUnion (fun S => S ⊆ U /\ A (fun x => (proj1_sig x) ∈ S)) = subset_ensemble (⋃ A).
  Proof.
    apply Extensionality_Ensembles; pre_union_intersection;
    specialize_all_ways; intuition; hnf in *.
    generalize_sig_then_destruct_sets.
    unfold In in *.
    destruct_sig; simpl in *; do_proof_irrelevance.
    exists (subset_ensemble Xj); pre_union_intersection;
    match goal with
      | [ |- A ?f ] => cut (f = Xj); [ let H := fresh in intro H; rewrite H; assumption | ]
    end;
    apply Extensionality_Ensembles; union_intersection.
  Qed.
End subset_ensemble_union_intersection.

Section inclusion.
  Variable X : Type.
  Variable E : Ensemble X.

  Definition inclusion : E -> X := @proj1_sig _ _.
End inclusion.

Section subspace_topology.
  Variable X : Type.
  Variable T : Topology X.
  Variable P : X -> Prop.

  Local Ltac subspace_t :=
    try apply Extensionality_Ensembles; hnf;
    repeat split; simpl in *; hnf in *;
    destruct_hypotheses; unfold In in *; simpl in *;
    destruct_head_hnf @Intersection;
    auto;
    specialize_all_ways;
    destruct_head_hnf @Empty_set.

  (*Inductive SubspaceOpen : Ensemble (Ensemble (sig P)) :=
    SubspaceOpen_intro : forall (U' : T) (U : Ensemble (sig P)),
                           subset_ensemble U = Intersection _ (proj1_sig U') P
                           -> In _ SubspaceOpen U.*)

  Local Ltac remove_proj1_sig_evar :=
    match goal with
      | [ |- context[proj1_sig ?x] ] =>
        has_evar x;
          let T := type of x in
          match eval hnf in T with
            | sig ?P =>
              match type of P with
                | ?A -> Prop =>
                  let y := fresh "y" in
                  let H := fresh "H" in
                  evar (y : A);
                    evar (H : P y);
                    let H' := fresh in
                    assert (H' : x = exist P y H) by reflexivity;
                      clear H'; subst y; subst H; simpl
              end
          end
    end.

  Global Instance SubspaceTopology : Topology (sig P) :=
    {| Open := (fun U => exists U' : T, subset_ensemble U = (proj1_sig U') ∩ P) |}.
  Proof with simpl; try abstract solve [ subspace_t ].
    - refine (ex_intro _ (exist _ (Full_set _) _) _)...
    - refine (ex_intro _ (exist _ (Empty_set _) _) _)...
    - (*setoid_rewrite <- subset_ensemble_union;
      intros; esplit;
      apply Extensionality_Ensembles; split; intros ? ?; destruct_sets; unfold In in *; simpl in *;
      destruct_sets; intuition; unfold Included in *;
      try remove_proj1_sig_evar;
      try constructor; intuition; try eassumption;
      specialize_all_ways;
      simpl in *.
      clear H0 H1 X0.*)
      admit.
    - setoid_rewrite <- subset_ensemble_intersection;
      intros A B HA HB; destruct HA as [ UA HA ], HB as [ UB HB ];
      rewrite HA, HB;
      refine (ex_intro _ (exist _ (Intersection _ _ _) _) _); simpl;
      apply Extensionality_Ensembles; split; intros ? ?; destruct_sets; unfold In in *; simpl in *;
      repeat constructor; try assumption; unfold In in *; [ | | eassumption | eassumption ]; assumption.
      Grab Existential Variables.
      abstract (destruct_sig; simpl; auto with topology).
      abstract (destruct_sig; simpl; auto with topology).
      abstract (destruct_sig; simpl; auto with topology).
  Defined.
End subspace_topology.

Section inclusion2.
  Variable X : Type.

  Definition include_subset (U V : Ensemble X) : U ⊆ V -> Ensemble { x : X | x ∈ V }
    := (fun _ xH => (proj1_sig xH) ∈ U).
End inclusion2.

Section inverse.
  Variables X Y : Type.

  Definition inverse_map (f : X -> Y) : Y -> Ensemble X :=
    fun y => (fun x => y = f x).

  Definition image (f : X -> Y) : Ensemble X -> Ensemble Y :=
    fun Px y => exists x, In _ Px x /\ f x = y.

  Definition inverse_image (f : X -> Y) : Ensemble Y -> Ensemble X :=
    fun Uy x => In _ Uy (f x).

  Definition restrict_domain (f : X -> Y) (P : Ensemble X) : { x | P x } -> Y
    := fun x => f (proj1_sig x).

  Definition restrict (f : X -> Y) (P : Ensemble X) (Q : Ensemble Y) (H : forall x, In _ P x -> In _ Q (f x))
  : { x | P x } -> { y | Q y }
    := fun x => exist _ (f (proj1_sig x)) (H (proj1_sig x) (proj2_sig x)).

  Definition restrict_range (f : X -> Y) (P : Ensemble Y) : sig (inverse_image f P) -> sig P
    := fun x => exist _ (f (proj1_sig x)) (proj2_sig x).
End inverse.

Notation "p ⁻¹" := (inverse_image p) (at level 10) : topology_scope.

Section inverse_compose.
  Variables X Y Z : Type.
  Variable f : X -> Y.
  Variable g : Y -> Z.

  Definition inverse_compose_commutes : f ⁻¹ o g ⁻¹ = (g o f) ⁻¹.
    reflexivity.
  Defined.
End inverse_compose.

Section continuous.
  Section continuous_definition.
    Variables X Y : Type.
    Variable Tx : Topology X.
    Variable Ty : Topology Y.

    (** inverse image of open sets are open *)
    Definition continuous (f : X -> Y)
      := forall Uy, @Open _ Ty Uy -> @Open _ Tx (f ⁻¹ Uy).
  End continuous_definition.

  Section continuous_identity.
    Variable X : Type.
    Variable Tx : Topology X.
    (** the identity function is continuous *)
    Definition identity_is_continuous : continuous _ _ (@id X).
      intros Uy UH.
      unfold inverse_image, id.
      match goal with
        | [ H : Open ?U |- Open ?U' ] => assert (H' : U' = U)
                                        by (apply Extensionality_Ensembles; compute; split; intro; exact id)
      end.
      intuition.
    Qed.
  End continuous_identity.

  Section continuous_composition.
    Context `(Tx : Topology X).
    Context `(Ty : Topology Y).
    Context `(Tz : Topology Z).

    (** the composition of continuous functions is continuous *)
    Definition compose_continuous (f : Y -> Z) (g : X -> Y)
    : continuous _ _ f -> continuous _ _ g -> continuous _ _ (f o g).
      intros fc gc Uz UH.
      unfold continuous in *.
      change ((f o g) ⁻¹) with (g ⁻¹ o f ⁻¹).
      simpl.
      intuition.
    Qed.
  End continuous_composition.
End continuous.

Section homeomorphic.
  Variables X Y : Type.
  Variable Tx : Topology X.
  Variable Ty : Topology Y.

  Record Homeomorphism (f : X -> Y) :=
    {
      HomeomorphismMap :> _ := f;
      HomeomophismInverse : Y -> X;
      HomeomophismContinuous : continuous Tx Ty f;
      HomeomophismInverseContinuous : continuous Ty Tx HomeomophismInverse;
      HomeomorphismInverse1 : (fun x => HomeomophismInverse (HomeomorphismMap x)) = @id _;
      HomeomorphismInverse2 : (fun y => HomeomorphismMap (HomeomophismInverse y)) = @id _
    }.

  Record Homeomophic :=
    {
      Homeomophism1 : X -> Y;
      Homeomophic_Homeomorphism :> Homeomorphism Homeomophism1
    }.

  Lemma homemorphism_open_to_open f (H : Homeomorphism f) U : Open U -> Open (image f U).
  Proof.
    intro.
    destruct H; subst_body; unfold continuous in *; simpl in *.
    specialize_all_ways.
    unfold inverse_image in *.
    match goal with
      | [ H : Open ?A |- Open ?B ] => cut (A = B); [ let H := fresh in intro H; rewrite <- H; assumption | ]
    end.
    apply Extensionality_Ensembles; split; intro x; intro;
    unfold image, In in *; simpl in *;
    try match goal with
          | [ H : ?U ?x |- exists x0, ?U x0 /\ _ ] => (exists x)
        end;
    intuition;
    fg_equal;
    destruct_hypotheses; subst;
    try match goal with
          | [ H : _ |- _ ] => rewrite H; compute; trivial
        end.
  Qed.
End homeomorphic.

Section covers.
  Variable X : Type.
  Variable T : Topology X.

  Record Cover :=
    {
      CoverSets :> Ensemble (Ensemble X);
      Covers : ⋃ CoverSets = Full_set _
    }.

  Definition cover_open (C : Cover) := forall Xj, Xj ∈ C -> Open Xj.

  Definition subcover (C' C : Cover) := C' ⊆ C.

  Lemma open_subcover_open (C' C : Cover)
  : cover_open C -> subcover C' C -> cover_open C'.
  Proof.
    unfold cover_open in *;
    intuition.
  Qed.
End covers.

Section compact.
  Variable X : Type.
  Variable T : Topology X.

  Definition compact := forall Xj : Cover X, cover_open T Xj (* forall open covers *)
                                             -> exists Xj' : Cover X, Finite _ Xj' /\ subcover Xj' Xj. (* exists finite subcover *)
End compact.

Section hausdorff.
  Variable X : Type.
  Variable T : Topology X.

  Definition hausdorff := forall x y, x <> y ->
                                      exists Ux Uy,
                                        (Open Ux) /\ (Open Uy)
                                        /\ (In _ Ux x) /\ (In _ Uy y)
                                        /\ Disjoint _ Ux Uy.
End hausdorff.

Section disjoint_union.
  Variable X : Type.

  Record IsDisjointUnion (U : Ensemble X) := {
                                              DisjointUnionSets :> Ensemble (Ensemble X);
                                              DisjointUnionSetsDisjoint : forall A B,
                                                                            A <> B
                                                                            -> In _ DisjointUnionSets A -> In _ DisjointUnionSets B ->
                                                                            Disjoint _ A B;
                                              DisjointUnionIsUnion : ArbitraryUnion DisjointUnionSets = U
                                            }.

  Lemma disjoint_union_in (U : Ensemble X) (DU : IsDisjointUnion U) : forall (Ux : DU), Included _ (proj1_sig Ux) U.
  Proof.
    intros Ux x H;
    destruct_sig;
    simpl in *.
    let H := fresh in pose proof (DisjointUnionIsUnion DU) as H;
                     rewrite <- H.
    hnf.
    econstructor; unfold In in *; simpl in *; eassumption.
  Qed.
End disjoint_union.

Section covering_space.
  Variable X : Type.
  Variable T : Topology X.

  Record IsCoveringSpace (X' : Type) (T' : Topology X') (p : X' -> X) :=
    {
      CoveringSpaceMap_continuous : continuous _ _ p;
      CoveringSpace_Cover :> Cover X;
      CoveringSpace_CoverOpen : cover_open T CoveringSpace_Cover;
      CoveringSpace_InverseImageSets : CoveringSpace_Cover -> Ensemble (Ensemble X');
      CoveringSpace_InverseImageSets_DisjointUnion : forall U : CoveringSpace_Cover,
                                                       IsDisjointUnion (inverse_image p (proj1_sig U));
      CoveringSpaceHomeomorphism : forall U : CoveringSpace_Cover,
                                   forall DU : CoveringSpace_InverseImageSets_DisjointUnion U,
                                     let H := (fun (x : X') H0 => disjoint_union_in (CoveringSpace_InverseImageSets_DisjointUnion U) DU _ H0) in
                                     Homeomorphism (SubspaceTopology _ _) (SubspaceTopology _ _) (restrict p (proj1_sig DU) (proj1_sig U) H)
    }.

  Record CoveringSpace (X' : Type) (T' : Topology X') :=
    {
      CoveringSpaceMap :> X' -> X;
      CoveringSpace_IsCoveringSpace :> @IsCoveringSpace X' T' CoveringSpaceMap
    }.

  Local Notation "p ⁻¹" := (inverse_image p) (at level 10).

  Lemma covering_space_subset_open X' T' (C : @CoveringSpace X' T') (U : Ensemble X') (E : C) (p := CoveringSpaceMap C)
        (E' : DisjointUnionSets (CoveringSpace_InverseImageSets_DisjointUnion C E))
  : Included _ U (proj1_sig E') -> Open U -> Open (image p U).
  Proof.
    intros.
    destruct C as [ CoveringSpaceMap0 [] ]; simpl in *.
    specialize_all_ways;
      repeat match goal with
               | [ H : _ |- _ ] => progress change CoveringSpaceMap0 with p in H |- *
             end;
      change (fun a b => ?f a b) with f in *.
    match goal with
      | [ _ : context[restrict p ?A ?B ?C], H : Included _ ?U _ |- Open (image ?p ?U) ] =>
        pose (image (restrict p A B C) (include_subset H)) as pU;
          cut (Open pU); [ cut (image p U = subset_ensemble pU) | ]
    end.
    - let H0 := fresh in
      let H1 := fresh in simpl; intros H0 H1; destruct H1 as [ U0 H1 ];
                         rewrite H0; rewrite H1;
                         apply FiniteIntersectionOpen; simpl; eta_red;
                         unfold cover_open in *;
                         match goal with
                           | [ |- Open (proj1_sig ?U) ] => destruct U; simpl in *; intuition
                         end.
    - subst_body; simpl in *.
      apply Extensionality_Ensembles; split; intros ? ?; simpl in *.
      split; simpl; eta_red;
      specialize_all_ways.
      repeat match goal with
               | [ H : appcontext[Homeomorphism] |- _ ] => clear H
             end.
      pose (proj1_sig E).
      simpl in *.
      (*match goal with
        | [ H : Included _ ?U _ |- In _ ?V _ ] => cut (Included _ U V)
      end.

      match goal with
        | [ H : In _ (image ?f ?U) ?x |- In _ ?V ?x ] =>
          cut (exists x', In _ U x' /\ f x' = x);
            [ let H := fresh in intro H; destruct H as [ H [] ]; subst; simpl in * | ]
      end.
      destruct_head IsDisjointUnion.
      specialize_all_ways.
      unfold Included in *.
      pose (DisjointUnionIsUnion E').
      Print IsDisjointUnion.
      hnf in *;
        intuition.
      compute.
      trivial.
      hnf in U0.
      Print Topology.
      subst_body; simpl in *;
      unfold include_subset, subset_ensemble in *; simpl in *.
      unfold SubspaceTopol
             subst_body; simpl.
      match goal with
        | [ |- Open ?X -> Open ?Y ] => pose X; pose Y
      end.
      Print SubspaceTopology.
      unfold Open at 1.
      Set Printing All.
      Arguments Open X T _ : rename.
      Set Pri
          Print Open.
      Implicit Arguments Open [].
      Set Printing Coercions.
      intro.
      unfold include_subset, image, restrict; simpl.
      match goal with
        | [ H : Included _ U _ |- _ ] => pose (include_subset H)
      end.
      unfold restrict in *; simpl in *.
      hnf in e. *)
  Admitted.


  Lemma covering_space_open_to_open X' T' (C : @CoveringSpace X' T') (U : Ensemble X') (p := CoveringSpaceMap C)
  : Open U -> Open (image p U).
  Proof.
    intros.

  Admitted.


  Lemma covering_space_inverse_image_open X' T' (C : @CoveringSpace X' T') (U : Ensemble X) (p := CoveringSpaceMap C)
  : Open U -> Open (p ⁻¹ U).
  Proof.
    intro.
    pose (CoveringSpaceHomeomorphism C).
  Admitted.
End covering_space.

Section intersection_lemmas.
  Variable X : Type.

  Lemma IntersectionAAA (A : Ensemble X) : Intersection _ A A = A.
  Proof.
    apply Extensionality_Ensembles; split; intros x H; destruct_head_hnf Intersection; try constructor; trivial.
  Qed.
End intersection_lemmas.

Section intersection_cover.
  Variable X : Type.
  Variable T : Topology X.
  Variables C C' : Cover X.

  Definition IntersectionCover : Cover X.
    exists (PairwiseIntersection C C').
    abstract (
        rewrite intersection_arbitrary_union_commute;
        repeat rewrite Covers;
        rewrite IntersectionAAA;
        reflexivity
      ).
  Defined.

  Lemma IntersectionCover_open : cover_open _ C -> cover_open _ C' -> cover_open _ IntersectionCover.
  Proof.
    intros; hnf in *; intros; hnf in * |- .
    destruct_head_hnf PairwiseIntersection.
    apply FiniteIntersectionOpen;
      match goal with
        | [ H : _ |- _ ] => apply H; assumption
      end.
  Qed.
End intersection_cover.
(*
Section p16.
  Variables X Y Z : Type.
  Variable Tx : Topology X.
  Variable Ty : Topology Y.
  Variable Tz : Topology Z.

  Variable f : X -> Y.
  Variable g : Y -> Z.
  Let gf := (fun x => g (f x)).

  Hypothesis YZ_is_covering_space : IsCoveringSpace _ _ g.
  Hypothesis XZ_is_covering_space : IsCoveringSpace _ _ gf.

  Local Notation "p ⁻¹" := (inverse_map p) (at level 1).

  Lemma XY_is_covering_space : IsCoveringSpace _ _ f.
  Proof.
    refine {|
        CoveringSpaceMap_continuous := (_ : continuous _ _ f);
        CoveringSpace_Cover := (_ : Cover Y);
        CoveringSpace_CoverOpen := _ (* cover_open T CoveringSpace_Cover;*);
        CoveringSpace_InverseImageSets := _ (* CoveringSpace_Cover ->
                                     Ensemble (Ensemble X');*);
        CoveringSpace_InverseImageSets_DisjointUnion := _ (*
    forall U : CoveringSpace_Cover,
    IsDisjointUnion (inverse_image p (proj1_sig U));*);
        CoveringSpaceHomeomorphism := _(* forall (U : CoveringSpace_Cover)
                                   (DU : CoveringSpace_InverseImageSets_DisjointUnion
                                           U),
                                 let H :=
                                   fun (x : X') (H0 : In X' (proj1_sig DU) x) =>
                                   disjoint_union_in
                                     (CoveringSpace_InverseImageSets_DisjointUnion
                                        U) DU x H0 in
                                 Homeomorphism
                                   (SubspaceTopology T'
                                      (fun x : X' => proj1_sig DU x))
                                   (SubspaceTopology T
                                      (fun y : X => proj1_sig U y))
                                   (restrict p (proj1_sig DU) (proj1_sig U) H)*)
      |}.
    intros Uy Uy_open; pose (image g Uy) as Uz.
    repeat match goal with
             | [ C : _ |- _ ] => unique_pose (CoveringSpaceMap_continuous C Uz)
           end.

    subst_body; unfold inverse_image, image in *; simpl in *.
    hnf in *.
    repeat match goal
                   destruct YZ_is_covering_space, XZ_is_covering_space.
End p16.

Section p3.
  Variables X X' : Type.
  Variable T : Topology X.
  Variable T' : Topology X'.

  Variable p : CoveringSpace T T'.

  Let p_continuous :=  CoveringSpaceMap_continuous p.

  Local Notation "p⁻¹" := (inverse_map p) (at level 0).

  Hypothesis all_finite : forall x, Finite _ ((inverse_map p) x).

  Hypothesis all_nonempty : forall x, Inhabited _ (p⁻¹ x).

  Hypothesis eq_dec_X : forall x y : X, {x = y} + {x <> y}.
  Hypothesis eq_dec_X' : forall x y : X', {x = y} + {x <> y}.

  Lemma p3h_only_if : compact T /\ hausdorff T -> hausdorff T'.
  Proof.
    intro H; destruct H as [ T_compact T_hausdorff ].
    move T_compact at top.
    hnf in *.
    intros x y x_ne_y.
    specialize (T_hausdorff (p x) (p y)).
    destruct (eq_dec_X (p x) (p y)) as [ px_py_eq | px_py_neq ].
    - clear T_hausdorff.
      pose (CoveringSpace_InverseImageSets_DisjointUnion p) as DU.
      pose (Covers (CoveringSpace_Cover p)) as C.
      fg_equal_in C.
      specialize (C (p x)).
      assert (U_contains_px : ArbitraryUnion p (p x)) by (rewrite C; constructor).
      assert (In _ (inverse_map p (p x)) x) by reflexivity.
      assert (In _ (inverse_map p (p x)) y) by (rewrite px_py_eq; reflexivity).
      destruct U_contains_px as [ U px U_in_cover U_contains_px ].
      specialize (DU (exist _ U U_in_cover)).
      admit.
    - specialize (T_hausdorff px_py_neq).
      destruct T_hausdorff as [ Upx [ Upy H ] ].
      destruct_hypotheses.
      exists (inverse_image p Upx); exists (inverse_image p Upy);
      repeat split;
      try match goal with
            | [ H : _ |- _ ] => solve [ apply H; trivial ]
          end;
      destruct_head Disjoint.
      intro x0; intro; destruct_head_hnf Intersection;
      repeat match goal with
               | [ H : _ |- _ ] => specialize (H (p x0));
                                  match type of H with
                                    | ~?X => cut X; [
                                              let H' := fresh in intro H'; specialize (H H'); assumption
                                            | ]
                                  end
             end.
      hnf in *; constructor; hnf; assumption.
  Qed.

  intro x0.

  pose (p x0) as px0; cut (In _ (Intersection _ Upx Upy) px0);
  [ let H := fresh in intro H; destruct_head Disjoint; specialize_all_ways; exfalso; assumption | subst_body ].
  constructor.
  split; try match goal with
               | [ H : _ |- _ ] => solve [ apply H; trivial ]
             end.
  Print ArbitraryUnion.
  destruct U_contains_px as [ U px U_in_cover U_contains_px ].
  Print Full_set.
  apply (fg_equal (p x)) in C.
  unfold Full_set in *.
  Print Cover.
  Print CoveringSpace.
  pose (inverse_map p x) as x'_0; pose (inverse_map p y) as y'_0.

(*
  Lemma p3_if : compact T /\ hausdorff T -> compact T' /\ hausdorff T'.
  Proof.
    intro H; destruct H as [ T_compact T_hausdorff ]; split.
    - hnf in *.
      intro X'_cover.
      intro X'_cover_open.
      clear T_hausdorff.
      hnf in X'_cover_open.
      pose ((fun U => CoverSets X'_cover (inverse_image p U)) : Ensemble _) as X_cover_sets.
      let T0 := fresh in evar (T0 : Type); evar (X_cover_is_cover : T0); subst T0;
                         pose {| CoverSets := X_cover_sets; Covers := X_cover_is_cover |} as X_cover_0.
      pose (IntersectionCover (CoveringSpace_Cover p) X_cover_0) as X_cover.
      assert (X_cover_is_open : cover_open _ X_cover); [ apply IntersectionCover_open | ];
      [ destruct p; simpl; assumption | | ].
      + hnf; intros U U_in_cover.
        subst_body; unfold In in *; simpl in *.
        specialize (X'_cover_open _ U_in_cover).
        pose proof (covering_space_open_to_open p (inverse_image p U)); simpl in *.

        Print CoveringSpace.
        pose proof (homemorphism_open_to_open p).
        Print Cover.
        eta_red.
        hnf in U_in_cover.
        pose (
        eapply X'_cover_open.
        pose (



      pose proof (T_compact X_cover) as X_finite_cover.
                         let t := type of X_cover_is_cover in assert t.
                         match type of
                         pose (
      refine (ex_intro _ ({| CoverSets := X_cover_
      Print Cover.
    clear T_hausdorff.
    intro X'_cover.
  Admitted.

  Lemma p3_only_if : compact T' /\ hausdorff T' -> compact T /\ hausdorff T.
  Proof.
    intro H; destruct H as [ T'_compact T'_hausdorff ]; split.
  Admitted. *)
End p3.

Section p8.

End p8.

*)
