(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Setoid Utf8.
Require Import ProofIrrelevance.
Require Import ZArith Omega.
Require Import Common Orders.

Set Implicit Arguments.

Generalizable All Variables.

(** ------------------------------------------------------------------------ *)
(** * Exercise 3.4.1.8 *)
Section Exercise_3_4_1_8.
  (** ** Problem *)
  (** List all the preorder relations possible on the set [{1, 2}].

      For any [n ∈ ℕ], how many linear orders exist on the set [{1, 2,
      3, ..., n}]. Does your formula work when [n = 0]? *)
  (** ** Solution *)
  (** All preorder relations contain [(x, x)] for all [x].  Then we
      can either have the relations
      - [{(1, 1), (2, 2)}]
      - [{(1, 1), (2, 2), (1, 2)}]
      - [{(1, 1), (2, 2), (2, 1)]}
      - [{(1, 1), (2, 2), (1, 2), (2, 1)}]

      A linear order on a finite set is just a permutation on that
      set.  So there are [n!] linear orders in [{1, 2, ..., n}].  My
      formula works for 0; 0! = 1 is the number of trivial orders on
      [{}] *)

  Let finite_set n := { m | 1 <= m <= n }.

  (** Define a function for going from relations on natural numbers to
      relations on finite sets. *)
  Let finite_set_relation n : Relation_Definitions.relation ℕ -> Relation_Definitions.relation (finite_set n)
    := fun r => (fun x y => r (proj1_sig x) (proj1_sig y)).

  Local Ltac t :=
    unfold finite_set, finite_set_relation;
    repeat match goal with
             | _ => split
             | _ => progress (compute in *; subst)
             | _ => progress trivial
             | _ => progress intuition
             | _ => intro
             | [ H : sig _ |- _ ] => destruct H
             | _ => apply proof_irrelevance
             | _ => omega
             | _ => apply f_equal
           end.

  Example Exercise_3_4_1_8_R1 : Relation_Definitions.relation (finite_set 2) :=
    finite_set_relation (@eq ℕ).
  Example Exercise_3_4_1_8_R2 : Relation_Definitions.relation (finite_set 2) :=
    finite_set_relation (fun x y => x ≤ y).
  Example Exercise_3_4_1_8_R3 : Relation_Definitions.relation (finite_set 2) :=
    finite_set_relation (fun x y => y ≤ x).
  Example Exercise_3_4_1_8_R4 : Relation_Definitions.relation (finite_set 2) :=
    fun _ _ => True.

  Example Exercise_3_4_1_8_R1_preorder : PreOrder Exercise_3_4_1_8_R1.
  Proof. t. Qed.
  Example Exercise_3_4_1_8_R2_preorder : PreOrder Exercise_3_4_1_8_R2.
  Proof. t. Qed.
  Example Exercise_3_4_1_8_R3_preorder : PreOrder Exercise_3_4_1_8_R3.
  Proof. t. Qed.
  Example Exercise_3_4_1_8_R4_preorder : PreOrder Exercise_3_4_1_8_R4.
  Proof. t. Qed.

  (** It's non-trivial to prove that these are the only ones, so I
       will not do it.  It's also non-trivial to construct a linear
       order given a relation; the basic idea is to repeatedly find
       lower bounds. *)
(*
  Example Exercise_3_4_1_8_R_all (R : Relation_Definitions.relation (finite_set 2))
          (R_dec : forall x y, {R x y} + {¬R x y})
          (H : PreOrder R) :
    Same_relation R Exercise_3_4_1_8_R1
    \/ Same_relation R Exercise_3_4_1_8_R2
    \/ Same_relation R Exercise_3_4_1_8_R3
    \/ Same_relation R Exercise_3_4_1_8_R4.
  Proof.
    assert (S1 : 1 <= 1 <= 2) by omega.
    assert (S2 : 1 <= 2 <= 2) by omega.
    pose (exist _ 1 S1 : finite_set 2) as s1.
    pose (exist _ 2 S2 : finite_set 2) as s2.
    Ltac t'0 tac := repeat match goal with
                             | [ H0 : _, H : ?R ?a ?a -> False |- _ ] => case (H (H0 a))
                             | _ => progress (compute in *; tac)
                             | _ => intro
                             | _ => omega
                             | [ H : sig _ |- _ ] => destruct H
                             | [ H : ?P, H' : ?P |- _ ] => assert (H = H') by (apply proof_irrelevance);
                                                          subst H'
                           end.
    Ltac t' tac :=
      repeat match goal with
               | _ => progress t'0 tac
               | [ n : ℕ |- _ ] => match goal with
                                     | [ H : context[S (S (S n))] |- _ ] => fail 1
                                     | [ |- context[S (S (S n))] ] => fail 1
                                     | _ => destruct n
                                   end
             end.
    destruct (R_dec s1 s1), (R_dec s1 s2), (R_dec s2 s1), (R_dec s2 s2); clear R_dec;
    destruct H;
    t'0 idtac.
    Ltac t''' :=
      match goal with
        | [ |- _ \/ _ ] => right; solve [ t''' ]
        | [ |- _ \/ _ ] => left; solve [ t''' ]
        | [ |- _ \/ _ ] => idtac
        | _ => t' intuition
      end.
    Ltac t'' :=
      hnf;
      t'0 idtac;
      t'''.
    t''.
    right.
    left.
    t'0 intuition.
    do 2 match goal with
           | [ n : ℕ |- _ ] => match goal with
                                 | [ H : context[S (S (S n))] |- _ ] => fail 1
                                 | [ |- context[S (S (S n))] ] => fail 1
                                 | _ => destruct n
                               end;
                              try omega
         end.

    t''.
    t''.
    |
    repeat right; t' intuition.
    t' idtac.
    hnf in *;
      match goal with
        | [ H : _ -> False |- _ ] => solve [ exfalso; firstorder ]
      end.
    intuition.
    firstorder
    t'.
    match goal with | [ n : ℕ |- _ ] => destruct n end; t'.
    match goal with | [ n : ℕ |- _ ] => destruct n end; t'.
    match goal with | [ n : ℕ |- _ ] => destruct n end; t'.
    match goal with | [ n : ℕ |- _ ] => destruct n end; t'.
    match goal with | [ n : ℕ |- _ ] => destruct n end; t'.
    match goal with | [ n : ℕ |- _ ] => destruct n end; t'.
    match goal with | [ n : ℕ |- _ ] => destruct n end; t'.
    match goal with | [ n : ℕ |- _ ] => destruct n end; t'.
    Ltac t'' :=
      hnf;
      match goal with
        | [ |- _ \/ _ ] => left; solve [ t'' ]
        | [ |- _ \/ _ ] => right; solve [ t'' ]
        | [ |- _ \/ _ ] => idtac
        | _ => t'
      end.
    t''.
    t''.
    t'.
    do 6 match goal with
           | [ n : ℕ |- _ ] => repeat match goal with
                                        | [ H : context[n] |- _ ] => revert H
                                      end;
                              destruct n; t'
         end.

    destruct a.
    destruct l0.
    destruct l.
    case l.
    repeat intro; . compute in *; repeat into
    intros [? ?] [? ?].
      split;
      intro;
      compute in *;
      trivial.
    revert a a0.
    refine match x with
             | 0 => _
             | 1 => _
             | 2 => _
             | S (S (S x)) => _
           end;
    refine match x0 with
             | 0 => _
             | 1 => _
             | 2 => _
             | S (S (S x0)) => _
           end;
      intuition; try omega.
      do 3 match goal with
             | [ H : ℕ |- _ ] => destruct H; compute in *; trivial; try omega
           end.
    destruct x; try omega; trivial.
    destruct x; try omega.
    destruct x; try omega.
    destruct x0; try omega.
    destruct x0; try omega.
    apply

    solve [ t ].
    solve [ t ].

    solve [ t ].
    unfold Exercise_3_4_1_8_R4.
    destruct (R (exist _ 1 S1));
    destruct (R
 *)
End Exercise_3_4_1_8.

(** ------------------------------------------------------------------------ *)
