(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Setoid JMeq.
Require Import Common.
Require Export Isomorphism.

Set Implicit Arguments.

Generalizable All Variables.

Section univ_prod.
  Variables X Y : Type.

  (** Define products by the universal property *)
  Record product_type :=
    {
      prodXY :> Type;
      prod_fst : prodXY -> X;
      prod_snd : prodXY -> Y;
      prod_map : forall A (f : A -> X) (g : A -> Y), A -> prodXY;
      prod_fst_commutes_prop := (fun A f g prod_map =>
                                   forall x,
                                     (prod_fst o prod_map) x = f x);
      prod_snd_commutes_prop := (fun A f g prod_map =>
                                   forall x,
                                     (prod_snd o prod_map) x = g x);
      prod_fst_commutes : forall A f g,
                            prod_fst_commutes_prop A f g (@prod_map A f g);
      prod_snd_commutes : forall A f g,
                            prod_snd_commutes_prop A f g (@prod_map A f g);
      prod_map_unique : forall A f g prod_map',
                          prod_fst_commutes_prop A f g prod_map'
                          -> prod_snd_commutes_prop A f g prod_map'
                          -> forall x, prod_map' x = (prod_map f g) x
    }.

  Existing Class product_type.

  Definition product := { p : product_type & p }.
  Definition product_element (p : product) := projT2 p.
  Definition product_of `(p : product_type) (x : p) : product := existT _ p x.
  Global Coercion product_element : product >-> prodXY.
  Global Coercion product_of : prodXY >-> product.
End univ_prod.

Delimit Scope product_scope with product.
Bind Scope product_scope with prodXY.

Arguments prod_fst_commutes_prop _ _ _ _ _ _ _ / .
Arguments prod_snd_commutes_prop _ _ _ _ _ _ _ / .

Infix "×" := product : type_scope.
Infix "×" := product : product_type_scope.
Infix "×" := (fun a b =>
                @prod_map _ _ _ unit (fun _ => a) (fun _ => b) tt) : product_scope.
Infix "×" := prod : old_type_scope.

Notation "'π₁'" := (@prod_fst _ _ _).
Notation "'π₂'" := (@prod_snd _ _ _).

Delimit Scope category_scope with category.
Delimit Scope old_scope with old_type.

Section swap.
  (** Define swap via the universal property; note that the object
  type doesn't change, but the projection maps are switched.  This is
  because the objects are truely opaque. *)

  Definition swap_types X Y : product_type X Y -> product_type Y X :=
    fun xy =>
      {|
        prodXY := prodXY xy;
        prod_fst := prod_snd xy;
        prod_snd := prod_fst xy;
        prod_map := (fun _ f g => prod_map xy g f);
        prod_fst_commutes := (fun _ f g => prod_snd_commutes xy g f);
        prod_snd_commutes := (fun _ f g => prod_fst_commutes xy g f);
        prod_map_unique := (fun _ _ _ _ Hfst Hsnd => prod_map_unique Hsnd Hfst)
      |}.

  (** We must have [swap_types] in the environment for type class
      resolution to pick it up.  Use [Eval simpl] so that it doesn't
      stick around. *)
  Definition swap X Y : X × Y -> Y × X
    := Eval simpl in
        fun xy => let s := swap_types (projT1 xy) in
                  (π₂ xy × π₁ xy)%product.

  (** Prove that [swap_types] is an isomorphism; its inverse is [swap_types] *)
  Definition swap_types_iso X Y : is_isomorphism (@swap_types X Y).
  Proof.
    exists (@swap_types _ _);
    abstract (
        repeat intro;
        destruct_head_hnf @product_type;
        reflexivity
      ).
  Defined.

  (** Prove that [swap] is an isomorphism; its inverse is [swap] *)
  Definition swap_iso X Y : is_isomorphism (@swap X Y).
  Proof.
    exists (@swap _ _);
    abstract (
        repeat intro; simpl; unfold swap, swap_types; simpl;
        destruct_head_hnf @sigT;
        destruct_head_hnf @product_type;
        simpl in *;
        simpl_eq; simpl;
        trivial;
        symmetry;
        repeat match goal with
                 | [ |- JMeq ?a ?b ] => (cut (a = b);
                                         [ let H := fresh in
                                           intro H;
                                             solve [ rewrite <- H; reflexivity
                                                   | rewrite H; reflexivity ]
                                         | ])
                 | [ H : _ |- _ ] => rewrite H
                 | [ x : _, H : _ |- _ ] => (eapply (H _ _ _ (fun _ : unit => x));
                                             hnf;
                                             trivial)
               end
      ).
  Defined.
End swap.
