(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing ≄ %\ensuremath{\not\simeq}% #&#8772;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
(** printing ℙ %\ensuremath{\mathbb{P}}% #&#x2119;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ▻ %\ensuremath{\triangleright}% #&#x25BB;# *)
(** printing ◅ %\ensuremath{\triangleleft}% #&#x25C5;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Export Category Functor.
Require Import Common Notations.

Set Implicit Arguments.

Generalizable All Variables.

Local Open Scope morphism_scope.

(** * Cones *)
(** ** Left Cone *)
(** The left cone [C◅] of a category [C] is [C], together with a
    freely adjoined initial object. *)

Local Ltac t_left_cone :=
  repeat (intros [[]|?] || intros [] || intro);
  simpl;
  subst_eq_refl_in_match;
  autorewrite with morphism;
  repeat rewrite FCompositionOf;
  repeat rewrite FIdentityOf;
  try reflexivity.

Section left_cone_category.
  Context `(C : @Category objC).
  Let obj := unit ⊔ objC.
  Definition LeftCone_Morphism (s d : obj) :=
    match s, d return Type with
      | inl tt, _ => unit
      | _, inl tt => ∅
      | inr s', inr d' => Morphism C s' d'
    end.
  Definition LeftCone_Identity (x : obj) : LeftCone_Morphism x x :=
    match x with
      | inl tt => tt
      | inr x' => Identity x'
    end.
  Definition LeftCone_Compose (s d d' : obj)
  : LeftCone_Morphism d d' -> LeftCone_Morphism s d -> LeftCone_Morphism s d'
    := match s as s, d as d, d' as d'
             return LeftCone_Morphism d d' -> LeftCone_Morphism s d -> LeftCone_Morphism s d'
       with
         | inr s0, inr d0, inr d'0_ => fun m1 m2 => m1 o m2
         | inl tt, _, _ => fun _ _ => tt
         | inr _, inl tt, _ => fun _ m => match m with end
         | _, inr _, inl tt => fun m _ => match m with end
       end.

  Definition LeftCone : @Category obj.
    refine {| Morphism := LeftCone_Morphism;
              Identity := LeftCone_Identity;
              Compose := LeftCone_Compose |};
    abstract t_left_cone.
  Defined.
End left_cone_category.

Notation "C ◅" := (LeftCone C) (at level 10) : category_scope.

Section left_cone_morphism_of.
  Context `(C : @Category objC).
  Context `(D : @Category objD).
  Variable F : Functor C D.

  Definition LeftCone_MorphismOf : Functor (C ◅) (D ◅).
    refine {| ObjectOf := (fun x => match x with
                                      | inl tt => inl tt
                                      | inr x' => inr (F x')
                                    end);
              MorphismOf := (fun s d => match s as s, d as d
                                              return Morphism (C ◅) s d
                                                     ->  Morphism (D ◅) (_ s) (_ d) with
                                          | inr s', inr d' => MorphismOf F (s := s') (d := d')
                                          | inl tt, _ => fun _ => tt
                                          | inr _, inl tt => fun m => match m with end
                                        end) |};
    abstract t_left_cone.
  Defined.
End left_cone_morphism_of.

Notation "F ◅" := (LeftCone_MorphismOf F) (at level 10) : functor_scope.

Section left_cone_f_identity_of.
  Context `(C : @Category objC).

  Local Open Scope functor_scope.

  Lemma LeftCone_FIdentityOf : (IdentityFunctor C) ◅ = IdentityFunctor (C ◅).
    apply Functor_Eq;
    t_left_cone.
  Qed.
End left_cone_f_identity_of.

Section left_cone_f_composition_of.
  Context `(C : @Category objC).
  Context `(D : @Category objD).
  Context `(E : @Category objE).
  Variable F : Functor D E.
  Variable G : Functor C D.

  Local Open Scope functor_scope.

  Lemma LeftCone_FCompositionOf : (F o G) ◅ = (F ◅) o (G ◅).
    apply Functor_Eq;
    t_left_cone.
  Qed.
End left_cone_f_composition_of.




(** ** Right Cone *)
(** The right cone [C▻] of a category [C] is [C], together with a
    freely adjoined terminal object. *)

Local Ltac t_right_cone :=
  repeat (intros [?|[]] || intros [] || intro);
  simpl;
  subst_eq_refl_in_match;
  autorewrite with morphism;
  repeat rewrite FCompositionOf;
  repeat rewrite FIdentityOf;
  try reflexivity.

Section right_cone_category.
  Context `(C : @Category objC).
  Let obj := objC ⊔ unit.
  Definition RightCone_Morphism (s d : obj) :=
    match s, d return Type with
      | _, inr tt => unit
      | inr tt, inl _ => ∅
      | inl s', inl d' => Morphism C s' d'
    end.
  Definition RightCone_Identity (x : obj) : RightCone_Morphism x x :=
    match x as x return RightCone_Morphism x x with
      | inr tt => tt
      | inl x' => Identity x'
    end.
  Definition RightCone_Compose (s d d' : obj)
  : RightCone_Morphism d d' -> RightCone_Morphism s d -> RightCone_Morphism s d'
    := match s as s, d as d, d' as d'
             return RightCone_Morphism d d' -> RightCone_Morphism s d -> RightCone_Morphism s d'
       with
         | inl s0, inl d0, inl d'0 => fun m1 m2 => m1 o m2
         | _, _, inr tt => fun _ _ => tt
         | _, inr tt, inl _ => fun m _ => match m with end
         | inr tt, inl _, _ => fun _ m => match m with end
       end.

  Definition RightCone : @Category obj.
    refine {| Morphism := RightCone_Morphism;
              Identity := RightCone_Identity;
              Compose := RightCone_Compose |};
    abstract t_right_cone.
  Defined.
End right_cone_category.

Notation "C ▻" := (RightCone C) (at level 10) : category_scope.

Section right_cone_morphism_of.
  Context `(C : @Category objC).
  Context `(D : @Category objD).
  Variable F : Functor C D.

  Definition RightCone_MorphismOf : Functor (C ▻) (D ▻).
    refine {| ObjectOf := (fun x => match x with
                                      | inr tt => inr tt
                                      | inl x' => inl (F x')
                                    end);
              MorphismOf := (fun s d => match s as s, d as d
                                              return Morphism (C ▻) s d
                                                     ->  Morphism (D ▻) (_ s) (_ d) with
                                          | inl s', inl d' => MorphismOf F (s := s') (d := d')
                                          | _, inr tt => fun _ => tt
                                          | inr tt, inl _ => fun m => match m with end
                                        end) |};
    abstract t_right_cone.
  Defined.
End right_cone_morphism_of.

Notation "F ▻" := (RightCone_MorphismOf F) (at level 10) : functor_scope.

Section right_cone_f_identity_of.
  Context `(C : @Category objC).

  Local Open Scope functor_scope.

  Lemma RightCone_FIdentityOf : (IdentityFunctor C) ▻ = IdentityFunctor (C ▻).
    apply Functor_Eq;
    t_right_cone.
  Qed.
End right_cone_f_identity_of.

Section right_cone_f_composition_of.
  Context `(C : @Category objC).
  Context `(D : @Category objD).
  Context `(E : @Category objE).
  Variable F : Functor D E.
  Variable G : Functor C D.

  Local Open Scope functor_scope.

  Lemma RightCone_FCompositionOf : (F o G) ▻ = (F ▻) o (G ▻).
    apply Functor_Eq;
    t_right_cone.
  Qed.
End right_cone_f_composition_of.
