(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import Setoid Eqdep.
Require Export Path.
Require Import Common.

Set Implicit Arguments.

Generalizable All Variables.

(** * Schemas *)

Record Schema :=
  {
    SVertex :> Type;
    SEdge : SVertex -> SVertex -> Type;

    PathsEquivalent : forall s d, Relation_Definitions.relation (path SEdge s d);
    PathsEquivalent_Equivalence : forall s d, equivalence _ (@PathsEquivalent s d);

    PreCompose : forall s d (E : SEdge s d) d' (p1 p2 : path _ d d'),
                   PathsEquivalent p1 p2 -> PathsEquivalent (prepend p1 E) (prepend p2 E);
    PostCompose : forall s d (p1 p2 : path _ s d) d' (E : SEdge d d'),
                    PathsEquivalent p1 p2 -> PathsEquivalent (AddEdge p1 E) (AddEdge p2 E)
  }.

Hint Resolve PreCompose PostCompose.

Theorem PreCompose' : forall S s d (E : S.(SEdge) s d) d' (p1 p2 : path _ d d'),
  PathsEquivalent _ p1 p2 -> PathsEquivalent _ (prepend p1 E) (prepend p2 E).
  intros; auto.
Qed.

Theorem PostCompose' : forall S s d (p1 p2 : path _ s d) d' (E : S.(SEdge) d d'),
  PathsEquivalent _ p1 p2
  -> PathsEquivalent _ (AddEdge p1 E) (AddEdge p2 E).
  intros; auto.
Qed.

Hint Resolve PreCompose' PostCompose'.

Add Parametric Relation S s d : _ (@PathsEquivalent S s d)
  reflexivity proved by (equiv_refl _ _ (@PathsEquivalent_Equivalence _ _ _))
  symmetry proved by (equiv_sym _ _ (@PathsEquivalent_Equivalence _ _ _))
  transitivity proved by (equiv_trans _ _ (@PathsEquivalent_Equivalence _ _ _))
    as paths_eq.

Hint Resolve paths_eq_Reflexive paths_eq_Symmetric.

(* It's not true that [(p1 = p2 -> p3 = p4) -> (PathsEquivalent p1 p2 -> PathsEquivalent p3 p4)]
   Consider a case where p1 = NoEdges and p2 is a path containing an edge and its inverse,
   and p3 and p4 are not equivalent paths.

   So, let's do the relevant theorems again... *)
Section path_Equivalence_Theorems.
  Variable S : Schema.

  Lemma addedge_equivalent : forall s d d' (p p' : path _ s d), PathsEquivalent S p p'
    -> forall e : SEdge _ d d', PathsEquivalent S (AddEdge p e) (AddEdge p' e).
    t.
  Qed.

  Lemma prepend_equivalent : forall s' s d (p p' : path _ s d), PathsEquivalent S p p'
    -> forall e : SEdge _ s' s, PathsEquivalent S (prepend p e) (prepend p' e).
    t.
  Qed.

  Hint Rewrite concatenate_noedges_p concatenate_p_addedge.
  Hint Rewrite <- concatenate_concatenate'_equivalent.
  Hint Resolve prepend_equivalent addedge_equivalent.

  Lemma pre_concatenate_equivalent : forall s' s d (p1 : path _ s' s) (p p' : path _ s d),
    PathsEquivalent S p p' -> PathsEquivalent S (concatenate p1 p) (concatenate p1 p').
    induction p1; t.
    repeat rewrite concatenate_concatenate'_equivalent.
    t.
  Qed.

  Lemma post_concatenate_equivalent : forall s d d' (p p' : path _ s d) (p2 : path _ d d'),
    PathsEquivalent S p p' -> PathsEquivalent S (concatenate p p2) (concatenate p' p2).
    induction p2; t.
  Qed.

  Hint Resolve pre_concatenate_equivalent post_concatenate_equivalent.

  Add Parametric Morphism s d d' p:
    (@concatenate _ S.(SEdge) s d d' p)
    with signature (@PathsEquivalent S _ _) ==> (@PathsEquivalent S _ _) as concatenate_pre_mor.
    t.
  Qed.

  Add Parametric Morphism s d d' p:
    (fun p' => (@concatenate _ S.(SEdge) s d d' p' p))
    with signature (@PathsEquivalent S _ _) ==> (@PathsEquivalent S _ _) as concatenate_post_mor.
    t.
  Qed.

  Lemma concatenate_equivalent : forall s d d' (p1 p1' : path _ s d) (p2 p2' : path _ d d'),
    PathsEquivalent S p1 p1' -> PathsEquivalent S p2 p2' -> PathsEquivalent S (concatenate p1 p2) (concatenate p1' p2').
    t; etransitivity; eauto.
  Qed.
End path_Equivalence_Theorems.

Hint Resolve concatenate_equivalent.

Add Parametric Morphism S s d d' :
  (@concatenate _ S.(SEdge) s d d')
  with signature (@PathsEquivalent S _ _) ==> (@PathsEquivalent S _ _) ==> (@PathsEquivalent S _ _) as concatenate_mor.
  t.
Qed.

Add Parametric Morphism S s d d' :
  (@AddEdge S _ s d d')
  with signature (@PathsEquivalent S _ _) ==> (@eq _) ==> (@PathsEquivalent S _ _) as AddEdge_mor.
  t.
Qed.

Add Parametric Morphism S s d d' :
  (fun p => @concatenate' S _ s d p d')
  with signature (@PathsEquivalent S _ _) ==> (@PathsEquivalent S _ _) ==> (@PathsEquivalent S _ _) as concatenate'_mor.
  intros; repeat rewrite <- concatenate_concatenate'_equivalent; t.
Qed.

Add Parametric Morphism S s' s d :
  (fun p => @prepend S _ s d p s')
  with signature (@PathsEquivalent S _ _) ==> (@eq _) ==> (@PathsEquivalent S _ _) as prepend_mor.
  t.
Qed.

Section Schema.
  Variable C : Schema.

  (* Quoting Wikipedia,
    In category theory, an epimorphism (also called an epic
    morphism or, colloquially, an epi) is a morphism [f : X → Y]
    which is right-cancellative in the sense that, for all
    morphisms [g, g' : Y → Z],
    [g ○ f = g' ○ f -> g = g']

    Epimorphisms are analogues of surjective functions, but they
    are not exactly the same. The dual of an epimorphism is a
    monomorphism (i.e. an epimorphism in a category [C] is a
    monomorphism in the dual category [OppositeCategory C]).
    *)
  Definition SEpimorphism x y (p : path (SEdge C) x y) : Prop :=
    forall z (p1 p2 : path (SEdge C) y z), PathsEquivalent _ (concatenate p p1) (concatenate p p2) ->
      PathsEquivalent _ p1 p2.
  Definition SMonomorphism x y (p : path (SEdge C) x y) : Prop :=
    forall z (p1 p2 : path (SEdge C) z x), PathsEquivalent _ (concatenate p1 p) (concatenate p2 p) ->
      PathsEquivalent _ p1 p2.

  (* [m'] is the inverse of [m] if both compositions are
     equivalent to the relevant identity morphisms. *)
  Definition SInverseOf s d (p : path (SEdge C) s d) (p' : path (SEdge C) d s) : Prop :=
    PathsEquivalent _ (concatenate p p') NoEdges /\
    PathsEquivalent _ (concatenate p' p) NoEdges.

  Lemma SInverseOf_sym s d m m' : @SInverseOf s d m m' -> @SInverseOf d s m' m.
    firstorder.
  Qed.

  (* A morphism is an isomorphism if it has an inverse *)
  Definition SchemaIsomorphism' s d (p : path (SEdge C) s d) : Prop :=
    exists p', SInverseOf p p'.

  Definition SchemaIsomorphism s d (p : path (SEdge C) s d) := { p' | SInverseOf p p' }.

  Hint Unfold SInverseOf SchemaIsomorphism' SchemaIsomorphism.

  Lemma SInverseOf1 : forall (s d : C) (p : _ s d) p', SInverseOf p p'
    -> PathsEquivalent _ (concatenate p p') NoEdges.
    firstorder.
  Qed.

  Lemma SInverseOf2 : forall (s d : C) (p : _ s d) p', SInverseOf p p'
    -> PathsEquivalent _ (concatenate p p') NoEdges.
    firstorder.
  Qed.

  Lemma SchemaIsomorphism2Isomorphism' s d (p : path (SEdge C) s d) : SchemaIsomorphism p -> SchemaIsomorphism' p.
    firstorder.
  Qed.

  Hint Rewrite <- SInverseOf1 SInverseOf2 using assumption.

  (* XXX TODO: Automate this better. *)
  Lemma s_iso_is_epi s d (p : path (SEdge C) s d) : SchemaIsomorphism p -> SEpimorphism p.
    destruct 1 as [ x [ i0 i1 ] ]; intros z p1 p2 e.
    transitivity (concatenate (concatenate x p) p1). t_con @PathsEquivalent.
    transitivity (concatenate (concatenate x p) p2); repeat rewrite concatenate_associative; t_con @PathsEquivalent;
      repeat rewrite <- concatenate_associative; t_con @PathsEquivalent.
  Qed.

  Lemma SInverseOf1' : forall x y z (p : path (SEdge C) x y) (p' : path (SEdge C) y x) (p'' : path (SEdge C) z _),
    SInverseOf p p'
    -> PathsEquivalent _ (concatenate (concatenate p'' p) p') p''.
    unfold SInverseOf; intros; destruct_hypotheses; repeat rewrite concatenate_associative; t_con @PathsEquivalent.
  Qed.

  Hint Rewrite SInverseOf1' using assumption.

  (* XXX TODO: Automate this better. *)
  Lemma s_iso_is_mono s d (p : path (SEdge C) s d) : SchemaIsomorphism p -> SMonomorphism p.
    destruct 1 as [ x [ i0 i1 ] ]; intros z p1 p2 e.
    transitivity (concatenate p1 (concatenate p x)). t_con @PathsEquivalent.
    transitivity (concatenate p2 (concatenate p x)); solve [ repeat rewrite <- concatenate_associative; t_con @PathsEquivalent ] || t_con @PathsEquivalent.
  Qed.

  Theorem SchemaIdentityInverse (x : C) : SInverseOf (@NoEdges _ _ x) (@NoEdges _ _ x).
    hnf; t.
  Qed.

  Hint Resolve SchemaIdentityInverse.

  Theorem SchemaIdentityIsomorphism (x : C) : SchemaIsomorphism (@NoEdges _ _ x).
    eauto.
  Qed.
End Schema.

Hint Resolve SchemaIsomorphism2Isomorphism'.

Ltac concatenate4associativity' a b c d := transitivity (concatenate a (concatenate (concatenate b c) d));
  try solve [ repeat rewrite concatenate_associative; reflexivity ].
Ltac concatenate4associativity :=
  match goal with
    | [ |- ?Rel (concatenate (concatenate ?a ?b) (concatenate ?c ?d)) _ ] => concatenate4associativity' a b c d
    | [ |- ?Rel _ (concatenate (concatenate ?a ?b) (concatenate ?c ?d)) ] => concatenate4associativity' a b c d
  end.

Section SchemaIsomorphismEquivalenceRelation.
  Variable C : Schema.
  Variable s d d' : C.

  Theorem SchemaIsomorphismComposition (p : path (SEdge C) s d) (p' : path (SEdge C) d d') :
    SchemaIsomorphism _ p -> SchemaIsomorphism _ p' -> SchemaIsomorphism _ (concatenate p p').
    repeat destruct 1; unfold SInverseOf in *; destruct_hypotheses.
      match goal with
        | [ m : path _ _ _, m' : path _ _ _ |- _ ] => exists (concatenate m m')
      end;
      split;
        concatenate4associativity; t_con @PathsEquivalent.
  Qed.
End SchemaIsomorphismEquivalenceRelation.

Definition path_unique (A : Schema) s d (x : path (SEdge A) s d) := forall x' : path (SEdge A) s d, PathsEquivalent _ x' x.

Section GeneralizedPathEquivalence.
  Variable S : Schema.

  Inductive GeneralizedPathsEquivalent s d (p : path (SEdge S) s d) : forall s' d' (p' : path (SEdge S) s' d'), Prop :=
    | GPathsEquivalent (p' : path (SEdge S) s d) : PathsEquivalent _ p p' -> GeneralizedPathsEquivalent p p'.

  Lemma GeneralizedPathsEquivalent_PathsEquivalent s d (p p' : path (SEdge S) s d) :
    GeneralizedPathsEquivalent p p' -> PathsEquivalent _ p p'.
    intro H; inversion H.
    repeat match goal with
             | [ H : _ |- _ ] => apply inj_pair2 in H
           end.
    repeat subst.
    assumption.
  Qed.

  Lemma GeneralizedPathsEquivalent_eq s d (p : path (SEdge S) s d) s' d' (p' : path (SEdge S) s' d') :
    GeneralizedPathsEquivalent p p' -> s = s' /\ d = d'.
    intro H; inversion H.
    repeat subst.
    split; trivial.
  Qed.
End GeneralizedPathEquivalence.

Ltac simpl_GeneralizedPathsEquivalent := intros;
  repeat match goal with
           | [ H : GeneralizedPathsEquivalent _ _ _ |- _ ]
             => destruct (GeneralizedPathsEquivalent_eq H); repeat subst;
               apply GeneralizedPathsEquivalent_PathsEquivalent in H
           | [ |- GeneralizedPathsEquivalent _ _ _ ] => apply GPathsEquivalent
         end.

Section GeneralizedPathsEquivalenceRelation.
  Variable S : Schema.

  Lemma GeneralizedPathsEquivalent_refl s d (p : path (SEdge S) s d) : GeneralizedPathsEquivalent _ p p.
    simpl_GeneralizedPathsEquivalent; reflexivity.
  Qed.

  Lemma GeneralizedPathsEquivalent_sym s d (p : path (SEdge S) s d) s' d' (p' : path (SEdge S) s' d') :
    GeneralizedPathsEquivalent _ p p' -> GeneralizedPathsEquivalent _ p' p.
    simpl_GeneralizedPathsEquivalent; symmetry; assumption.
  Qed.

  Lemma GeneralizedPathsEquivalent_trans s d (p : path (SEdge S) s d) s' d' (p' : path (SEdge S) s' d') s'' d'' (p'' : path (SEdge S) s'' d'') :
    GeneralizedPathsEquivalent _ p p' -> GeneralizedPathsEquivalent _ p' p'' -> GeneralizedPathsEquivalent _ p p''.
    simpl_GeneralizedPathsEquivalent; transitivity p'; eauto.
  Qed.
End GeneralizedPathsEquivalenceRelation.

(*
Section SchemaObjects1.
  Variable C : Schema.

  Definition UniqueUpToUniqueIsomorphism' (P : C.(Object) -> Prop) : Prop :=
    forall o, P o -> forall o', P o' -> exists m : C.(Morphism) o o', SchemaIsomorphism' m /\ is_unique m.

  Definition UniqueUpToUniqueIsomorphism (P : C.(Object) -> Type) :=
    forall o, P o -> forall o', P o' -> { m : C.(Morphism) o o' | SchemaIsomorphism' m & is_unique m }.

  (* A terminal object is an object with a unique morphism from every other object. *)
  Definition TerminalObject' (o : C) : Prop :=
    forall o', exists! m : C.(Morphism) o' o, True.

  Definition TerminalObject (o : C) :=
    forall o', { m : C.(Morphism) o' o | is_unique m }.

  (* An initial object is an object with a unique morphism from every other object. *)
  Definition InitialObject' (o : C) : Prop :=
    forall o', exists! m : C.(Morphism) o o', True.

  Definition InitialObject (o : C) :=
    forall o', { m : C.(Morphism) o o' | is_unique m }.
End SchemaObjects1.

Implicit Arguments UniqueUpToUniqueIsomorphism' [C].
Implicit Arguments UniqueUpToUniqueIsomorphism [C].
Implicit Arguments InitialObject' [C].
Implicit Arguments InitialObject [C].
Implicit Arguments TerminalObject' [C].
Implicit Arguments TerminalObject [C].

Section SchemaObjects2.
  Variable C : Schema.

  Hint Unfold TerminalObject InitialObject InverseOf.

  Ltac unique := intros o Ho o' Ho'; destruct (Ho o); destruct (Ho o'); destruct (Ho' o); destruct (Ho' o');
    unfold is_unique, unique, uniqueness in *;
      repeat (destruct 1);
      repeat match goal with
               | [ x : _ |- _ ] => exists x
             end; eauto; try split; try solve [ etransitivity; eauto ].

  (* The terminal object is unique up to unique isomorphism. *)
  Theorem TerminalObjectUnique : UniqueUpToUniqueIsomorphism (@TerminalObject C).
    unique.
  Qed.

  (* The initial object is unique up to unique isomorphism. *)
  Theorem InitialObjectUnique : UniqueUpToUniqueIsomorphism (@InitialObject C).
    unique.
  Qed.
End SchemaObjects2.
*)
