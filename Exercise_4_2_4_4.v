(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import ProofIrrelevance.
Require Import Ensembles.
Require Import Common Notations Orders PropPreOrder PreOrderCategory Duals SetCategory EnsemblePreOrder.

Set Implicit Arguments.

Generalizable All Variables.


(** ------------------------------------------------------------------------ *)

(** * Exercise 4.2.4.4 *)
Module Exercise_4_2_4_4.
  (** ** Problem *)
  (** Take again the preorder [J] of jurisdictions from Exercise
      4.2.4.3 and the idea that laws are propositions. But this time,
      let [R(V)] be the set of all possible laws (not just those
      dictated to hold) that are in actuality being respected,
      i.e. followed, by all people in [V]. This assigns to each
      jurisdiction a set. Since preorders can be considered
      categories, does our "the set of respected laws" function [R :
      Ob J -> Ob Set] extend to a functor [J -> Set]?

      What about if instead we take the meet of all these laws and
      assign to each jurisdiction the maximal law respected
      throughout. Does this assignment [Ob J -> Ob Prop] extend to a
      functor [J -> Prop]? *)
  (** ** Solution *)
  (** If [U ⊆ V], then [R(V) ⊆ R(U)], because all the people in [U]
      are also people in [V], and so respect all the laws which
      everyone in [V] respects.  However, people in [U] might respect
      additional laws.  Again, we do not have a functor [J -> Set],
      but [J -> Set ᵒᵖ].

      The "maximal law" assignment does give us a functor a functor
      [Set -> Prop], because if [U ⊆ V], then the maximal law of [U]
      implies the maximal law of [V]. *)

  Variable Person : Type.
  (** A jurisdiction is a set of people *)
  Definition Jurisdiction := Ensemble Person.
  Variable Law : Type.
  Variable LawAsProp : Law -> Prop.
  (** The laws of a jurisdiction is a subset of the set of [Law]s *)
  Definition SetOfLaws := Ensemble Law.
  (** Each person respects some set of laws *)
  Variable RespectedLawsOfPerson : Person -> SetOfLaws.

  (** The laws respected by a jurisdiction is the set of laws
      respected by every person in that jurisdiction *)
  Inductive RespectedLawsOf (J : Jurisdiction) : SetOfLaws :=
  | RespectedLawsOfAll : forall law,
                         (forall person,
                            person ∈ J
                            -> law ∈ RespectedLawsOfPerson person)
                         -> law ∈ RespectedLawsOf J.

  (*Definition ConcreteSetOfLaws : SetOfLaws -> Type := @sig _.

  Local Coercion ConcreteSetOfLaws : SetOfLaws >-> Sortclass.

  Local Infix "<=" := impl.
  Local Infix "≤" := impl. *)

  Global Instance JurisdictionPreOrder
  : @PreOrder Jurisdiction (fun U V => U ⊆ V).
  firstorder.
  Qed.

  Global Instance SetsPreOrder : @PreOrder SetOfLaws _
    := Ensemble_PreOrder _.

  Hint Extern 1 => constructor.
  Hint Extern 1 => destruct_head_hnf @RespectedLawsOf.

  (** If jurisdiction [s] is a subset of jurisdiction [d], we can show
      by unfolding of definitions and firstorder logical reasoning
      that the respected laws of [d] are a subset of the respected
      laws of [s].  (Intuitively, everyone in [s] follows all the laws
      respected by people in [d], and then some.) *)
  Definition RespectedLawsOfFunctor_MorphismOf
             s d (m : Morphism (PreOrderCategory JurisdictionPreOrder) s d)
  : Morphism (OppositeCategory (PreOrderCategory SetsPreOrder))
             (RespectedLawsOf s)
             (RespectedLawsOf d).
    compute in *;
    repeat (split || intro);
    destruct_head_hnf @RespectedLawsOf.
    intuition.
  Qed.

  (** The fact that this is a functor follows by proof irrelevance. *)
  Definition RespectedLawsOfFunctor
  : Functor (PreOrderCategory JurisdictionPreOrder)
            (OppositeCategory (PreOrderCategory SetsPreOrder)).
    refine (Build_Functor (PreOrderCategory JurisdictionPreOrder)
                          (OppositeCategory (PreOrderCategory SetsPreOrder))
                          (RespectedLawsOf)
                          (RespectedLawsOfFunctor_MorphismOf)
                          _
                          _);
    abstract (intros; simpl; apply ProofIrrelevance.proof_irrelevance).
  Defined.

  Section maximal_law.
    Variable S : SetOfLaws.

    (** A [P : Prop] is a law of [V] if there is some [Law] which is
        equal to [P] when treated as a [Prop]. *)
    Let SetOfLawsAsProp : Ensemble Prop := fun P =>
                                             exists L,
                                               L ∈ S
                                               /\ LawAsProp L = P.

    Definition maximal_law : Prop :=
      EnsembleMeetElement (EnsembleMeetOf := PropHasEnsembleMeets SetOfLawsAsProp).
  End maximal_law.

  (** If jurisdiction [s] is a subset of jurisdiction [d], we can show
      by unfolding of definitions and firstorder logical reasoning
      that the maximal respected law of [s] implies are a subset of
      the respected laws of [s].  (Intuitively, everyone in [s]
      follows all the laws respected by people in [d], and then some.) *)

  (** This proof is done by a combination of unfolding of definitions,
      firstorder logical reasoning, and educated guessing on the basis
      of hypotheses. *)
  Definition MaximalRespectedLawOfFunctor_MorphismOf
             s d (m : Morphism (PreOrderCategory JurisdictionPreOrder) s d)
  : Morphism (PreOrderCategory Prop_PreOrder)
             (maximal_law (RespectedLawsOf s))
             (maximal_law (RespectedLawsOf d)).
    repeat match goal with
             | _ => progress compute in *
             | _ => split
             | _ => intro
             | _ => progress destruct_head_hnf @RespectedLawsOf
             | _ => progress destruct_head_hnf @ex
             | _ => progress intuition
             | [ H : _ |- _ ] => apply H; clear H
             | _ => eexists; split; try eassumption; []
             | _ => constructor
             | _ => solve [ firstorder ]
           end.
  Defined.

  (** The fact that this is a functor follows by proof irrelevance. *)
  Definition MaximalRespectedLawOfFunctor
  : Functor (PreOrderCategory JurisdictionPreOrder)
            (PreOrderCategory Prop_PreOrder).
    refine (Build_Functor (PreOrderCategory JurisdictionPreOrder)
                          (PreOrderCategory Prop_PreOrder)
                          (fun J => maximal_law (RespectedLawsOf J))
                          MaximalRespectedLawOfFunctor_MorphismOf
                          _
                          _);
    abstract (intros; simpl; apply ProofIrrelevance.proof_irrelevance).
  Defined.
End Exercise_4_2_4_4.

(** ------------------------------------------------------------------------ *)
