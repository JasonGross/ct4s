(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing ≄ %\ensuremath{\not\simeq}% #&#8772;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
(** printing ℙ %\ensuremath{\mathbb{P}}% #&#x2119;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ▻ %\ensuremath{\triangleright}% #&#x25BB;# *)
(** printing ◅ %\ensuremath{\triangleleft}% #&#x25C5;# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import ChainCategory Functor Cone CategoryIsomorphisms ComputableCategory DiscreteCategory ProductCategory.
Require Import Common Notations NatFacts FEqualDep.

Set Implicit Arguments.

Generalizable All Variables.

(** ------------------------------------------------------------------------ *)

(** * Exercise 4.5.2.12 *)
Module Exercise_4_5_2_12.
  Local Open Scope category_scope.
  Local Open Scope morphism_scope.
  (** ** Problem *)
  (** Let [C] be the category [( _2_ ◅)▻], where _2_ is the discrete
      category on two objects. Then [C] is somehow square-shaped, but
      what category is it exactly? Looking at Example 4.5.2.2, is [C]
      the commutative diagram indexing category [[1] * [1]], is it the
      non-commutative diagram indexing category [F(G)], or is it
      something else? *)
  (** ** Solution *)
  (** I prove that [( _2_ ◅)▻ ≅ [1] * [1]] in the category of
      categories. *)

  Inductive Two := A | B.

  Definition C := ((DiscreteCategory Two)◅)▻.

  Lemma pf_0_le_0 : 0 <= 0. repeat constructor. Defined.
  Lemma pf_0_le_1 : 0 <= 1. repeat constructor. Defined.
  Lemma pf_1_le_1 : 1 <= 1. repeat constructor. Defined.
  Fixpoint pf_0_le_n n : 0 <= n := match n with O => le_n _ | S n' => le_S _ _ (pf_0_le_n n') end.

  Definition obj_0 : [1] := exist _ 0 pf_0_le_1.
  Definition obj_1 : [1] := exist _ 1 pf_1_le_1.
  Definition mor_0_1 : Morphism [1] obj_0 obj_1 := pf_0_le_1.
  Global Arguments obj_0 / .
  Global Arguments obj_1 / .
  Global Arguments mor_0_1 / .

  (** We define functions between [C] and [[1] * [1]].  The stuff at
      the bottom of [sq_to_C] is deriving abusrdity ([exfalso]) from
      having supposed elements that aren't actually in [[1]]. *)

  Definition C_to_sq : C -> [1] * [1]
    := fun x => match x with
                  | inr tt => (obj_1, obj_1)
                  | inl (inl tt) => (obj_0, obj_0)
                  | inl (inr A) => (obj_0, obj_1)
                  | inl (inr B) => (obj_1, obj_0)
                end.

  Definition sq_to_C : [1] * [1] -> C.
      refine (fun x => match x with
                  | (exist 0 _, exist 0 _) => inl (inl tt)
                  | (exist 1 _, exist 1 _) => inr tt
                  | (exist 0 _, exist 1 _) => inl (inr A)
                  | (exist 1 _, exist 0 _) => inl (inr B)
                  | (exist (S (S n)) pf, _) => let pf' := pf : S (S n) <= 1 in
                                               _
                  | (_, exist (S (S n)) pf) => let pf' := pf : S (S n) <= 1 in
                                               _
                end);
    clearbody pf';
    revert pf';
    clear;
    intro;
    exfalso;
    abstract omega.
  Defined.

  (** Now we define the transformation on morphisms.  As the morphisms
      are unique, this isn't too hard. *)

  Definition C_to_sq_MorphismOf s d (m : Morphism C s d)
  : Morphism ([1] * [1]) (C_to_sq s) (C_to_sq d).
    revert m.
    refine (match s as s, d as d
                  return Morphism C s d
                         -> Morphism ([1] * [1]) (C_to_sq s) (C_to_sq d)
            with
              | _, inr tt => fun _ => (_, _)
              | inl (inl tt), _ => fun _ => (pf_0_le_n _, pf_0_le_n _)
              | inl (inr A), inl (inr A) => fun _ => (_, _)
              | inl (inr B), inl (inr B) => fun _ => (_, _)
              | inl (inr A), inl (inr B) => _
              | inl (inr B), inl (inr A) => _
              | inr tt, inl _ => fun x => match x with end
              | _, inl (inl tt) => fun x => match x with end
            end);
      simpl;
      try solve [ repeat constructor
                | let H := fresh in
                  clear;
                    intro H;
                    exfalso;
                    abstract inversion H ].
  Defined.

  (** Every morphism is either [tt] or [eq_refl], and in the other
      cases, we can find an absurdity. *)

  Definition sq_to_C_MorphismOf s d (m : Morphism ([1] * [1]) s d)
  : Morphism C (sq_to_C s) (sq_to_C d).
    destruct s as [[[|[|s1]] ?] [[|[|s2]] ?]],
                  d as [[[|[|d1]] ?] [[|[|d2]] ?]];
    try exact tt;
    try exact eq_refl;
    simpl in *;
    try match goal with
          | [ |- appcontext[False_rect _ ?pf] ] => solve [ case pf ]
        end;
    exfalso;
    abstract (
        destruct_head_hnf @prod;
        omega
      ).
  Defined.

  (** Now the functors.  We prove functoriality by repeated
      case-splitting, using uniqueness of some proofs, and some
      definitions of equality. *)

  Definition C_to_sq_functor : Functor C ([1] * [1]).
    refine {| MorphismOf := C_to_sq_MorphismOf |};
    abstract (
        intros;
        repeat match goal with
                 | [ H : _ ⊔ _ |- _ ] => destruct H
                 | [ u : unit |- _ ] => destruct u
                 | _ => progress simpl_eq
                 | _ => apply nat_le_proofs_unicity
                 | _ => progress simpl in * |-
                 | _ => progress simpl
               end
      ).
  Defined.

  Local Ltac destruct_sig_one n :=
    (let H := fresh in
     destruct n as [ [|[|]] H ];
     [ | | exfalso;
           repeat match goal with
                    | [ H' : _ |- _ ] => (constr_eq H H'; fail 1)
                                           || clear H'
                  end;
           abstract omega ]).

  Definition sq_to_C_functor : Functor ([1] * [1]) C.
    refine {| MorphismOf := sq_to_C_MorphismOf |};
    abstract (
        intros;
        repeat match goal with
                 | _ => reflexivity
                 | _ => progress (hnf in *; simpl in * |- )
                 | [ H : prod _ _ |- _ ] => destruct H
                 | [ H : 1 <= 0 |- _ ] => (exfalso; revert H; clear; intro H; abstract omega)
                 | [ n : { m | m <= 1 } |- _ ] => destruct_sig_one n
               end
      ).
  Defined.

  (** Now, finally, we prove that [[1] * [1]] and [( _2_ ◅)▻] are
      isomorphic in [Cat].

      To prove this goal, we exhaustively case-split and apply some
      facts about uniqueness of proofs. *)

  Theorem Exercise_4_5_2_12 : ((C : CategoryOfCategories)
                                 ≅ ([1] * [1] : CategoryOfCategories))%category.
    exists C_to_sq_functor.
    exists sq_to_C_functor;
      abstract (
          simpl;
          apply Functor_Eq;
          intros;
          repeat match goal with
                   | _ => easy
                   | [ H : _ ⊔ _ |- _ ] => destruct H
                   | [ u : unit |- _ ] => destruct u
                   | [ u : Two |- _ ] => destruct u
                   | [ H : prod _ _ |- _ ] => destruct H
                   | _ => progress simpl_eq
                   | _ => apply nat_le_proofs_unicity
                   | _ => progress simpl in * |-
                   | _ => progress simpl
                   | _ => progress subst_eq_refl_dec
                   | _ => (apply Eqdep_dec.eq_proofs_unicity; clear; abstract decide equality)
                   | [ n : { m | m <= 1 } |- _ ] => destruct_sig_one n
                 end
        ).
  Defined.
End Exercise_4_5_2_12.

(** ------------------------------------------------------------------------ *)
