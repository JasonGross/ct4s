(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ∪ %\ensuremath{\cup}% #&cup;# *)
(** printing '∪' %\ensuremath{\cup}% #&cup;# *)
(** printing ∩ %\ensuremath{\cap}% #&cap;# *)
(** printing '∩' %\ensuremath{\cap}% #&cap;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing ≄ %\ensuremath{\not\simeq}% #&#8772;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ℤ %\ensuremath{\mathbb{Z}}% #&#x2124;# *)
(** printing ℙ %\ensuremath{\mathbb{P}}% #&#x2119;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ↦ %\ensuremath{\mapsto}% #&#21A6# *)
(** printing ↪ %\ensuremath{\hookrightarrow}% #&rarrhk;# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ▻ %\ensuremath{\triangleright}% #&#x25BB;# *)
(** printing ◅ %\ensuremath{\triangleleft}% #&#x25C5;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ≰ %\ensuremath{\not\le}% #&#x2270;# *)
(** printing ≱ %\ensuremath{\not\ge}% #&#x2271;# *)
(** printing ≼ %\ensuremath{\preceq}% #&#x227c;# *)
(** printing ≽ %\ensuremath{\succeq}% #&#x227d;# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *) (* ))) *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import ProofIrrelevance FunctionalExtensionality.
Require Import ClassicalFacts.
Require Import Ensembles.
Require Import Orders PropPreOrder PreOrderCategory.
Require Import Duals.
Require Import SetCategory EnsemblePreOrder.
Require Import Common Notations FEqualDep TopologyCategory Functor Morphism IndiscreteTopology DiscreteTopology.
Require Import Common Notations Orders PropPreOrder PreOrderCategory Duals.

Set Implicit Arguments.

Generalizable All Variables.

(** ------------------------------------------------------------------------ *)

(** * Exercise 4.6.1.5 *)
Module Exercise_4_6_1_5.
  Local Open Scope topology_scope.
  (** ** Problem *)
  (** In Exercises 4.2.3.2, 4.2.4.3, and 4.2.4.4 there were questions
      about whether a certain function [Ob(C) -> Ob(D)] extended to a
      functor [C -> D]. In each case, see if the proposed function would
      extend to a "contravariant functor" i.e. to a functor [C ᵒᵖ -> D]. *)
  (** ** Solution *)
  (** In each case that we don't have a functor [C -> D] (4.2.3.2 and
  4.2.4.4), we do have a functor [C ᵒᵖ -> D]. *)

  (** *** Exercise 4.2.3.2 *)
  Section Exercise_4_2_3_2.
    (** **** Problem *)
    (** Explain how "looking at points" gives a functor [Top ->
        Set]. Does "looking at open sets" give a functor [Top -> PrO]?
     *)
    (** **** Solution *)
    (** Every topology has an underlying set of points, and every
        continuous function is a function on these sets.  Looking at
        open sets gives a functor [Top ᵒᵖ -> PrO] where the open sets
        are ordered by inclusion. *)

    Record > EOpenSet `(Topology X) :=
      {
       OpenSetSet :> Ensemble X;
        OpenSetOpen :> Open OpenSetSet
      }.

    Lemma OpenSet_eq `(T : Topology X) (A B : EOpenSet T)
    : OpenSetSet A = OpenSetSet B
      -> A = B.
      destruct A, B; simpl; intro; subst;
      f_equal; apply ProofIrrelevance.proof_irrelevance.
    Qed.

    Global Instance opens_ordered_by_inclusion `(Topology X)
    : @PreOrder (EOpenSet _) (fun U V => U ⊆ V).
    split; firstorder.
    Qed.

    Definition continuous_induced_functor_object_of
               s d (m : Morphism CategoryOfTopologies s d)
    : (opens_ordered_by_inclusion d) -> (opens_ordered_by_inclusion s).
      intro; hnf in *.
      exists (inverse_image (proj1_sig m) X);
        simpl.
      abstract (
          destruct m as [f c];
          apply c;
          destruct X;
          assumption
        ).
    Defined.

    Definition continuous_induced_functor_morphism_of
               s d (m : Morphism CategoryOfTopologies s d)
    : forall s' d' (m' : Morphism (PreOrderCategory (opens_ordered_by_inclusion d))
                                  s'
                                  d'),
        Morphism (PreOrderCategory (opens_ordered_by_inclusion s))
                 (continuous_induced_functor_object_of m s')
                 (continuous_induced_functor_object_of m d').
      intros s' d' m' x H.
      hnf in m, m'.
      simpl in *.
      destruct m as [ f c ]; simpl in *.
      repeat unfold Ensembles.In, inverse_image in *.
      intuition.
    Qed.

    Definition continuous_induced_functor
               s d (m : Morphism CategoryOfTopologies d s)
    : Morphism CategoryOfPreOrders
               (opens_ordered_by_inclusion s)
               (opens_ordered_by_inclusion d).
      refine {| ObjectOf := (continuous_induced_functor_object_of m);
                MorphismOf := (continuous_induced_functor_morphism_of m) |};
      abstract (intros; simpl; apply ProofIrrelevance.proof_irrelevance).
    Defined.

    (** Here's the open-set functor *)
    Definition PreOrderedSets
    : Functor (OppositeCategory CategoryOfTopologies) CategoryOfPreOrders.
      refine (Build_Functor (OppositeCategory CategoryOfTopologies)
                            CategoryOfPreOrders
                            (fun x => opens_ordered_by_inclusion x)
                            continuous_induced_functor
                            _
                            _);
      abstract (repeat (
                    reflexivity
                      || (progress (simpl; intros; expand))
                      || (progress destruct_head_hnf @EOpenSet)
                      || (apply f_equal)
                      || (apply ProofIrrelevance.proof_irrelevance)
                      || (apply proof_irrelevance_JMeq)
                      || (apply Functor_Eq)
               )).
    Defined.
  End Exercise_4_2_3_2.
  (** ------------------------------------------------------------------------ *)

  (** *** Exercise 4.2.4.3 *)
  Module Exercise_4_2_4_3.
    (** **** Problem *)
    (** Consider the set of possible laws (most likely an infinite set)
      that can be dictated to hold throughout a jurisdiction. Consider
      each law as a proposition ("such and such is (dictated to be)
      the case"), i.e as an object of our preorder [Prop]. Given a
      jurisdiction [V], and a set of laws [{L1, L2, ..., Ln}] that are
      dictated to hold throughout [V], we take their meet [L(V) := L1
      /\ L2 /\ ... /\ Ln] and consider it to be the single law of the
      land [V]. Suppose that [V] is a jurisdiction and [U ⊆ V] is a
      sub-jurisdiction (e.g. [U] is a county and [V] is a state);
      then clearly any law dictated by the large jurisdiction (the
      state) must also hold throughout the small jurisdiction (the
      county). What is the relation in [Prop] between L(U) and L(V)?

      Consider the obvious preorder [J] on jurisdictions, where [U ⊆
      V] means [U ≤ V]. Is "the law of the land" a morphism of
      preorders [J -> Prop]? To be a bit more highbrow, considering
      both [J] and [Prop] to be categories (by Proposition 4.2.1.17),
      we have a function [L : Ob J -> Ob Prop]; this question is
      asking whether [L] extends to a functor [J -> Prop]. *)
    (** **** Solution *)
    (** If [U ⊆ V], then [L(U) ≤ L(V)], because whenever all the laws
        of [U] hold, so must the laws of [V], because [U] can only add
        more laws.

        We have a functor [J -> Prop]. *)

    Variable Law : Type.
    Variable LawAsProp : Law -> Prop.
    (** The type of jurisdictions *)
    Variable Jurisdiction : Type.
    (** The laws of a jurisdiction is a subset of the set of [Law]s *)
    Variable LawsOf : Jurisdiction -> Ensemble Law.

    Local Infix "<=" := impl.
    Local Infix "≤" := impl.

    Section LawOfTheLand.
      Variable V : Jurisdiction.
      (** An [Ensemble T] is a subset of [T]. *)
      Let V_Laws : Ensemble Law := LawsOf V.
      (** A [P : Prop] is a law of [V] if there is some [Law] which is
        equal to [P] when treated as a [Prop]. *)
      Let V_LawsAsProp : Ensemble Prop := fun P =>
                                            exists L,
                                              L ∈ V_Laws
                                              /\ LawAsProp L = P.
      (** Since [Prop] has all meets (defined by subsets, i.e.,
       [Ensemble Prop]s), we can define the law of the land as the
       meet of all of the laws of [V]. *)
      Definition LawOfTheLand := PropHasEnsembleMeets V_LawsAsProp.
    End LawOfTheLand.

    Lemma LawOfTheLand_subset_flip (U V : Jurisdiction) (P := Prop_PreOrder)
          (LawOfTheVLand := EnsembleMeetElement (EnsembleMeetOf := LawOfTheLand V))
          (LawOfTheULand := EnsembleMeetElement (EnsembleMeetOf := LawOfTheLand U))
    : LawsOf V ⊆ LawsOf U
      -> LawOfTheULand ≤ LawOfTheVLand.
    Proof.
      firstorder.
    Qed.

    Global Instance JurisdictionPreOrder
    : @PreOrder Jurisdiction (fun U V => LawsOf V ⊆ LawsOf U).
    firstorder.
    Qed.

    Definition LawOfTheLandFunctor
    : Functor (PreOrderCategory JurisdictionPreOrder)
              (PreOrderCategory Prop_PreOrder).
      refine (Build_Functor (PreOrderCategory JurisdictionPreOrder)
                            (PreOrderCategory Prop_PreOrder)
                            (fun V : Jurisdiction =>
                               EnsembleMeetElement
                                 (EnsembleMeetOf := LawOfTheLand V))
                            (fun s d (m : Morphism (PreOrderCategory JurisdictionPreOrder) s d)
                             => @LawOfTheLand_subset_flip _ _ m : Morphism (PreOrderCategory Prop_PreOrder) _ _)
                            _
                            _);
      abstract (intros; simpl; apply ProofIrrelevance.proof_irrelevance).
    Defined.
  End Exercise_4_2_4_3.

  (** ------------------------------------------------------------------------ *)

  (** *** Exercise 4.2.4.4 *)
  Module Exercise_4_2_4_4.
    (** **** Problem *)
    (** Take again the preorder [J] of jurisdictions from Exercise
        4.2.4.3 and the idea that laws are propositions. But this
        time, let [R(V)] be the set of all possible laws (not just
        those dictated to hold) that are in actuality being respected,
        i.e. followed, by all people in [V]. This assigns to each
        jurisdiction a set. Since preorders can be considered
        categories, does our "the set of respected laws" function [R :
        Ob J -> Ob Set] extend to a functor [J -> Set]?

        What about if instead we take the meet of all these laws and
        assign to each jurisdiction the maximal law respected
        throughout. Does this assignment [Ob J -> Ob Prop] extend to a
        functor [J -> Prop]? *)
    (** **** Solution *)
    (** If [U ⊆ V], then [R(V) ⊆ R(U)], because all the people in [U]
        are also people in [V], and so respect all the laws which
        everyone in [V] respects.  However, people in [U] might
        respect additional laws.  Again, we do not have a functor [J
        -> Set], but [J ᵒᵖ -> Set].

        The "maximal law" assignment does give us a functor [Set ->
        Prop], because if [U ⊆ V], then the maximal law of [U] implies
        the maximal law of [V]. *)

    Variable Person : Type.
    (** A jurisdiction is a set of people *)
    Definition Jurisdiction := Ensemble Person.
    Variable Law : Type.
    Variable LawAsProp : Law -> Prop.
    (** The laws of a jurisdiction is a subset of the set of [Law]s *)
    Definition SetOfLaws := Ensemble Law.
    (** Each person respects some set of laws *)
    Variable RespectedLawsOfPerson : Person -> SetOfLaws.

    (** The laws respected by a jurisdiction is the set of laws
      respected by every person in that jurisdiction *)
    Inductive RespectedLawsOf (J : Jurisdiction) : SetOfLaws :=
    | RespectedLawsOfAll : forall law,
                             (forall person,
                                person ∈ J
                                -> law ∈ RespectedLawsOfPerson person)
                             -> law ∈ RespectedLawsOf J.

    Global Instance JurisdictionPreOrder
    : @PreOrder Jurisdiction (fun U V => U ⊆ V).
    firstorder.
    Qed.

    Global Instance SetsPreOrder : @PreOrder SetOfLaws _
      := Ensemble_PreOrder _.

    Hint Extern 1 => constructor.
    Hint Extern 1 => destruct_head_hnf @RespectedLawsOf.

    (** If jurisdiction [s] is a subset of jurisdiction [d], we can show
      by unfolding of definitions and firstorder logical reasoning
      that the respected laws of [d] are a subset of the respected
      laws of [s].  (Intuitively, everyone in [s] follows all the laws
      respected by people in [d], and then some.) *)
    Definition RespectedLawsOfFunctor_MorphismOf
               s d (m : Morphism (OppositeCategory (PreOrderCategory JurisdictionPreOrder)) s d)
    : Morphism (PreOrderCategory SetsPreOrder)
               (RespectedLawsOf s)
               (RespectedLawsOf d).
      compute in *;
      repeat (split || intro);
      destruct_head_hnf @RespectedLawsOf.
      intuition.
    Qed.

    (** The fact that this is a functor follows by proof irrelevance. *)
    Definition RespectedLawsOfFunctor
    : Functor (OppositeCategory (PreOrderCategory JurisdictionPreOrder))
              (PreOrderCategory SetsPreOrder).
      refine (Build_Functor (OppositeCategory (PreOrderCategory JurisdictionPreOrder))
                            (PreOrderCategory SetsPreOrder)
                            (RespectedLawsOf)
                            (RespectedLawsOfFunctor_MorphismOf)
                            _
                            _);
      abstract (intros; simpl; apply ProofIrrelevance.proof_irrelevance).
    Defined.

    Section maximal_law.
      Variable S : SetOfLaws.

      (** A [P : Prop] is a law of [V] if there is some [Law] which is
        equal to [P] when treated as a [Prop]. *)
      Let SetOfLawsAsProp : Ensemble Prop := fun P =>
                                               exists L,
                                                 L ∈ S
                                                 /\ LawAsProp L = P.

      Definition maximal_law : Prop :=
        EnsembleMeetElement (EnsembleMeetOf := PropHasEnsembleMeets SetOfLawsAsProp).
    End maximal_law.

    (** If jurisdiction [s] is a subset of jurisdiction [d], we can show
      by unfolding of definitions and firstorder logical reasoning
      that the maximal respected law of [s] implies are a subset of
      the respected laws of [s].  (Intuitively, everyone in [s]
      follows all the laws respected by people in [d], and then some.) *)

    (** This proof is done by a combination of unfolding of definitions,
      firstorder logical reasoning, and educated guessing on the basis
      of hypotheses. *)
    Definition MaximalRespectedLawOfFunctor_MorphismOf
               s d (m : Morphism (PreOrderCategory JurisdictionPreOrder) s d)
    : Morphism (PreOrderCategory Prop_PreOrder)
               (maximal_law (RespectedLawsOf s))
               (maximal_law (RespectedLawsOf d)).
      repeat match goal with
               | _ => progress compute in *
               | _ => split
               | _ => intro
               | _ => progress destruct_head_hnf @RespectedLawsOf
               | _ => progress destruct_head_hnf @ex
               | _ => progress intuition
               | [ H : _ |- _ ] => apply H; clear H
               | _ => eexists; split; try eassumption; []
               | _ => constructor
               | _ => solve [ firstorder ]
             end.
    Defined.

    (** The fact that this is a functor follows by proof irrelevance. *)
    Definition MaximalRespectedLawOfFunctor
    : Functor (PreOrderCategory JurisdictionPreOrder)
              (PreOrderCategory Prop_PreOrder).
      refine (Build_Functor (PreOrderCategory JurisdictionPreOrder)
                            (PreOrderCategory Prop_PreOrder)
                            (fun J => maximal_law (RespectedLawsOf J))
                            MaximalRespectedLawOfFunctor_MorphismOf
                            _
                            _);
      abstract (intros; simpl; apply ProofIrrelevance.proof_irrelevance).
    Defined.
  End Exercise_4_2_4_4.
End Exercise_4_6_1_5.
(** ------------------------------------------------------------------------ *)
