(* printing '*' %\ensuremath{\times}% #&times;# *)
(* printing * %\ensuremath{\times}% #&times;# *)
(** printing '×' %\ensuremath{\times}% #&times;# *)
(** printing × %\ensuremath{\times}% #&times;# *)
(** printing ★ %\ensuremath{\star}% #&#9733;# *)
(** printing "★" %\ensuremath{\star}% #&#9733;# *)
(** printing '★' %\ensuremath{\star}% #&#9733;# *)
(** printing '⊔' %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing ⊔ %\ensuremath{\sqcup}% #&#x2294;# *)
(** printing 'π' %\ensuremath{\pi}% #&pi;# *)
(** printing π %\ensuremath{\pi}% #&pi;# *)
(** printing 'Σ' %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing Σ %\ensuremath{\Sigma}% #&Sigma;# *)
(** printing ⁰ %\ensuremath{^0}% #<sup>0</sup># *)
(** printing ¹ %\ensuremath{^1}% #<sup>1</sup># *)
(** printing ² %\ensuremath{^2}% #<sup>2</sup># *)
(** printing ³ %\ensuremath{^3}% #<sup>3</sup># *)
(** printing ⁴ %\ensuremath{^4}% #<sup>4</sup># *)
(** printing ⁵ %\ensuremath{^5}% #<sup>5</sup># *)
(** printing ⁶ %\ensuremath{^6}% #<sup>6</sup># *)
(** printing ⁷ %\ensuremath{^7}% #<sup>7</sup># *)
(** printing ⁸ %\ensuremath{^8}% #<sup>8</sup># *)
(** printing ⁹ %\ensuremath{^9}% #<sup>9</sup># *)
(** printing ⁱ %\ensuremath{^i}% #<sup>i</sup># *)
(** printing ⁺ %\ensuremath{^+}% #<sup>+</sup># *)
(** printing ⁻ %\ensuremath{^-}% #<sup>-</sup># *)
(** printing ⁼ %\ensuremath{^=}% #<sup>=</sup># *)
(** printing ⁽ %\ensuremath{^(}% #<sup>(</sup># *)
(** printing ⁾ %\ensuremath{^)}% #<sup>)</sup># *)
(** printing ⁿ %\ensuremath{^n}% #<sup>n</sup># *)
(** printing ₀ %\ensuremath{_0}% #<sub>0</sub># *)
(** printing ₁ %\ensuremath{_1}% #<sub>1</sub># *)
(** printing ₂ %\ensuremath{_2}% #<sub>2</sub># *)
(** printing ₃ %\ensuremath{_3}% #<sub>3</sub># *)
(** printing ₄ %\ensuremath{_4}% #<sub>4</sub># *)
(** printing ₅ %\ensuremath{_5}% #<sub>5</sub># *)
(** printing ₆ %\ensuremath{_6}% #<sub>6</sub># *)
(** printing ₇ %\ensuremath{_7}% #<sub>7</sub># *)
(** printing ₈ %\ensuremath{_8}% #<sub>8</sub># *)
(** printing ₉ %\ensuremath{_9}% #<sub>9</sub># *)
(** printing ₊ %\ensuremath{_+}% #<sub>+</sub># *)
(** printing ₋ %\ensuremath{_-}% #<sub>-</sub># *)
(** printing ₌ %\ensuremath{_=}% #<sub>=</sub># *)
(** printing ₍ %\ensuremath{_(}% #<sub>(</sub># *)
(** printing ₎ %\ensuremath{_)}% #<sub>)</sub># *)
(** printing ₐ %\ensuremath{_a}% #<sub>a</sub># *)
(** printing ₑ %\ensuremath{_e}% #<sub>e</sub># *)
(** printing ₒ %\ensuremath{_o}% #<sub>o</sub># *)
(** printing ₓ %\ensuremath{_x}% #<sub>x</sub># *)
(** printing ᵒᵖ %\ensuremath{^{\text{op}}}% #<sup>op</sup># *)
(** printing π₁ %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing π₂ %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing 'π₁' %\ensuremath{\pi_1}% #&pi;<sub>1</sub># *)
(** printing 'π₂' %\ensuremath{\pi_2}% #&pi;<sub>2</sub># *)
(** printing f₀ %\ensuremath{f_0}% #f<sub>0</sub># *)
(** printing f₀) %\ensuremath{f_0})% #f<sub>0</sub>)# *)
(** printing f₁ %\ensuremath{f_1}% #f<sub>1</sub># *)
(** printing f₁) %\ensuremath{f_1})% #f<sub>1</sub>)# *)
(** printing ≅ %\ensuremath{\cong}% #&cong;# *)
(** printing ≃ %\ensuremath{\simeq}% #&#x2243;# *)
(** printing λ %\ensuremath{\lambda}% #&lambda;# *)
(** printing 'o' %\ensuremath{\circ}% #&#x25cb;# *)
(** printing o %\ensuremath{\circ}% #&#x25cb;# *)
(** printing i ⁻¹ %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing 'i ⁻¹' %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing "i ⁻¹" %\ensuremath{i^{-1}}% #i<sup>-1</sup># *)
(** printing ⁻¹ %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻¹' %\ensuremath{^{-1}}% #<sup>-1</sup># *)
(** printing '⁻' %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing '¹' %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing ⁻ %\ensuremath{^{-}}% #<sup>-</sup># *)
(** printing ¹ %\ensuremath{^{1}}% #<sup>1</sup># *)
(** printing :> %:\ensuremath{>}% #:># *)
(** printing ':>' %:\ensuremath{>}% #:># *)
(** printing _1_ %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing '_1_' %\ensuremath{\text{\underline{1}}}% #<u>1</u># *)
(** printing _2_ %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing '_2_' %\ensuremath{\text{\underline{2}}}% #<u>2</u># *)
(** printing ℝ %\ensuremath{\mathbb{R}}% #&#x211d;# *)
(** printing ℝ³ %\ensuremath{\mathbb{R}^3}% #&#x211d;<sup>3</sup># *)
(** printing ℕ %\ensuremath{\mathbb{N}}% #&#x2115;# *)
(** printing ← %\ensuremath{\leftarrow}% #&larr;# *)
(** printing ↑ %\ensuremath{\uparrow}% #&uarr;# *)
(** printing → %\ensuremath{\rightarrow}% #&rarr;# *)
(** printing ↓ %\ensuremath{\downarrow}% #&darr;# *)
(** printing ↔ %\ensuremath{\leftrightarrow}% #&harr;# *)
(** printing ↕ %\ensuremath{\updownarrow}% #&#x2195# *)
(** printing ↖ %\ensuremath{\nwarrow}% #&#x2196# *)
(** printing ↗ %\ensuremath{\nearrow}% #&#x2197# *)
(** printing ↘ %\ensuremath{\searrow}% #&#x2198# *)
(** printing ↙ %\ensuremath{\swarrow}% #&#x2199# *)
(** printing ⇉ %\ensuremath{\rightrightarrows} #&#x21c9# *)
(** printing ⊆ %\ensuremath{\subseteq}% #&sube;# *)
(** printing ⊂ %\ensuremath{\subset}% #&sub;# *)
(** printing ∈ %\ensuremath{\in}% #&isin;# *)
(** printing ∅ %\ensuremath{\emptyset}% #&empty;# *)
(** printing ≤ %\ensuremath{\le}% #&le;# *)
(** printing ≤) %\ensuremath{\le)}% #&le;)# *)
(** printing ∧ %\ensuremath{\wedge}% #&and;# *)
(** printing ∨ %\ensuremath{\vee}% #&or;# *)
(** printing ¬ %\ensuremath{\neg}% #&not;# *)
(** printing ¬( %\ensuremath{\neg}(% #&not;(# *)
(* must \usepackage{mathabx} in LaTeX *)
(** printing ↷ %\ensuremath{\lefttorightarrow}% #<div style="display:inline-block; transform:rotate(90deg);-o-transform:rotate(90deg);-mod-transform:rotate(90deg);-webkit-transform:rotate(90deg);">&#x21ba;</div># *)

Require Import Utf8.
Require Import ProofIrrelevance FunctionalExtensionality.
Require Import Common Notations FEqualDep SetCategory TopologyCategory PreOrderCategory Functor Morphism Duals IndiscreteTopology DiscreteTopology.

Set Implicit Arguments.

Generalizable All Variables.

Local Open Scope topology_scope.

(** ------------------------------------------------------------------------ *)

(** * Exercise 4.2.3.2 *)
Section Exercise_4_2_3_2.
  Require Import ClassicalFacts.

  (** ** Problem *)
  (** Explain how "looking at points" gives a functor [Top -> Set]. Does
      "looking at open sets" give a functor [Top -> PrO]? *)
  (** ** Solution *)
  (** Every topology has an underlying set of points, and every
      continuous function is a function on these sets.  Looking at
      open sets gives a functor [Top -> PrO ᵒᵖ] where the open sets
      are ordered by inclusion.  There is not an obvious functor [Top
      -> PrO] given by looking at open sets; taking interiors doesn't
      work with composition.  There might be a functor [Top -> PrO]
      given by looking at closed sets and closure, but I haven't
      looked in to that. *)

  Definition UnderlyingPoints : Functor CategoryOfTopologies CategoryOfTypes.
    refine {| ObjectOf := (fun X : CategoryOfTopologies =>
                             X : CategoryOfTypes);
              MorphismOf := (fun s d (m : Morphism CategoryOfTopologies s d) =>
                               proj1_sig m : Morphism CategoryOfTypes _ _) |};
    reflexivity.
  Defined.

  Record > EOpenSet `(Topology X) :=
    {
      OpenSetSet :> Ensemble X;
      OpenSetOpen :> Open OpenSetSet
    }.

  Lemma OpenSet_eq `(T : Topology X) (A B : EOpenSet T)
  : OpenSetSet A = OpenSetSet B
    -> A = B.
    destruct A, B; simpl; intro; subst; f_equal; apply ProofIrrelevance.proof_irrelevance.
  Qed.

  Global Instance opens_ordered_by_inclusion `(Topology X) : @PreOrder (EOpenSet _) (fun U V => U ⊆ V).
    split; firstorder.
  Qed.

  Definition continuous_induced_functor_object_of s d (m : Morphism CategoryOfTopologies s d)
  : (opens_ordered_by_inclusion d) -> (opens_ordered_by_inclusion s).
    intro; hnf in *.
    exists (inverse_image (proj1_sig m) X);
      simpl.
    abstract (
        destruct m as [f c];
        apply c;
        destruct X;
        assumption
      ).
  Defined.

  Definition continuous_induced_functor_morphism_of s d (m : Morphism CategoryOfTopologies s d)
  : forall s' d' (m' : Morphism (PreOrderCategory (opens_ordered_by_inclusion d)) s' d'),
      Morphism (PreOrderCategory (opens_ordered_by_inclusion s))
               (continuous_induced_functor_object_of m s')
               (continuous_induced_functor_object_of m d').
    intros s' d' m' x H.
    hnf in m, m'.
    simpl in *.
    destruct m as [ f c ]; simpl in *.
    repeat unfold In, inverse_image in *.
    intuition.
  Qed.

  Definition continuous_induced_functor s d (m : Morphism CategoryOfTopologies s d)
  : Morphism CategoryOfPreOrders (opens_ordered_by_inclusion d) (opens_ordered_by_inclusion s).
    refine {| ObjectOf := (continuous_induced_functor_object_of m);
              MorphismOf := (continuous_induced_functor_morphism_of m) |};
    abstract (intros; simpl; apply ProofIrrelevance.proof_irrelevance).
  Defined.

  (** Here's the open-set functor *)
  Definition PreOrderedSets : Functor CategoryOfTopologies (OppositeCategory CategoryOfPreOrders).
    refine (Build_Functor CategoryOfTopologies (OppositeCategory CategoryOfPreOrders)
                          (fun x => opens_ordered_by_inclusion x)
                          continuous_induced_functor
                          _
                          _);
    abstract (repeat (
                  reflexivity
                    || (progress (simpl; intros; expand))
                    || (progress destruct_head_hnf @EOpenSet)
                    || (apply f_equal)
                    || (apply ProofIrrelevance.proof_irrelevance)
                    || (apply proof_irrelevance_JMeq)
                    || (apply Functor_Eq)
                )).
  Defined.

(*  (** And now we begin playing with closures *)
  Definition continuous_induced_functor_object_of_interior s d (m : Morphism CategoryOfTopologies s d)
  : (opens_ordered_by_inclusion s) -> (opens_ordered_by_inclusion d).
    intro; hnf in *.
    exists (interior d (image (proj1_sig m) X));
      simpl.
    abstract apply interior_open.
  Defined.

  Definition continuous_induced_functor_morphism_of_interior s d (m : Morphism CategoryOfTopologies s d)
  : forall s' d' (m' : Morphism (PreOrderCategory (opens_ordered_by_inclusion s)) s' d'),
      Morphism (PreOrderCategory (opens_ordered_by_inclusion d))
               (continuous_induced_functor_object_of_interior m s')
               (continuous_induced_functor_object_of_interior m d').
    intros s' d' m' x H.
    hnf in m, m'.
    simpl in *.
    destruct m as [ f c ]; simpl in *.
    destruct_head_hnf ArbitraryUnion.
    destruct_head_hnf and.
    exists Xj;
      firstorder.
  Qed.

  Definition continuous_induced_functor_interior s d (m : Morphism CategoryOfTopologies s d)
  : Morphism CategoryOfPreOrders (opens_ordered_by_inclusion s) (opens_ordered_by_inclusion d).
    refine {| ObjectOf := (continuous_induced_functor_object_of_interior m);
              MorphismOf := (@continuous_induced_functor_morphism_of_interior _ _ m) |};
    abstract (intros; simpl; apply ProofIrrelevance.proof_irrelevance).
  Defined.

  Variable prop_extensionality : prop_extensionality.

  Definition PreOrderedSetsByInterior : Functor CategoryOfTopologies CategoryOfPreOrders.
    refine (Build_Functor CategoryOfTopologies CategoryOfPreOrders
                          (fun x => opens_ordered_by_inclusion x)
                          continuous_induced_functor_interior
                          _
                          _).
    Focus 2.
    intro x.
    simpl.
    apply Functor_Eq.
     (repeat (
                  reflexivity
                    || (progress (simpl; intros; expand))
                    || (progress destruct_head_hnf @EOpenSet)
                    || (progress destruct_head_hnf @ArbitraryUnion)
                    || (progress destruct_head_hnf @and)
                    || (apply OpenSet_eq)
                    || (apply Extensionality_Ensembles)
                    || intro
                    || split
                    || constructor
                    || (apply f_equal)
                    || (apply proof_irrelevance)
                    || (apply proof_irrelevance_JMeq)
                    || (apply Functor_Eq)
                ));
     try match goal with
           | [ d' : _ |- context[image ?f ?X] ] =>
             (exists (Xj ∩ interior d' (image f X)))
         end;
     (repeat (
          reflexivity
            || (progress (simpl; intros; expand))
            || (progress destruct_head_hnf @EOpenSet)
            || (progress destruct_head_hnf @ArbitraryUnion)
            || (progress destruct_head_hnf @and)
            || (apply OpenSet_eq)
            || (apply Extensionality_Ensembles)
            || intro
            || split
            || constructor
            || (apply f_equal)
            || (apply proof_irrelevance)
            || (apply proof_irrelevance_JMeq)
            || (apply Functor_Eq)
            || assumption
            || (eexists; try eassumption; solve [ firstorder ])
            || (progress trivial)
            || (progress constructor)
            || (progress (etransitivity; eassumption); instantiate)
            || (progress destruct_head_hnf ArbitraryUnion)
            || (progress destruct_head_hnf and)
            || (progress destruct_head_hnf @Intersection)
            || (apply Intersection_Included_morr)
            || (apply FiniteIntersectionOpen)
            || (apply interior_open)
     ));
     try match goal with
           | [ H : _, H' : _ |- _ ] => rewrite H in H'; firstorder; subst; firstorder solve [ trivial ]
         end.

     simpl.
     intros.
     expand.
     simpl.
     apply proof_irrelevance_JMeq.
     simpl.
     apply prop_extensionality.
     split; intro.
     rewrite <- (interior_open_same x d).
     rewrite <- (interior_open_same x s).
     transitivity (interior x (image id s)).
     apply interior_respect_subset; firstorder.
     transitivity (interior x (image id d)).
     assumption.
     apply interior_respect_subset.
     hnf; firstorder; unfold id in *; simpl in *; subst; firstorder.
     destruct s; assumption.
     destruct d; assumption.
     transitivity (interior x s).
     apply interior_respect_subset; hnf in *; unfold id in *; simpl in *; subst; firstorder; subst; firstorder.
     transitivity (interior x d).
     apply interior_respect_subset; hnf in *; unfold id in *; simpl in *; subst; firstorder; subst; firstorder.
     apply interior_respect_subset; hnf in *; unfold id in *; simpl in *; subst; firstorder; subst; firstorder.


     intros s d d'.
     intros m1 m2.
     hnf in m1, m2.
     simpl.
     apply Functor_Eq.
          (repeat (
                  reflexivity
                    || (progress (simpl; intros; expand))
                    || (progress destruct_head_hnf @EOpenSet)
                    || (progress destruct_head_hnf @ArbitraryUnion)
                    || (progress destruct_head_hnf @and)
                    || (apply OpenSet_eq)
                    || (apply Extensionality_Ensembles)
                    || intro
                    || split
                    || constructor
                    || (apply f_equal)
                    || (apply proof_irrelevance)
                    || (apply proof_irrelevance_JMeq)
                    || (apply Functor_Eq)
                ));
     try match goal with
           | [ d' : _ |- context[image ?f ?X] ] =>
             (exists (Xj ∩ interior d' (image f X)))
         end;
     (repeat (
          reflexivity
            || (progress (simpl; intros; expand))
            || (progress destruct_head_hnf @EOpenSet)
            || (progress destruct_head_hnf @ArbitraryUnion)
            || (progress destruct_head_hnf @and)
            || (apply OpenSet_eq)
            || (apply Extensionality_Ensembles)
            || intro
            || split
            || constructor
            || (apply f_equal)
            || (apply proof_irrelevance)
            || (apply proof_irrelevance_JMeq)
            || (apply Functor_Eq)
            || assumption
            || (eexists; try eassumption; solve [ firstorder ])
            || (progress trivial)
            || (progress constructor)
            || (progress (etransitivity; eassumption); instantiate)
            || (progress destruct_head_hnf ArbitraryUnion)
            || (progress destruct_head_hnf and)
            || (progress destruct_head_hnf @Intersection)
            || (apply Intersection_Included_morr)
            || (apply FiniteIntersectionOpen)
            || (apply interior_open)
     ));
     try match goal with
           | [ H : _, H' : _ |- _ ] => rewrite H in H'; firstorder; subst; firstorder solve [ trivial ]
         end.
     expand.

     apply f_equal.
     match goal with
       | [
     rewrite
     apply Pr
     match goal with
       | [
     Set Printing All.
     unfold continuous_induced_functor_morphism_of_interior.
     destruct m.
     compute.
     apply forall_extensionality_dep.
     unfold id.
     eexists; try eassumption; firstorder.
     unfold image, id in *; simpl in *.
     exists OpenSetSet0.
     hnf. firstorder.
     rewrite H in H0.
     firstorder.
     hnf in *.
    Focus 3.

    compute.
    apply
    apply proof_irrelevance.


    rewrite H3 in H4.
    assumption.
    rewrite H in H2.
    firstorder.
    hnf;
    hnf.
    constructor.
    match goal with | [ |- @eq ?T _ _ ] => pose T end.
    Set Printing Coercions.
    apply f_equal.
    apply proof_irrelevance.
  Defined. *)
End Exercise_4_2_3_2.
Module Exercise_4_2_3_2_continuity_bad.
  (** Here's a proof that continuous functions don't necesarily
      respect openness *)
  Inductive Three := A | B | C.

  Definition ThreeTopology1 : Topology Three
    := DiscreteTopology _.
  Definition ThreeTopology2 : Topology Three
    := IndiscreteTopology _.

  Definition f := @id Three.
  Definition continuous_function_continuous : continuous ThreeTopology1 ThreeTopology2 f.
    repeat intro; constructor.
  Defined.

  Lemma f_not_preserve_open : exists S,
                                @Open _ ThreeTopology1 S /\ ~@Open _ ThreeTopology2 (image f S).
    exists (fun x => match x with
                       | A => True
                       | _ => False
                     end);
    abstract (
        simpl; intuition; firstorder subst;
        fg_equal;
        repeat match goal with
                 | [ H : _ |- _ ] => pose proof (H A);
                 pose proof (H B);
                 pose proof (H C);
                 clear H
                 | [ H : @eq Prop ?a ?b |- _ ] => let H' := fresh in
                                                  assert (H' : a <-> b) by (rewrite H; firstorder);
                 clear H;
                 destruct H';
                 intuition
                 | [ H : forall _ : ?T, _ |- _ ] => match type of T with
                                                      | Prop => let t := fresh in
                                                                assert (t : T) by (repeat esplit; try reflexivity; trivial);
                                                      specialize (H t)
                                                    end
                 | _ => progress compute in *
                 | _ => progress destruct_head_hnf @ex
                 | _ => progress destruct_head_hnf @and
                 | _ => progress intuition subst
               end
      ).
  Qed.
End Exercise_4_2_3_2_continuity_bad.

(** ------------------------------------------------------------------------ *)
